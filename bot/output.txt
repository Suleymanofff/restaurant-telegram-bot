=== .env ===
BOT_TOKEN=7385257320:AAH6hAAWQgAJXZv_hogPc7elkZ7uoT6Z3zA
DATABASE_URL=postgresql://garun:origami@localhost/restaurant_bot_with_payment
# POSTGRES_USERNAME=garun
# POSTGRES_PASSWORD=origami
# POSTGRES_HOST=localhost
# POSTGRES_PORT=5432
# POSTGRES_NAME=restaurant_db

# # Для разработки:
# LOG_LEVEL=INFO
# LOG_FORMAT=colored
# ENABLE_FILE_LOGGING=true

# # Для отладки:
# LOG_LEVEL=DEBUG
# LOG_FORMAT=simple
# ENABLE_FILE_LOGGING=true

# Для продакшена:
LOG_LEVEL=WARNING
LOG_FORMAT=json
ENABLE_FILE_LOGGING=true


# Restaurant location
RESTAURANT_ADDRESS=Москва, ул. Тверская, 25
RESTAURANT_LATITUDE=55.7603
RESTAURANT_LONGITUDE=37.6185


ADMIN_IDS=5170209314
STAFF_IDS=5170209314,7553841581


=== main.py ===
import asyncio
import os
from pathlib import Path

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.client.session.aiohttp import AiohttpSession
from fluent.runtime import FluentLocalization, FluentResourceLoader

# Импорты из вашего проекта
from src.utils.config import settings
from src.utils.logger import setup_logging, get_logger
from src.handlers import router as main_router
from src.database.db_manager import DatabaseManager
from src.utils.reminders import start_reminder_system, stop_reminder_system
from src.utils.rate_limiter import rate_limiter
from src.middlewares.fsm_middleware import FSMMiddleware
from src.utils.fsm_cleanup import start_fsm_cleanup

# Инициализация менеджера базы данных
db_manager = DatabaseManager()

# Инициализация логирования ДО создания логгера
setup_logging(
    log_level=settings.LOG_LEVEL,
    log_format=settings.LOG_FORMAT,
    enable_file_logging=settings.ENABLE_FILE_LOGGING
)

# Получаем логгер
logger = get_logger(__name__)

# Инициализация системы локализации
loader = FluentResourceLoader("src/i18n/{locale}")
l10n = FluentLocalization(["ru"], ["text.ftl", "button.ftl"], loader)

async def init_database():
    """Инициализация базы данных"""
    try:
        logger.info("🗄️ Initializing database connection...")
        
        # Получаем DSN из настроек или используем значение по умолчанию
        dsn = getattr(settings, 'DATABASE_URL', 'postgresql://garun:origami@localhost/restaurant_bot_with_payment')
        
        await db_manager.init_pool(dsn)
        
        # Проверяем соединение
        if await db_manager.health_check():
            logger.info("✅ Database connected successfully")
            return True
        else:
            logger.error("❌ Database health check failed")
            return False
            
    except Exception as e:
        logger.error(f"❌ Failed to initialize database: {e}", exc_info=True)
        return False

async def close_database():
    """Закрытие соединения с базой данных"""
    try:
        await db_manager.close_pool()
        logger.info("✅ Database connection closed")
    except Exception as e:
        logger.error(f"❌ Error closing database connection: {e}")


async def cleanup_rate_limits():
    """Периодическая очистка старых записей rate limiting"""
    while True:
        await asyncio.sleep(3600)  # Каждый час
        rate_limiter.cleanup_old_entries()
        logger.debug("🧹 Очищены старые записи rate limiting")


async def init_default_admins(db_manager: DatabaseManager):
    """Добавление администраторов из .env в базу данных"""
    try:
        admin_ids = [int(admin_id.strip()) for admin_id in settings.ADMIN_IDS.split(",")]
        staff_ids = [int(staff_id.strip()) for staff_id in settings.STAFF_IDS.split(",")]
        
        for admin_id in admin_ids:
            await db_manager.add_admin(admin_id, "admin", "Default Admin")
            logger.info(f"✅ Added default admin: {admin_id}")
        
        for staff_id in staff_ids:
            await db_manager.add_staff(staff_id, "staff", "Default Staff")
            logger.info(f"✅ Added default staff: {staff_id}")
            
    except Exception as e:
        logger.error(f"❌ Failed to init default admins: {e}")

async def main():
    logger.info("🚀 Starting Restaurant Bot...")
    
    try:
        # Инициализация базы данных
        db_initialized = await init_database()
        if not db_initialized:
            logger.warning("⚠️  Database not initialized, some features may not work")
        else:
            # Добавляем администраторов по умолчанию
            await init_default_admins(db_manager)
        
        # Логируем информацию о боте
        logger.info("🤖 Initializing bot with token: %s...", settings.BOT_TOKEN[:10] + "..." if settings.BOT_TOKEN else "None")
        
        session = AiohttpSession()
        bot = Bot(
            token=settings.BOT_TOKEN,
            session=session,
            default=DefaultBotProperties(parse_mode="HTML")
        )

        dp = Dispatcher()

        # 🔥 ДОБАВЛЯЕМ MIDDLEWARE ДЛЯ FSM
        dp.message.middleware(FSMMiddleware())
        dp.callback_query.middleware(FSMMiddleware())
        
        # Передаем l10n и db_manager в диспетчер через work_data
        dp.workflow_data.update({
            "l10n": l10n,
            "db_manager": db_manager,
            "settings": settings
        })
        
        # Регистрируем роутеры
        dp.include_router(main_router)

        # Запускаем систему напоминаний
        await start_reminder_system(bot, db_manager)
        logger.info("🔔 Reminder system started")

        # 🆕 ЗАПУСКАЕМ CLEANUP RATE LIMITING (после создания бота)
        asyncio.create_task(cleanup_rate_limits())
        logger.info("🧹 Rate limiting cleanup task started")

        # 🔥 ЗАПУСКАЕМ FSM CLEANUP SERVICE
        await start_fsm_cleanup(dp.storage)
        logger.info("🧹 FSM cleanup service started")
        
        # Получаем информацию о зарегистрированных хэндлерах
        logger.info("📋 Registered %s routers", len(dp.sub_routers))
        
        logger.info("✅ Bot initialized successfully")
        logger.info("📡 Starting polling...")
        
        await dp.start_polling(bot)
        
    except ValueError as e:
        logger.error("❌ Configuration error: %s", e, exc_info=True)
    except KeyError as e:
        logger.error("❌ Key error: %s", e, exc_info=True)
    except Exception as e:
        logger.critical("💥 Critical error during bot operation: %s", e, exc_info=True)
        raise
    finally:
        logger.info("🛑 Bot stopped")
        await close_database()  # Закрываем соединение с БД
        if 'bot' in locals():
            await bot.session.close()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("👋 Bot interrupted by user")
        os.system("cls" if os.name == 'nt' else "clear")
    except Exception as e:
        logger.critical("💥 Fatal error during bot startup: %s", e, exc_info=True)

=== requirements.txt ===
aiofiles==24.1.0
aiogram==3.22.0
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
annotated-types==0.7.0
asyncpg==0.30.0
attrs==25.3.0
babel==2.17.0
certifi==2025.8.3
dotenv==0.9.9
fluent==0.10.0
fluent-compiler==1.1
fluent.runtime==0.4.0
fluent.syntax==0.19.0
fluentogram==1.2.1
frozenlist==1.7.0
idna==3.10
magic-filter==1.0.12
multidict==6.6.4
propcache==0.3.2
psutil==7.1.0
pydantic==2.11.9
pydantic-settings==2.11.0
pydantic_core==2.33.2
python-dotenv==1.1.1
python-i18n==0.3.9
pytz==2025.2
typing-inspection==0.4.2
typing_extensions==4.15.0
yarl==1.20.1
openpyxl==3.1.2

=== db_backup/backup_1.sql ===
-- =============================================
-- BACKUP SCRIPT FOR RESTAURANT BOT DATABASE
-- =============================================

-- Удаляем таблицы в правильном порядке (с учетом внешних ключей)
DROP TABLE IF EXISTS referral_bonuses CASCADE;
DROP TABLE IF EXISTS menu_views CASCADE;
DROP TABLE IF EXISTS user_actions CASCADE;
DROP TABLE IF EXISTS broadcasts CASCADE;
DROP TABLE IF EXISTS staff_calls CASCADE;
DROP TABLE IF EXISTS reservations CASCADE;
DROP TABLE IF EXISTS delivery_orders CASCADE;
DROP TABLE IF EXISTS payment_receipts CASCADE;
DROP TABLE IF EXISTS bonus_transactions CASCADE;
DROP TABLE IF EXISTS admin_users CASCADE;
DROP TABLE IF EXISTS staff_users CASCADE;
DROP TABLE IF EXISTS delivery_menu CASCADE;
DROP TABLE IF EXISTS users CASCADE;

-- Удаляем функцию обновления updated_at
DROP FUNCTION IF EXISTS update_updated_at_column CASCADE;

-- =============================================
-- СОЗДАНИЕ ТАБЛИЦ
-- =============================================

-- Таблица пользователей (с реферальными полями и балансом)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    user_id BIGINT UNIQUE NOT NULL,
    username VARCHAR(255),
    full_name VARCHAR(255) NOT NULL,
    sex VARCHAR(10) CHECK (sex IN ('male', 'female', 'other', 'unknown')),
    major VARCHAR(50) CHECK (major IN ('student', 'entrepreneur', 'hire', 'frilans', 'other', 'unknown')),
    language_code VARCHAR(10) DEFAULT 'ru',
    is_blocked BOOLEAN DEFAULT FALSE,
    
    -- Реферальные поля
    referrer_id BIGINT,
    referral_code VARCHAR(20) UNIQUE,
    referral_count INTEGER DEFAULT 0,
    total_referral_bonus DECIMAL(10,2) DEFAULT 0,
    
    -- Личный счет пользователя
    bonus_balance DECIMAL(10,2) DEFAULT 0,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (referrer_id) REFERENCES users(user_id) ON DELETE SET NULL
);

-- Таблица администраторов
CREATE TABLE admin_users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(255),
    full_name VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- Таблица официантов  
CREATE TABLE staff_users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(255),
    full_name VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- Таблица реферальных бонусов
CREATE TABLE referral_bonuses (
    id SERIAL PRIMARY KEY,
    referrer_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    referred_id BIGINT NOT NULL UNIQUE REFERENCES users(user_id) ON DELETE CASCADE,
    bonus_amount DECIMAL(10,2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'cancelled')),
    order_id INTEGER, -- ID заказа, за который начислен бонус
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Таблица бронирований
CREATE TABLE reservations (
    id SERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    reservation_date DATE NOT NULL,
    reservation_time TIME NOT NULL,
    guests_count INTEGER NOT NULL CHECK (guests_count > 0 AND guests_count <= 20),
    customer_name VARCHAR(255) NOT NULL,
    customer_phone VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed')),
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Таблица вызовов персонала
CREATE TABLE staff_calls (
    id SERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    table_number INTEGER NOT NULL CHECK (table_number > 0 AND table_number <= 99),
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'completed', 'cancelled')),
    notes TEXT,
    accepted_by_name VARCHAR(255),  -- Имя официанта
    accepted_by BIGINT,             -- ID официанта
    message_ids JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    accepted_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    cancelled_at TIMESTAMP WITH TIME ZONE
);

-- Таблица рассылок
CREATE TABLE broadcasts (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    message_text TEXT NOT NULL,
    message_type VARCHAR(20) DEFAULT 'text',
    image_file_id VARCHAR(500),
    buttons JSONB,
    target_sex VARCHAR(10) CHECK (target_sex IN ('male', 'female', 'all')),
    target_major VARCHAR(50) CHECK (target_major IN ('student', 'entrepreneur', 'hire', 'frilans', 'all')),
    sent_count INTEGER DEFAULT 0,
    total_count INTEGER DEFAULT 0,
    read_count INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'sending', 'completed', 'cancelled')),
    scheduled_at TIMESTAMP WITH TIME ZONE,
    sent_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Таблица действий пользователей
CREATE TABLE user_actions (
    id SERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    action_type VARCHAR(50) NOT NULL,
    action_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Таблица просмотров меню
CREATE TABLE menu_views (
    id SERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    category VARCHAR(50) NOT NULL,
    view_count INTEGER DEFAULT 1,
    last_viewed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, category)
);

-- Таблица заказов доставки (добавляем поля для скидок и бонусов)
CREATE TABLE delivery_orders (
    id SERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
    order_data JSONB NOT NULL,

    -- Основная информация о статусе
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'preparing', 'on_way', 'delivered', 'cancelled')),
    priority INTEGER DEFAULT 1 CHECK (priority IN (1, 2, 3)), -- 1=normal, 2=medium, 3=high

    -- Информация о клиенте (дублируется в order_data для быстрого поиска)
    customer_name VARCHAR(255) NOT NULL,
    customer_phone VARCHAR(20) NOT NULL,
    delivery_address TEXT NOT NULL,
    delivery_time TEXT, -- Предпочтительное время доставки
    customer_notes TEXT, -- Пожелания клиента

    -- ПОЛЯ ДЛЯ ОПЛАТЫ
    payment_method VARCHAR(20) DEFAULT 'cash' CHECK (payment_method IN ('cash','card','bank_transfer')),
    payment_status VARCHAR(20) DEFAULT 'pending' CHECK (payment_status IN ('pending','confirmed','rejected')),
    payment_notes TEXT,
    payment_transaction_id TEXT, -- внешний ID платежа / reference from provider
    payment_attempts INTEGER DEFAULT 0, -- количество попыток оплаты/прикрепления квитанций

    -- audit поля для подтверждения/отклонения платежа
    payment_confirmed_by BIGINT, -- admin id
    payment_confirmed_at TIMESTAMP WITH TIME ZONE,
    payment_rejected_by BIGINT,
    payment_rejected_at TIMESTAMP WITH TIME ZONE,
    payment_reject_reason TEXT,

    -- Финансовая информация
    total_amount DECIMAL(10,2) NOT NULL,
    discount_amount DECIMAL(10,2) DEFAULT 0, -- Скидка по реферальной программе
    bonus_used DECIMAL(10,2) DEFAULT 0, -- Использовано бонусов
    final_amount DECIMAL(10,2) NOT NULL, -- Итоговая сумма к оплате

    -- Назначение ответственных
    assigned_cook BIGINT, -- ID повара (ссылка на users)
    assigned_courier BIGINT, -- ID курьера (ссылка на users)

    -- Временные метки и расчёты
    estimated_delivery_time INTEGER, -- Предполагаемое время доставки в минутах
    preparation_time INTEGER, -- Время приготовления в минутах
    actual_delivery_time TIMESTAMP WITH TIME ZONE, -- Фактическое время доставки

    -- Системные поля
    delivery_notes TEXT, -- Внутренние заметки для курьера/повара
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);


-- New table for receipts
CREATE TABLE IF NOT EXISTS payment_receipts (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES delivery_orders(id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL,
    file_id TEXT NOT NULL, -- file_id Telegram
    note TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Таблица элементов меню доставки
CREATE TABLE delivery_menu (
    id SERIAL PRIMARY KEY,
    category VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    image_url VARCHAR(500),
    is_available BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Таблица для бонусных транзакций
CREATE TABLE bonus_transactions (
    id SERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    order_id INTEGER REFERENCES delivery_orders(id) ON DELETE SET NULL,
    amount DECIMAL(10,2) NOT NULL, -- положительное = начисление, отрицательное = списание
    type VARCHAR(50) NOT NULL, -- 'cashback', 'purchase', 'referral', 'manual'
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =============================================
-- ИНДЕКСЫ ДЛЯ ПРОИЗВОДИТЕЛЬНОСТИ
-- =============================================

-- Индексы для users
CREATE INDEX idx_users_user_id ON users(user_id);
CREATE INDEX idx_users_sex ON users(sex);
CREATE INDEX idx_users_major ON users(major);
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_users_blocked ON users(is_blocked);
CREATE INDEX idx_users_referral_code ON users(referral_code);
CREATE INDEX idx_users_referrer_id ON users(referrer_id);

-- Индексы для bonus_transactions
CREATE INDEX idx_bonus_transactions_user_id ON bonus_transactions(user_id);
CREATE INDEX idx_bonus_transactions_created ON bonus_transactions(created_at);
CREATE INDEX idx_bonus_transactions_type ON bonus_transactions(type);

-- Индексы для referral_bonuses
CREATE INDEX idx_referral_bonuses_referrer ON referral_bonuses(referrer_id);
CREATE INDEX idx_referral_bonuses_referred ON referral_bonuses(referred_id);
CREATE INDEX idx_referral_bonuses_status ON referral_bonuses(status);

-- Индексы для reservations
CREATE INDEX idx_reservations_user_id ON reservations(user_id);
CREATE INDEX idx_reservations_date ON reservations(reservation_date);
CREATE INDEX idx_reservations_status ON reservations(status);
CREATE INDEX idx_reservations_created_at ON reservations(created_at);

-- Индексы для staff_calls
CREATE INDEX idx_staff_calls_status ON staff_calls(status);
CREATE INDEX idx_staff_calls_created ON staff_calls(created_at);
CREATE INDEX idx_staff_calls_user ON staff_calls(user_id);
CREATE INDEX idx_staff_calls_table ON staff_calls(table_number);

-- Индексы для user_actions
CREATE INDEX idx_user_actions_user_id ON user_actions(user_id);
CREATE INDEX idx_user_actions_type ON user_actions(action_type);
CREATE INDEX idx_user_actions_created_at ON user_actions(created_at);

-- Индексы для menu_views
CREATE INDEX idx_menu_views_user_id ON menu_views(user_id);
CREATE INDEX idx_menu_views_category ON menu_views(category);

-- Индексы для broadcasts
CREATE INDEX idx_broadcasts_status ON broadcasts(status);
CREATE INDEX idx_broadcasts_scheduled ON broadcasts(scheduled_at);
CREATE INDEX idx_broadcasts_type ON broadcasts(message_type);
CREATE INDEX idx_broadcasts_created ON broadcasts(created_at);

-- Индексы для delivery
CREATE INDEX idx_delivery_orders_status ON delivery_orders(status);
CREATE INDEX idx_delivery_orders_created ON delivery_orders(created_at);
CREATE INDEX idx_delivery_menu_category ON delivery_menu(category);
CREATE INDEX idx_delivery_menu_available ON delivery_menu(is_available);

-- =============================================
-- ТРИГГЕРЫ
-- =============================================

-- Функция для автоматического обновления updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Триггер для users
CREATE TRIGGER update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Триггер для reservations
CREATE TRIGGER update_reservations_updated_at 
    BEFORE UPDATE ON reservations 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Триггер для updated_at в delivery
CREATE TRIGGER update_delivery_orders_updated_at 
    BEFORE UPDATE ON delivery_orders 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- ТЕСТОВЫЕ ДАННЫЕ
-- =============================================

-- Очищаем последовательности (если нужно сбросить ID)
ALTER SEQUENCE users_id_seq RESTART WITH 1;
ALTER SEQUENCE referral_bonuses_id_seq RESTART WITH 1;
ALTER SEQUENCE reservations_id_seq RESTART WITH 1;
ALTER SEQUENCE staff_calls_id_seq RESTART WITH 1;
ALTER SEQUENCE broadcasts_id_seq RESTART WITH 1;
ALTER SEQUENCE user_actions_id_seq RESTART WITH 1;
ALTER SEQUENCE menu_views_id_seq RESTART WITH 1;
ALTER SEQUENCE delivery_orders_id_seq RESTART WITH 1;
ALTER SEQUENCE delivery_menu_id_seq RESTART WITH 1;

-- Сначала создаем базовых пользователей
INSERT INTO users (user_id, username, full_name, language_code) VALUES
(5170209314, 'admin', 'Администратор', 'ru'),
(7553841581, 'staff', 'Официант', 'ru')
ON CONFLICT (user_id) DO UPDATE SET
    username = EXCLUDED.username,
    full_name = EXCLUDED.full_name,
    language_code = EXCLUDED.language_code;

-- Тестовые данные для меню доставки
INSERT INTO delivery_menu (category, name, description, price) VALUES
('breakfasts', 'Сырники с малиновым соусом', 'Нежные творожные сырники с хрустящей корочкой и свежим ягодным соусом', 450.00),
('breakfasts', 'Авокадо-тост с лососем', 'Хрустящий тост с пюре из авокадо и слабосоленым лососем', 520.00),
('breakfasts', 'Омлет с шампиньонами', 'Пышный омлет с нежными шампиньонами и сыром', 380.00),
('breakfasts', 'Гранола с йогуртом', 'Хрустящая домашняя гранола с греческим йогуртом и ягодами', 420.00),
('breakfasts', 'Блины с кленовым сиропом', 'Тонкие воздушные блины с ароматным кленовым сиропом', 390.00),
('hots', 'Стейк из мраморной говядины', 'Сочный стейк средней прожарки с розмарином и овощами гриль', 1200.00),
('hots', 'Лосось в медово-соевом соусе', 'Нежное филе лосося в пикантном медово-соевом глазури', 890.00),
('hots', 'Утка с апельсиновым соусом', 'Хрустящая утиная грудка с цитрусовым соусом и пюре', 950.00),
('hots', 'Рагу из телятины', 'Ароматное рагу из нежной телятины с сезонными овощами', 680.00),
('hots', 'Куриные медальоны', 'Нежные куриные медальоны в сливочном соусе с грибами', 580.00),
('hot_drinks', 'Эспрессо', 'Классический крепкий эспрессо из арабики', 180.00),
('hot_drinks', 'Капучино', 'Идеальный баланс эспрессо и воздушной молочной пенки', 250.00),
('hot_drinks', 'Латте с сиропом', 'Нежный кофейный напиток с выбором сиропов', 320.00),
('hot_drinks', 'Чай матча', 'Традиционный японский зеленый чай с нежным вкусом', 280.00),
('hot_drinks', 'Горячий шоколад', 'Насыщенный шоколадный напиток со взбитыми сливками', 350.00),
('cold_drinks', 'Мохито', 'Освежающий коктейль с лаймом и мятой', 330.00),
('cold_drinks', 'Фраппе', 'Холодный кофейный коктейль со льдом', 340.00),
('cold_drinks', 'Лимонад ягодный', 'Домашний лимонад со свежими ягодами и мятой', 290.00),
('cold_drinks', 'Смузи тропический', 'Фруктовый смузи с манго, бананом и кокосом', 320.00),
('cold_drinks', 'Айс ти', 'Освежающий холодный чай с лимоном и персиком', 260.00),
('deserts', 'Тирамису', 'Классический итальянский десерт с кофейным вкусом', 480.00),
('deserts', 'Чизкейк Нью-Йорк', 'Нежный чизкейк с ягодным топпингом', 520.00),
('deserts', 'Фондан', 'Шоколадный кекс с текучей начинкой', 450.00),
('deserts', 'Крем-брюле', 'Нежный крем с хрустящей карамельной корочкой', 420.00),
('deserts', 'Яблочный штрудель', 'Тонкое тесто с яблочной начинкой и корицей', 380.00)

ON CONFLICT (id) DO UPDATE SET
    category = EXCLUDED.category,
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    price = EXCLUDED.price;

-- Вставляем текущих админов и стафф (после создания пользователей)
INSERT INTO admin_users (user_id, username, full_name) 
VALUES 
(5170209314, 'admin', 'Администратор')
ON CONFLICT (user_id) DO UPDATE SET
    username = EXCLUDED.username,
    full_name = EXCLUDED.full_name;

INSERT INTO staff_users (user_id, username, full_name) 
VALUES 
(5170209314, 'admin', 'Администратор'),
(7553841581, 'staff', 'Официант')
ON CONFLICT (user_id) DO UPDATE SET
    username = EXCLUDED.username,
    full_name = EXCLUDED.full_name;

-- =============================================
-- ПРОВЕРОЧНЫЕ ЗАПРОСЫ
-- =============================================

-- Проверяем количество записей в таблицах
SELECT 'users' as table_name, COUNT(*) as record_count FROM users
UNION ALL
SELECT 'admin_users', COUNT(*) FROM admin_users
UNION ALL
SELECT 'staff_users', COUNT(*) FROM staff_users
UNION ALL
SELECT 'referral_bonuses', COUNT(*) FROM referral_bonuses
UNION ALL
SELECT 'bonus_transactions', COUNT(*) FROM bonus_transactions
UNION ALL
SELECT 'reservations', COUNT(*) FROM reservations
UNION ALL
SELECT 'staff_calls', COUNT(*) FROM staff_calls
UNION ALL
SELECT 'user_actions', COUNT(*) FROM user_actions
UNION ALL
SELECT 'menu_views', COUNT(*) FROM menu_views
UNION ALL
SELECT 'broadcasts', COUNT(*) FROM broadcasts
UNION ALL
SELECT 'delivery_orders', COUNT(*) FROM delivery_orders
UNION ALL
SELECT 'delivery_menu', COUNT(*) FROM delivery_menu;

-- =============================================
-- BACKUP ЗАВЕРШЕН
-- =============================================

SELECT '✅ Database backup completed successfully!' as result;

=== logs/bot.log ===
2025-10-12 14:48:39 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 14:48:39 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 14:48:39 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 14:48:40 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 14:48:40 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 14:48:40 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 14:48:40 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 14:48:40 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 14:48:40 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 14:48:40 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 14:48:40 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 14:48:40 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 14:48:40 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 14:48:40 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 14:48:40 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 14:48:40 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 14:48:55 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 14:48:55 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-12 14:49:07 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, username: @Garun_tg)
2025-10-12 14:49:07 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 7553841581
2025-10-12 14:49:30 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 14:49:30 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=700.0, delivery=200, discount=0, total_after_discount=900.0
2025-10-12 14:50:42 - src.handlers.admin.delivery_dashboard - ERROR - delivery_dashboard.py:290 - ❌ Error refreshing dashboard: Telegram server says - Bad Request: there is no text in the message to edit
2025-10-12 14:53:40 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 14:54:01 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 14:54:01 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 14:54:02 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 14:54:02 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 14:54:02 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 14:54:02 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 14:54:05 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 14:54:05 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 14:54:05 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 14:54:06 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 14:54:06 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 14:54:06 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 14:54:06 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 14:54:06 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 14:54:06 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 14:54:06 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 14:54:06 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 14:54:06 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 14:54:06 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 14:54:06 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 14:54:06 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 14:54:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 14:54:09 - src.handlers.admin.delivery_dashboard - ERROR - delivery_dashboard.py:290 - ❌ Error refreshing dashboard: Telegram server says - Bad Request: there is no text in the message to edit
2025-10-12 14:59:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:04:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:09:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:14:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:19:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:24:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:29:06 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:33:19 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 15:33:19 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 15:33:19 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 15:33:19 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 15:33:19 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 15:33:19 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 15:33:38 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 15:33:38 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 15:33:38 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 15:33:39 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 15:33:39 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 15:33:39 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 15:33:39 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 15:33:39 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 15:33:39 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 15:33:39 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 15:33:39 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 15:33:39 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 15:33:39 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 15:33:39 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 15:33:39 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 15:33:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:33:40 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 15:33:40 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 15:33:52 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 15:33:52 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=680.0, delivery=200, discount=0, total_after_discount=880.0
2025-10-12 15:34:06 - src.handlers.user.delivery - INFO - delivery.py:1235 - ✅ Delivery order notification sent to admin 5170209314
2025-10-12 15:34:06 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 15:34:06 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 15:34:54 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 15:34:54 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 15:34:55 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 15:34:55 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 15:34:55 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 15:34:55 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 15:36:57 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 15:36:57 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 15:36:57 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 15:36:58 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 15:36:58 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 15:36:58 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 15:36:58 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 15:36:58 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 15:36:58 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 15:36:59 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 15:36:59 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 15:36:59 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 15:36:59 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 15:36:59 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 15:36:59 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 15:36:59 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:37:07 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 15:37:08 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-12 15:37:25 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, username: @Garun_tg)
2025-10-12 15:37:25 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 7553841581
2025-10-12 15:37:51 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 15:37:51 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=1200.0, delivery=200, discount=0, total_after_discount=1400.0
2025-10-12 15:39:31 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 15:39:31 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-12 15:39:43 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 15:39:43 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 15:40:04 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 15:40:04 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=700.0, delivery=200, discount=0, total_after_discount=900.0
2025-10-12 15:40:26 - src.handlers.user.delivery - INFO - delivery.py:1235 - ✅ Delivery order notification sent to admin 5170209314
2025-10-12 15:40:26 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 15:40:26 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 15:41:07 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 15:41:07 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 15:41:08 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 15:41:08 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 15:41:08 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 15:41:08 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 15:46:59 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 15:46:59 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 15:46:59 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 15:46:59 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 15:46:59 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 15:46:59 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 15:46:59 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 15:46:59 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 15:46:59 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 15:47:00 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 15:47:00 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 15:47:00 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 15:47:00 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 15:47:00 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 15:47:00 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 15:47:00 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:47:29 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 15:47:30 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 15:47:56 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 15:47:56 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=2080.0, delivery=0, discount=0, total_after_discount=2080.0
2025-10-12 15:49:50 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 15:49:50 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 15:49:59 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 15:49:59 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=1200.0, delivery=200, discount=0, total_after_discount=1400.0
2025-10-12 15:50:28 - src.handlers.user.delivery - INFO - delivery.py:1235 - ✅ Delivery order notification sent to admin 5170209314
2025-10-12 15:50:28 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 15:50:28 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 15:51:01 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 15:51:01 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=950.0, delivery=200, discount=0, total_after_discount=1150.0
2025-10-12 15:52:00 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:57:00 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:59:08 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 15:59:08 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 15:59:09 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 15:59:09 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 15:59:09 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 15:59:09 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 15:59:14 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 15:59:14 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 15:59:14 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 15:59:15 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 15:59:15 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 15:59:15 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 15:59:15 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 15:59:15 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 15:59:15 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 15:59:15 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 15:59:15 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 15:59:15 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 15:59:15 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 15:59:15 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 15:59:15 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 15:59:15 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 15:59:29 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 15:59:30 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-12 15:59:53 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, username: @Garun_tg)
2025-10-12 15:59:53 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 7553841581
2025-10-12 16:00:08 - src.handlers.user.delivery - INFO - delivery.py:237 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 16:00:08 - src.handlers.user.delivery - INFO - delivery.py:263 - 🔢 Checkout totals: subtotal=1200.0, delivery=200, discount=0, total_after_discount=1400.0
2025-10-12 16:01:36 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:01:36 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 16:01:37 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 16:01:37 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 16:01:37 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 16:01:37 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 16:05:57 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 16:05:57 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 16:05:57 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 16:05:58 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 16:05:58 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 16:05:58 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 16:05:58 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 16:05:58 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 16:05:58 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 16:05:58 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 16:05:58 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 16:05:58 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 16:05:58 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 16:05:58 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 16:05:58 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 16:05:58 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 16:06:07 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 16:06:11 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 16:06:22 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ClientOSError: [WinError 1236] Подключение к сети было разорвано локальной системой
2025-10-12 16:06:22 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 16:06:49 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 16:06:49 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=1480.0, delivery=200, discount=0, total_after_discount=1680.0
2025-10-12 16:07:49 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:07:49 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 16:07:49 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 16:07:49 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 16:07:49 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 16:07:49 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 16:07:55 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 16:07:55 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 16:07:55 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 16:07:55 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 16:07:55 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 16:07:55 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 16:07:55 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 16:07:55 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 16:07:55 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 16:07:56 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 16:07:56 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 16:07:56 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 16:07:56 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 16:07:56 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 16:07:56 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 16:07:56 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 16:08:23 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 16:08:23 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 16:08:34 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 16:08:34 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=950.0, delivery=200, discount=0, total_after_discount=1150.0
2025-10-12 16:09:40 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 16:09:41 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 16:10:04 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 16:10:04 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=1380.0, delivery=200, discount=0, total_after_discount=1580.0
2025-10-12 16:12:56 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 16:14:28 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:14:28 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 16:14:29 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 16:14:29 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 16:14:29 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 16:14:29 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 16:16:14 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 16:16:14 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 16:16:14 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 16:16:14 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 16:16:14 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 16:16:14 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 16:16:14 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 16:16:14 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 16:16:14 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 16:16:14 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 16:16:14 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 16:16:14 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 16:16:14 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 16:16:14 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 16:16:14 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 16:16:14 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 16:16:52 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 16:16:52 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 16:17:17 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 16:17:17 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=960.0, delivery=200, discount=0, total_after_discount=1160.0
2025-10-12 16:20:09 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:20:09 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 16:20:10 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 16:20:10 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 16:20:10 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 16:20:10 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 16:21:34 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 16:21:34 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 16:21:34 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 16:21:34 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 16:21:34 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 16:21:34 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 16:21:34 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 16:21:34 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 16:21:34 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 16:21:35 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 16:21:35 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 16:21:35 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 16:21:35 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 16:21:35 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 16:21:35 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 16:21:35 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 16:22:15 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, username: @Garun_tg)
2025-10-12 16:22:15 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 7553841581
2025-10-12 16:22:28 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 16:22:28 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=1200.0, delivery=200, discount=0, total_after_discount=1400.0
2025-10-12 16:23:01 - src.handlers.admin.delivery_dashboard - INFO - delivery_dashboard.py:689 - Order #19 status set to 'cancelled' after payment rejected
2025-10-12 16:23:59 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 16:23:59 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 16:24:17 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Гарун [Создание ТГ ботов для ресторанов] (id: 7553841581, rights: ['STAFF'])
2025-10-12 16:24:17 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 7553841581
2025-10-12 16:24:33 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=7553841581, has_referrer=None
2025-10-12 16:24:33 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=660.0, delivery=200, discount=0, total_after_discount=860.0
2025-10-12 16:25:14 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 16:25:14 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 16:25:49 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 16:25:49 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 16:26:35 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 16:27:16 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=5170209314, has_referrer=None
2025-10-12 16:27:16 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=950.0, delivery=200, discount=0, total_after_discount=1150.0
2025-10-12 16:27:32 - src.handlers.user.delivery - INFO - delivery.py:1336 - ✅ Delivery order notification sent to admin 5170209314
2025-10-12 16:27:32 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 16:27:32 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 16:28:22 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 16:28:22 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 16:28:28 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ClientOSError: [WinError 1236] Подключение к сети было разорвано локальной системой
2025-10-12 16:28:28 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 16:28:34 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:28:34 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.385315 seconds and try again... (tryings = 1, bot id = 7385257320)
2025-10-12 16:28:34 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 16:28:34 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 16:28:34 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 16:28:34 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 21:33:46 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 21:33:46 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 21:33:46 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 21:33:46 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 21:33:46 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 21:33:47 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 21:33:47 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 21:33:47 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 21:33:47 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 21:33:47 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 21:33:47 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 21:33:47 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 21:33:47 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 21:33:47 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 21:33:47 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 21:33:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 21:34:09 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 21:34:09 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-12 21:34:16 - src.handlers.user.message - INFO - message.py:190 - 👤 Food menu button from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 21:34:17 - src.handlers.user.message - INFO - message.py:207 - 👤 Food menu shown to user 5170209314
2025-10-12 21:34:21 - src.handlers.user.message - INFO - message.py:254 - 👤 Main_menu->Menu->Hot dishes from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 21:34:21 - src.handlers.user.message - INFO - message.py:276 - 👤 Main_menu->Menu->Hot dishes shown to user 5170209314
2025-10-12 21:34:33 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 21:34:33 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 21:34:37 - src.handlers.user.message - INFO - message.py:409 - 👨‍💼 Staff call initiated by user 5170209314
2025-10-12 21:34:39 - src.handlers.user.message - INFO - message.py:454 - 👨‍💼 Staff call created for user 5170209314 at table 6
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:225 - 📨 Отправка уведомлений персоналу о вызове #1
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:226 - 👥 ID персонала для уведомления: [5170209314, 7553841581]
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:231 - 📤 Отправка сообщения персоналу 5170209314
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:239 - ✅ Сообщение отправлено персоналу 5170209314, message_id: 5861
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:231 - 📤 Отправка сообщения персоналу 7553841581
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:239 - ✅ Сообщение отправлено персоналу 7553841581, message_id: 5862
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:243 - 💾 Сохранение message_ids в БД: {5170209314: 5861, 7553841581: 5862}
2025-10-12 21:34:42 - src.database.db_manager - INFO - db_manager.py:478 - ✅ Message IDs обновлены для вызова #1: {5170209314: 5861, 7553841581: 5862}
2025-10-12 21:34:42 - src.handlers.user.callback - INFO - callback.py:249 - ✅ Message_ids сохранены в БД для вызова #1
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:99 - 🔄 Начало принятия вызова #1 персоналом ГАРУН (ID: 5170209314)
2025-10-12 21:34:43 - src.database.db_manager - INFO - db_manager.py:455 - 📥 Получен вызов #1: статус=pending, message_ids={"5170209314": 5861, "7553841581": 5862}
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:108 - 📊 Статус вызова #1: pending
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:122 - ✅ Вызов #1 принят в БД
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:133 - 📨 Получены message_ids для вызова #1: {'5170209314': 5861, '7553841581': 5862}
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:134 - 🔍 Типы ключей: [<class 'str'>, <class 'str'>]
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:208 - 👤 Получена информация о клиенте: ГАРУН (@garunsuleymanov) 👨💼
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:149 - 🔔 Начинаем уведомление персонала о принятии вызова #1
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:27 - 🔔 Уведомление о принятии вызова #1. Принял: ГАРУН (ID: 5170209314)
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:28 - 📋 Message IDs для обновления: {'5170209314': 5861, '7553841581': 5862}
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:29 - 🔍 Тип accepted_by_staff_id: <class 'int'>
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:49 - 🔄 Обновление сообщения для staff_id: 5170209314->5170209314, message_id: 5861
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:50 - 🔍 Сравнение: 5170209314 == 5170209314 -> True
2025-10-12 21:34:43 - src.handlers.admin.callback - INFO - callback.py:54 - 🎯 Это принявший официант, добавляем кнопку завершения
2025-10-12 21:34:44 - src.handlers.admin.callback - INFO - callback.py:67 - ✅ Добавлена кнопку завершения для принявшего официанта
2025-10-12 21:34:44 - src.handlers.admin.callback - INFO - callback.py:49 - 🔄 Обновление сообщения для staff_id: 7553841581->7553841581, message_id: 5862
2025-10-12 21:34:44 - src.handlers.admin.callback - INFO - callback.py:50 - 🔍 Сравнение: 7553841581 == 5170209314 -> False
2025-10-12 21:34:44 - src.handlers.admin.callback - INFO - callback.py:70 - 📝 Это другой официант, убираем кнопки
2025-10-12 21:34:44 - src.handlers.admin.callback - INFO - callback.py:84 - ✅ Успешно обновлено 2 сообщений из 2
2025-10-12 21:34:44 - src.handlers.admin.callback - INFO - callback.py:161 - ✅ Уведомления отправлены для вызова #1
2025-10-12 21:34:44 - src.handlers.admin.callback - INFO - callback.py:166 - 🎯 Вызов стола #6 принят персоналом ГАРУН
2025-10-12 21:34:46 - src.handlers.admin.callback - INFO - callback.py:226 - 🔄 Завершение вызова #1 персоналом 5170209314
2025-10-12 21:34:46 - src.database.db_manager - INFO - db_manager.py:455 - 📥 Получен вызов #1: статус=accepted, message_ids={"5170209314": 5861, "7553841581": 5862}
2025-10-12 21:34:47 - src.handlers.admin.callback - INFO - callback.py:250 - ✅ Вызов #1 завершен
2025-10-12 21:34:50 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 21:34:50 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 21:35:15 - src.handlers.user.reservation - INFO - reservation.py:457 - 🔄 Starting ATOMIC reservation process for user 5170209314
2025-10-12 21:35:15 - src.database.reservation_manager - INFO - reservation_manager.py:194 - ✅ Reservation #1 created atomically
2025-10-12 21:35:15 - src.handlers.user.reservation - INFO - reservation.py:470 - ✅ Reservation #1 created successfully for user 5170209314
2025-10-12 21:35:16 - src.handlers.user.reservation - INFO - reservation.py:118 - ✅ Sent reservation notification to admin 5170209314 with correct timezone
2025-10-12 21:35:21 - src.handlers.admin.reservation_management - INFO - reservation_management.py:68 - 🔄 Admin confirming reservation #1
2025-10-12 21:35:21 - src.handlers.user.reservation - INFO - reservation.py:169 - ✅ Sent status notification to user 5170209314 with correct timezone
2025-10-12 21:35:22 - src.handlers.admin.reservation_management - INFO - reservation_management.py:98 - ✅ Reservation #1 confirmed by admin
2025-10-12 21:35:46 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=5170209314, has_referrer=None
2025-10-12 21:35:46 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=700.0, delivery=200, discount=0, total_after_discount=900.0
2025-10-12 21:37:32 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 21:37:33 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 21:37:36 - src.handlers.user.referral - INFO - referral.py:175 - 👥 Referral program shown to user 5170209314
2025-10-12 21:37:40 - src.handlers.user.bonus - INFO - bonus.py:89 - 💳 Loyalty card shown to user 5170209314
2025-10-12 21:37:44 - src.handlers.user.directions - INFO - directions.py:73 - 🗺️ Detailed directions requested by user 5170209314
2025-10-12 21:38:16 - src.handlers.admin.broadcast - INFO - broadcast.py:263 - ✅ Image file validated: AgACAgIAAxkBAAIXJGjr54l7k_P93jqaihAjJEWmO1fMAAJh9zEbuxJYS2EliYzmf7A8AQADAgADeQADNgQ, size: 237870
2025-10-12 21:38:43 - src.handlers.admin.broadcast - INFO - broadcast.py:387 - 📤 Starting broadcast: type=image, segment=male, users=2, has_image=True
2025-10-12 21:38:43 - src.handlers.admin.broadcast - INFO - broadcast.py:487 - ✅ Broadcast #1 completed: 2 sent, 0 failed
2025-10-12 21:38:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 21:39:09 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 21:39:09 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 21:40:22 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 21:40:22 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 21:40:31 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 21:40:31 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 21:41:38 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 21:41:38 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 21:43:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 21:48:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 21:53:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 21:58:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:03:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:08:47 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:13:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:18:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:23:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:28:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:33:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:38:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:42:25 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 22:42:25 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 22:43:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:48:48 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:53:49 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:58:49 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 22:59:55 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 22:59:55 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 22:59:55 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-12 22:59:55 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-12 22:59:55 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-12 22:59:55 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-12 23:00:00 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-12 23:00:00 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-12 23:00:00 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-12 23:00:01 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-12 23:00:01 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-12 23:00:01 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-12 23:00:01 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-12 23:00:01 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-12 23:00:01 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-12 23:00:01 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-12 23:00:01 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-12 23:00:01 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-12 23:00:01 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-12 23:00:01 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-12 23:00:01 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-12 23:00:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:00:06 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 23:00:06 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-12 23:00:30 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-12 23:00:30 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-12 23:05:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:09:27 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: Максим (id: 720776914, username: @funeralarchangel)
2025-10-12 23:09:27 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 720776914
2025-10-12 23:10:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:10:03 - src.handlers.user.bonus - INFO - bonus.py:89 - 💳 Loyalty card shown to user 720776914
2025-10-12 23:10:27 - src.handlers.user.message - INFO - message.py:190 - 👤 Food menu button from user: Максим (id: 720776914, username: @funeralarchangel)
2025-10-12 23:10:27 - src.handlers.user.message - INFO - message.py:207 - 👤 Food menu shown to user 720776914
2025-10-12 23:10:31 - src.handlers.user.message - INFO - message.py:254 - 👤 Main_menu->Menu->Hot dishes from user: Максим (id: 720776914, username: @funeralarchangel)
2025-10-12 23:10:32 - src.handlers.user.message - INFO - message.py:276 - 👤 Main_menu->Menu->Hot dishes shown to user 720776914
2025-10-12 23:11:03 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Максим (id: 720776914, rights: USER)
2025-10-12 23:11:03 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 720776914
2025-10-12 23:11:05 - src.handlers.user.message - INFO - message.py:409 - 👨‍💼 Staff call initiated by user 720776914
2025-10-12 23:11:09 - src.handlers.user.message - INFO - message.py:454 - 👨‍💼 Staff call created for user 720776914 at table 5
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:225 - 📨 Отправка уведомлений персоналу о вызове #2
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:226 - 👥 ID персонала для уведомления: [5170209314, 7553841581]
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:231 - 📤 Отправка сообщения персоналу 5170209314
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:239 - ✅ Сообщение отправлено персоналу 5170209314, message_id: 6015
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:231 - 📤 Отправка сообщения персоналу 7553841581
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:239 - ✅ Сообщение отправлено персоналу 7553841581, message_id: 6016
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:243 - 💾 Сохранение message_ids в БД: {5170209314: 6015, 7553841581: 6016}
2025-10-12 23:11:13 - src.database.db_manager - INFO - db_manager.py:478 - ✅ Message IDs обновлены для вызова #2: {5170209314: 6015, 7553841581: 6016}
2025-10-12 23:11:13 - src.handlers.user.callback - INFO - callback.py:249 - ✅ Message_ids сохранены в БД для вызова #2
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:99 - 🔄 Начало принятия вызова #2 персоналом ГАРУН (ID: 5170209314)
2025-10-12 23:11:15 - src.database.db_manager - INFO - db_manager.py:455 - 📥 Получен вызов #2: статус=pending, message_ids={"5170209314": 6015, "7553841581": 6016}
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:108 - 📊 Статус вызова #2: pending
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:122 - ✅ Вызов #2 принят в БД
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:133 - 📨 Получены message_ids для вызова #2: {'5170209314': 6015, '7553841581': 6016}
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:134 - 🔍 Типы ключей: [<class 'str'>, <class 'str'>]
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:208 - 👤 Получена информация о клиенте: Максим (@funeralarchangel) 👨🎓
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:149 - 🔔 Начинаем уведомление персонала о принятии вызова #2
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:27 - 🔔 Уведомление о принятии вызова #2. Принял: ГАРУН (ID: 5170209314)
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:28 - 📋 Message IDs для обновления: {'5170209314': 6015, '7553841581': 6016}
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:29 - 🔍 Тип accepted_by_staff_id: <class 'int'>
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:49 - 🔄 Обновление сообщения для staff_id: 5170209314->5170209314, message_id: 6015
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:50 - 🔍 Сравнение: 5170209314 == 5170209314 -> True
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:54 - 🎯 Это принявший официант, добавляем кнопку завершения
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:67 - ✅ Добавлена кнопку завершения для принявшего официанта
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:49 - 🔄 Обновление сообщения для staff_id: 7553841581->7553841581, message_id: 6016
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:50 - 🔍 Сравнение: 7553841581 == 5170209314 -> False
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:70 - 📝 Это другой официант, убираем кнопки
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:84 - ✅ Успешно обновлено 2 сообщений из 2
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:161 - ✅ Уведомления отправлены для вызова #2
2025-10-12 23:11:15 - src.handlers.admin.callback - INFO - callback.py:166 - 🎯 Вызов стола #5 принят персоналом ГАРУН
2025-10-12 23:11:45 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ClientOSError: [WinError 1236] Подключение к сети было разорвано локальной системой
2025-10-12 23:11:45 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 23:12:07 - src.handlers.admin.callback - INFO - callback.py:226 - 🔄 Завершение вызова #2 персоналом 5170209314
2025-10-12 23:12:07 - src.database.db_manager - INFO - db_manager.py:455 - 📥 Получен вызов #2: статус=accepted, message_ids={"5170209314": 6015, "7553841581": 6016}
2025-10-12 23:12:07 - src.handlers.admin.callback - INFO - callback.py:250 - ✅ Вызов #2 завершен
2025-10-12 23:12:16 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=720776914, has_referrer=None
2025-10-12 23:12:16 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=660.0, delivery=200, discount=0, total_after_discount=860.0
2025-10-12 23:13:12 - src.handlers.user.delivery - INFO - delivery.py:1336 - ✅ Delivery order notification sent to admin 5170209314
2025-10-12 23:13:12 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: Максим (id: 720776914, rights: USER)
2025-10-12 23:13:12 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 720776914
2025-10-12 23:13:44 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 23:13:45 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 23:15:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:16:27 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 23:16:27 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 23:16:52 - src.handlers.admin.broadcast - INFO - broadcast.py:263 - ✅ Image file validated: AgACAgIAAxkBAAIXpWjr_qUHT6K6hIXD8FJT89x5J73VAAKE9jEbuxJgS1vNZhS6NiRFAQADAgADeQADNgQ, size: 237870
2025-10-12 23:17:49 - src.handlers.admin.broadcast - INFO - broadcast.py:387 - 📤 Starting broadcast: type=image, segment=all, users=3, has_image=True
2025-10-12 23:17:50 - src.handlers.admin.broadcast - INFO - broadcast.py:487 - ✅ Broadcast #2 completed: 3 sent, 0 failed
2025-10-12 23:19:06 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-12 23:19:06 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-12 23:20:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:25:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:30:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:30:14 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramServerError: Telegram server says - Bad Gateway
2025-10-12 23:30:14 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-12 23:35:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:40:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:45:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:50:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-12 23:55:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:00:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:05:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:10:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:13:25 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-13 00:13:26 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-13 00:15:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:20:02 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:25:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:30:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:35:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:40:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:45:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:50:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 00:55:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 01:00:03 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 01:03:19 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-13 01:03:19 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-13 01:03:19 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-13 01:03:19 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-13 01:03:19 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-13 01:03:19 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-13 10:37:00 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-13 10:37:00 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-13 10:37:00 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-13 10:37:01 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-13 10:37:01 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-13 10:37:01 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-13 10:37:01 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-13 10:37:01 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-13 10:37:01 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-13 10:37:01 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-13 10:37:01 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-13 10:37:01 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-13 10:37:01 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-13 10:37:01 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-13 10:37:01 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-13 10:37:01 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 10:37:01 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-13 10:37:02 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-13 10:37:37 - src.handlers.user.reservation - INFO - reservation.py:606 - 🔄 User 5170209314 cancelling reservation #1
2025-10-13 10:37:37 - src.handlers.user.reservation - INFO - reservation.py:717 - ✅ Notified admin 5170209314 about cancellation #1
2025-10-13 10:37:37 - src.handlers.user.reservation - INFO - reservation.py:664 - ✅ Reservation #1 cancelled by user 5170209314
2025-10-13 10:38:43 - src.handlers.user.message - INFO - message.py:190 - 👤 Food menu button from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-13 10:38:43 - src.handlers.user.message - INFO - message.py:207 - 👤 Food menu shown to user 5170209314
2025-10-13 10:38:49 - src.handlers.user.message - INFO - message.py:288 - 👤 Main_menu->Menu->Hot drinks from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-13 10:38:49 - src.handlers.user.message - INFO - message.py:310 - 👤 Main_menu->Menu->Hot drinks shown to user 5170209314
2025-10-13 10:39:03 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-13 10:39:03 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-13 10:39:07 - src.handlers.user.directions - INFO - directions.py:73 - 🗺️ Detailed directions requested by user 5170209314
2025-10-13 10:39:14 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-13 10:39:14 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-13 10:39:14 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-13 10:39:14 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-13 10:39:14 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-13 10:39:14 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
2025-10-13 10:45:38 - root - INFO - logger.py:130 - 🚀 Система логирования инициализирована (уровень: INFO, формат: colored)
2025-10-13 10:45:38 - __main__ - INFO - main.py:94 - 🚀 Starting Restaurant Bot...
2025-10-13 10:45:38 - __main__ - INFO - main.py:40 - 🗄️ Initializing database connection...
2025-10-13 10:45:38 - src.database.db_manager - INFO - db_manager.py:50 - ✅ Database connection pool created successfully
2025-10-13 10:45:38 - __main__ - INFO - main.py:49 - ✅ Database connected successfully
2025-10-13 10:45:38 - __main__ - INFO - main.py:84 - ✅ Added default admin: 5170209314
2025-10-13 10:45:38 - __main__ - INFO - main.py:88 - ✅ Added default staff: 5170209314
2025-10-13 10:45:38 - __main__ - INFO - main.py:88 - ✅ Added default staff: 7553841581
2025-10-13 10:45:38 - __main__ - INFO - main.py:106 - 🤖 Initializing bot with token: 7385257320......
2025-10-13 10:45:38 - __main__ - INFO - main.py:133 - 🔔 Reminder system started
2025-10-13 10:45:38 - __main__ - INFO - main.py:137 - 🧹 Rate limiting cleanup task started
2025-10-13 10:45:38 - __main__ - INFO - main.py:141 - 🧹 FSM cleanup service started
2025-10-13 10:45:38 - __main__ - INFO - main.py:144 - 📋 Registered 1 routers
2025-10-13 10:45:38 - __main__ - INFO - main.py:146 - ✅ Bot initialized successfully
2025-10-13 10:45:38 - __main__ - INFO - main.py:147 - 📡 Starting polling...
2025-10-13 10:45:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 10:45:59 - src.handlers.user.referral - INFO - referral.py:175 - 👥 Referral program shown to user 5170209314
2025-10-13 10:50:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 10:55:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:00:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:04:12 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-13 11:04:12 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-13 11:04:23 - src.handlers.user.message - INFO - message.py:190 - 👤 Food menu button from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-13 11:04:23 - src.handlers.user.message - INFO - message.py:207 - 👤 Food menu shown to user 5170209314
2025-10-13 11:04:57 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-13 11:04:57 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-13 11:05:02 - src.handlers.user.message - INFO - message.py:409 - 👨‍💼 Staff call initiated by user 5170209314
2025-10-13 11:05:35 - src.handlers.user.message - INFO - message.py:454 - 👨‍💼 Staff call created for user 5170209314 at table 5
2025-10-13 11:05:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:225 - 📨 Отправка уведомлений персоналу о вызове #3
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:226 - 👥 ID персонала для уведомления: [5170209314, 7553841581]
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:231 - 📤 Отправка сообщения персоналу 5170209314
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:239 - ✅ Сообщение отправлено персоналу 5170209314, message_id: 6107
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:231 - 📤 Отправка сообщения персоналу 7553841581
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:239 - ✅ Сообщение отправлено персоналу 7553841581, message_id: 6108
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:243 - 💾 Сохранение message_ids в БД: {5170209314: 6107, 7553841581: 6108}
2025-10-13 11:05:39 - src.database.db_manager - INFO - db_manager.py:478 - ✅ Message IDs обновлены для вызова #3: {5170209314: 6107, 7553841581: 6108}
2025-10-13 11:05:39 - src.handlers.user.callback - INFO - callback.py:249 - ✅ Message_ids сохранены в БД для вызова #3
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:99 - 🔄 Начало принятия вызова #3 персоналом ГАРУН (ID: 5170209314)
2025-10-13 11:06:01 - src.database.db_manager - INFO - db_manager.py:455 - 📥 Получен вызов #3: статус=pending, message_ids={"5170209314": 6107, "7553841581": 6108}
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:108 - 📊 Статус вызова #3: pending
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:122 - ✅ Вызов #3 принят в БД
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:133 - 📨 Получены message_ids для вызова #3: {'5170209314': 6107, '7553841581': 6108}
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:134 - 🔍 Типы ключей: [<class 'str'>, <class 'str'>]
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:208 - 👤 Получена информация о клиенте: ГАРУН (@garunsuleymanov) 👨🎓
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:149 - 🔔 Начинаем уведомление персонала о принятии вызова #3
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:27 - 🔔 Уведомление о принятии вызова #3. Принял: ГАРУН (ID: 5170209314)
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:28 - 📋 Message IDs для обновления: {'5170209314': 6107, '7553841581': 6108}
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:29 - 🔍 Тип accepted_by_staff_id: <class 'int'>
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:49 - 🔄 Обновление сообщения для staff_id: 5170209314->5170209314, message_id: 6107
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:50 - 🔍 Сравнение: 5170209314 == 5170209314 -> True
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:54 - 🎯 Это принявший официант, добавляем кнопку завершения
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:67 - ✅ Добавлена кнопку завершения для принявшего официанта
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:49 - 🔄 Обновление сообщения для staff_id: 7553841581->7553841581, message_id: 6108
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:50 - 🔍 Сравнение: 7553841581 == 5170209314 -> False
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:70 - 📝 Это другой официант, убираем кнопки
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:84 - ✅ Успешно обновлено 2 сообщений из 2
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:161 - ✅ Уведомления отправлены для вызова #3
2025-10-13 11:06:01 - src.handlers.admin.callback - INFO - callback.py:166 - 🎯 Вызов стола #5 принят персоналом ГАРУН
2025-10-13 11:06:18 - src.handlers.admin.callback - INFO - callback.py:226 - 🔄 Завершение вызова #3 персоналом 5170209314
2025-10-13 11:06:18 - src.database.db_manager - INFO - db_manager.py:455 - 📥 Получен вызов #3: статус=accepted, message_ids={"5170209314": 6107, "7553841581": 6108}
2025-10-13 11:06:18 - src.handlers.admin.callback - INFO - callback.py:250 - ✅ Вызов #3 завершен
2025-10-13 11:09:28 - src.handlers.user.reservation - INFO - reservation.py:457 - 🔄 Starting ATOMIC reservation process for user 5170209314
2025-10-13 11:09:28 - src.database.reservation_manager - INFO - reservation_manager.py:194 - ✅ Reservation #2 created atomically
2025-10-13 11:09:28 - src.handlers.user.reservation - INFO - reservation.py:470 - ✅ Reservation #2 created successfully for user 5170209314
2025-10-13 11:09:28 - src.handlers.user.reservation - INFO - reservation.py:118 - ✅ Sent reservation notification to admin 5170209314 with correct timezone
2025-10-13 11:10:04 - src.handlers.admin.reservation_management - INFO - reservation_management.py:68 - 🔄 Admin confirming reservation #2
2025-10-13 11:10:05 - src.handlers.user.reservation - INFO - reservation.py:169 - ✅ Sent status notification to user 5170209314 with correct timezone
2025-10-13 11:10:05 - src.handlers.admin.reservation_management - INFO - reservation_management.py:98 - ✅ Reservation #2 confirmed by admin
2025-10-13 11:10:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:14:14 - src.handlers.user.delivery - INFO - delivery.py:230 - 🔍 Start checkout: user_id=5170209314, has_referrer=None
2025-10-13 11:14:14 - src.handlers.user.delivery - INFO - delivery.py:256 - 🔢 Checkout totals: subtotal=1450.0, delivery=200, discount=0, total_after_discount=1650.0
2025-10-13 11:15:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:18:40 - src.handlers.user.message - INFO - message.py:143 - 👤 Open main menu for user: ГАРУН (id: 5170209314, rights: ['ADMIN', 'STAFF'])
2025-10-13 11:18:40 - src.handlers.user.message - INFO - message.py:160 - 👤 Main menu shown to user 5170209314
2025-10-13 11:20:38 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:25:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:30:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:35:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:36:53 - src.handlers.user.message - INFO - message.py:22 - 👤 /start command from user: ГАРУН (id: 5170209314, username: @garunsuleymanov)
2025-10-13 11:36:54 - src.handlers.user.message - INFO - message.py:91 - 👤 /start command text shown to user 5170209314
2025-10-13 11:40:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:45:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:50:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 11:55:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:00:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:05:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:10:39 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:15:40 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:20:40 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:25:40 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:30:40 - src.database.db_manager - INFO - db_manager.py:326 - ✅ Updated expired reservations: UPDATE 0
2025-10-13 12:32:34 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-13 12:32:34 - aiogram.dispatcher - WARNING - dispatcher.py:221 - Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)
2025-10-13 12:32:34 - __main__ - INFO - main.py:159 - 🛑 Bot stopped
2025-10-13 12:32:34 - src.database.db_manager - INFO - db_manager.py:59 - ✅ Database connection pool closed
2025-10-13 12:32:34 - __main__ - INFO - main.py:63 - ✅ Database connection closed
2025-10-13 12:32:35 - __main__ - INFO - main.py:168 - 👋 Bot interrupted by user
{"timestamp": "2025-10-13 12:34:31", "level": "ERROR", "logger": "aiogram.dispatcher", "file": "dispatcher.py", "line": 219, "function": "_listen_updates", "message": "Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected"}
{"timestamp": "2025-10-13 12:34:31", "level": "WARNING", "logger": "aiogram.dispatcher", "file": "dispatcher.py", "line": 221, "function": "_listen_updates", "message": "Sleep for 1.000000 seconds and try again... (tryings = 0, bot id = 7385257320)"}


=== logs/errors.log ===
2025-10-12 14:50:42 - src.handlers.admin.delivery_dashboard - ERROR - delivery_dashboard.py:290 - ❌ Error refreshing dashboard: Telegram server says - Bad Request: there is no text in the message to edit
2025-10-12 14:54:01 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 14:54:09 - src.handlers.admin.delivery_dashboard - ERROR - delivery_dashboard.py:290 - ❌ Error refreshing dashboard: Telegram server says - Bad Request: there is no text in the message to edit
2025-10-12 15:33:19 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 15:34:54 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 15:41:07 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 15:59:08 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:01:36 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:06:22 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ClientOSError: [WinError 1236] Подключение к сети было разорвано локальной системой
2025-10-12 16:07:49 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:14:28 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:20:09 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 16:28:28 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ClientOSError: [WinError 1236] Подключение к сети было разорвано локальной системой
2025-10-12 16:28:34 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 22:42:25 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 22:59:55 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-12 23:11:45 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ClientOSError: [WinError 1236] Подключение к сети было разорвано локальной системой
2025-10-12 23:30:14 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramServerError: Telegram server says - Bad Gateway
2025-10-13 01:03:19 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-13 10:39:14 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
2025-10-13 12:32:34 - aiogram.dispatcher - ERROR - dispatcher.py:219 - Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected
{"timestamp": "2025-10-13 12:34:31", "level": "ERROR", "logger": "aiogram.dispatcher", "file": "dispatcher.py", "line": 219, "function": "_listen_updates", "message": "Failed to fetch updates - TelegramNetworkError: HTTP Client says - ServerDisconnectedError: Server disconnected"}


=== src/database/db_manager.py ===
import asyncpg
from typing import Optional, List, Dict, Any
from datetime import datetime, date, time
import json
import logging
from asyncio import sleep

from src.database.reservation_manager import ReservationManager

logger = logging.getLogger(__name__)

class DatabaseError(Exception):
    """Кастомное исключение для ошибок базы данных"""
    pass

class DatabaseManager:
    def __init__(self):
        self.pool = None
        self.logger = logging.getLogger(__name__)
        self.max_retries = 3
        self.retry_delay = 1
        self.reservation_manager = None

    async def execute_with_retry(self, operation, *args, **kwargs):
        """
        Выполняет операцию с повторными попытками при ошибках соединения
        """
        for attempt in range(self.max_retries):
            try:
                return await operation(*args, **kwargs)
            except (asyncpg.exceptions.ConnectionDoesNotExistError,
                   asyncpg.exceptions.TooManyConnectionsError,
                   asyncpg.exceptions.ConnectionFailureError) as e:
                if attempt == self.max_retries - 1:
                    self.logger.error(f"Database connection failed after {self.max_retries} attempts: {e}")
                    raise DatabaseError(f"Database connection failed: {e}") from e
                
                self.logger.warning(f"Database connection attempt {attempt + 1} failed, retrying...")
                await sleep(self.retry_delay * (2 ** attempt))  # Exponential backoff
            except Exception as e:
                self.logger.error(f"Database operation failed: {e}")
                raise DatabaseError(f"Database operation failed: {e}") from e

    async def init_pool(self, dsn: str):
        """Инициализация пула соединений и менеджера бронирований"""
        try:
            self.pool = await asyncpg.create_pool(dsn)
            self.reservation_manager = ReservationManager(self)
            await self.execute_with_retry(self._health_check_impl)
            self.logger.info("✅ Database connection pool created successfully")
        except Exception as e:
            self.logger.error(f"❌ Failed to create database connection pool: {e}")
            raise DatabaseError(f"Failed to initialize database: {e}") from e
        
    async def close_pool(self):
        """Закрытие пула соединений"""
        if self.pool:
            await self.pool.close()
            self.logger.info("✅ Database connection pool closed")

    async def _health_check_impl(self) -> bool:
        """Реализация проверки здоровья БД"""
        async with self.pool.acquire() as conn:
            result = await conn.fetchval("SELECT 1")
            return result == 1

    async def health_check(self) -> bool:
        """Проверка соединения с базой данных с повторными попытками"""
        try:
            return await self.execute_with_retry(self._health_check_impl)
        except Exception as e:
            self.logger.error(f"❌ Database health check failed: {e}")
            return False

    # ==================== USERS ====================
    async def ensure_user_exists(self, user_id: int, username: str = None, full_name: str = None) -> bool:
        """Гарантирует, что пользователь существует в базе"""
        async def _ensure_user_exists():
            async with self.pool.acquire() as conn:
                user_exists = await conn.fetchval(
                    "SELECT 1 FROM users WHERE user_id = $1", 
                    user_id
                )
                
                if not user_exists:
                    # Создаем базовую запись пользователя
                    username = username or "unknown"
                    full_name = full_name or f"User_{user_id}"
                    
                    await conn.execute('''
                        INSERT INTO users (user_id, username, full_name, language_code)
                        VALUES ($1, $2, $3, 'ru')
                        ON CONFLICT (user_id) DO NOTHING
                    ''', user_id, username, full_name)
                    logger.info(f"✅ Auto-created user record for {user_id}")
                
                return True
        
        try:
            return await self.execute_with_retry(_ensure_user_exists)
        except Exception as e:
            logger.error(f"❌ Failed to ensure user exists {user_id}: {e}")
            return False



    async def add_user(self, user_id: int, username: str, full_name: str, 
                      language_code: str = 'ru') -> bool:
        """Добавление нового пользователя с обработкой ошибок"""
        async def _add_user():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    INSERT INTO users (user_id, username, full_name, language_code)
                    VALUES ($1, $2, $3, $4)
                    ON CONFLICT (user_id) DO UPDATE SET
                    username = EXCLUDED.username,
                    full_name = EXCLUDED.full_name,
                    updated_at = CURRENT_TIMESTAMP
                ''', user_id, username, full_name, language_code)
                return True
        
        try:
            return await self.execute_with_retry(_add_user)
        except Exception as e:
            logger.error(f"❌ Failed to add user {user_id}: {e}")
            return False

    async def update_user_profile(self, user_id: int, sex: str, major: str) -> bool:
        """Обновление профиля пользователя (пол и профессия)"""
        async def _update_user_profile():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE users 
                    SET sex = $1, major = $2, updated_at = CURRENT_TIMESTAMP
                    WHERE user_id = $3
                ''', sex, major, user_id)
                return True
        try:
            return await self.execute_with_retry(_update_user_profile)
        except Exception as e:
            logger.error(f"❌ Failed to update user profile {user_id}: {e}")
            return False

    async def get_user(self, user_id: int) -> Optional[Dict]:
        """Получение пользователя по ID"""
        async def _get_user():
            async with self.pool.acquire() as conn:
                row = await conn.fetchrow('''
                    SELECT * FROM users WHERE user_id = $1
                ''', user_id)
                return dict(row) if row else None
        try:    
            return await self.execute_with_retry(_get_user)
        except Exception as e:
            logger.error(f"❌ Failed to get user {user_id}: {e}")
            return None

    async def get_users_by_segment(self, segment_key: str) -> List[Dict]:
        """Получение пользователей по сегменту"""
        async def _get_users_by_segment():
            async with self.pool.acquire() as conn:
                base_query = "SELECT user_id FROM users WHERE is_blocked = FALSE"
                
                if segment_key == "male":
                    query = f"{base_query} AND sex = 'male'"
                elif segment_key == "female":
                    query = f"{base_query} AND sex = 'female'"
                elif segment_key == "students":
                    query = f"{base_query} AND major = 'student'"
                elif segment_key == "entrepreneurs":
                    query = f"{base_query} AND major = 'entrepreneur'"
                elif segment_key == "employees":
                    query = f"{base_query} AND major = 'hire'"
                elif segment_key == "freelancers":
                    query = f"{base_query} AND major = 'frilans'"
                else:
                    query = base_query  # all users
                
                rows = await conn.fetch(query)
                return [dict(row) for row in rows]
        
        try:
            return await self.execute_with_retry(_get_users_by_segment)
        except Exception as e:
            logger.error(f"❌ Failed to get users by segment {segment_key}: {e}")
            return []

    # ==================== RESERVATIONS ====================
    async def check_table_availability(self, reservation_date: str, reservation_time: str, guests_count: int) -> dict:
        """Проверка доступности столов через ReservationManager"""
        if not self.reservation_manager:
            return {"available": False, "reason": "service_unavailable"}
        
        return await self.reservation_manager.check_table_availability(
            reservation_date, reservation_time, guests_count
        )

    async def create_reservation(self, user_id: int, reservation_date: str, reservation_time: str,
                               guests_count: int, customer_name: str, customer_phone: str) -> int:
        """Создание брони через атомарный метод"""
        if not self.reservation_manager:
            raise DatabaseError("Reservation manager not initialized")
        
        return await self.reservation_manager.create_reservation_atomic(
            user_id, reservation_date, reservation_time, guests_count, customer_name, customer_phone
        )

    async def get_reservations_by_status(self, status: str):
        """Получение актуальных броней по статусу (исключая прошедшие)"""
        async def _get_reservations_by_status():
            query = """
                SELECT * FROM reservations 
                WHERE status = $1 
                AND (reservation_date > CURRENT_DATE 
                    OR (reservation_date = CURRENT_DATE AND reservation_time::time >= CURRENT_TIME))
                ORDER BY created_at DESC
                LIMIT 10
            """
            return await self.pool.fetch(query, status)
        
        try:
            return await self.execute_with_retry(_get_reservations_by_status)
        except Exception as e:
            self.logger.error(f"❌ Failed to get reservations by status: {e}")
            return None


    async def get_today_reservations(self):
        async def _get_today_reservations():
            """Получение актуальных броней на сегодня"""
            query = """
                SELECT * FROM reservations 
                WHERE reservation_date = CURRENT_DATE 
                AND status IN ('pending', 'confirmed')
                AND reservation_time::time >= CURRENT_TIME
                ORDER BY reservation_time
            """
            return await self.pool.fetch(query)
        try:
            return await self.execute_with_retry(_get_today_reservations)
        except Exception as e:
            self.logger.error(f"❌ Failed to get today reservations: {e}")
            return None
            
            

    async def update_reservation_status(self, reservation_id: int, status: str) -> bool:
        """Обновление статуса брони"""
        query = """
            UPDATE reservations 
            SET status = $1, updated_at = CURRENT_TIMESTAMP
            WHERE id = $2
        """
        
        try:
            await self.pool.execute(query, status, reservation_id)
            return True
        except Exception as e:
            self.logger.error(f"❌ Failed to update reservation status: {e}")
            return False

    async def get_reservation_by_id(self, reservation_id: int):
        """Получение брони по ID"""
        async def _get_reservation_by_id():
            query = "SELECT * FROM reservations WHERE id = $1"
            return await self.pool.fetchrow(query, reservation_id)
        try:
            return await self.execute_with_retry(_get_reservation_by_id)
        except Exception as e:
            self.logger.error(f"❌ Failed to get_reservation_by_id: {e}")
            return None


    async def get_user_reservations(self, user_id: int):
        """Получение броней пользователя"""
        async def _get_user_reservations():
            query = """
                SELECT * FROM reservations 
                WHERE user_id = $1 
                ORDER BY created_at DESC
                LIMIT 10
            """
            return await self.pool.fetch(query, user_id)
        try:
            return await self.execute_with_retry(_get_user_reservations)
        except Exception as e:
            self.logger.error(f"❌ Failed to get_user_reservations: {e}")
            return None

    async def get_reservations_for_date(self, date_str: str) -> List[Dict]:
        """Получение бронирований на указанную дату с полной информацией"""
        try:
            # Преобразуем дату из формата "день.месяц.год" в объект date
            day, month, year = map(int, date_str.split('.'))
            date_obj = date(year, month, day)
            
            query = """
                SELECT 
                    r.*,
                    u.full_name as user_full_name,
                    u.username as user_username
                FROM reservations r
                LEFT JOIN users u ON r.user_id = u.user_id
                WHERE r.reservation_date = $1
                ORDER BY r.reservation_time, r.created_at
            """
            
            rows = await self.pool.fetch(query, date_obj)
            return rows
            
        except Exception as e:
            self.logger.error(f"❌ Error getting reservations for date {date_str}: {e}")
            return []
        
    async def update_expired_reservations(self):
        """Автоматическое обновление статусов прошедших броней"""
        async def _update_expired_reservation():
            query = """
                UPDATE reservations 
                SET status = 'completed'
                WHERE status IN ('pending', 'confirmed')
                AND (reservation_date < CURRENT_DATE 
                    OR (reservation_date = CURRENT_DATE AND reservation_time::time < CURRENT_TIME))
            """
            result = await self.pool.execute(query)
            self.logger.info(f"✅ Updated expired reservations: {result}")
            return True
        try:
            return await self.execute_with_retry(_update_expired_reservation)
        except Exception as e:
            self.logger.error(f"❌ Failed to update expired reservations: {e}")
            return False
        
    async def archive_old_reservations(self, days_old: int = 30):
        """Архивация старых броней (перемещение в отдельную таблицу или удаление)"""
        async def _archive_old_reservations():
            query = """
                DELETE FROM reservations 
                WHERE reservation_date < CURRENT_DATE - ($1 * INTERVAL '1 day')
                AND status IN ('completed', 'cancelled')
            """
            result = await self.pool.execute(query, days_old)
            self.logger.info(f"✅ Archived reservations older than {days_old} days: {result}")
            return True
        try:
            return await self.execute_with_retry(_archive_old_reservations)
        except Exception as e:
            self.logger.error(f"❌ Failed to archive old reservations: {e}")
            return False

    # ==================== STAFF CALLS ====================
    async def add_staff_call(self, user_id: int, table_number: int, notes: str = None) -> Optional[int]:
        """Добавление вызова персонала"""
        async def _add_staff_call():
            async with self.pool.acquire() as conn:
                call_id = await conn.fetchval('''
                    INSERT INTO staff_calls (user_id, table_number, notes)
                    VALUES ($1, $2, $3)
                    RETURNING id
                ''', user_id, table_number, notes)
                return call_id
        try:
            return await self.execute_with_retry(_add_staff_call)
        except Exception as e:
            logger.error(f"❌ Failed to add staff call for user {user_id}: {e}")
            return None

    async def accept_staff_call(self, call_id: int, staff_id: int, staff_name: str) -> bool:
        """Принять вызов официантом - ТОЛЬКО принятие"""
        async def _accept_staff_call():
            async with self.pool.acquire() as conn:
                result = await conn.execute('''
                    UPDATE staff_calls 
                    SET 
                        status = 'accepted',
                        accepted_at = CURRENT_TIMESTAMP,
                        accepted_by_name = $1,
                        accepted_by = $2  -- 👈 Сохраняем ID официанта
                    WHERE id = $3 AND status = 'pending'
                ''', staff_name, staff_id, call_id)
                
                return "UPDATE 1" in result
        try:
            return await self.execute_with_retry(_accept_staff_call)
        except Exception as e:
            logger.error(f"❌ Failed to accept staff call {call_id}: {e}")
            return False

    async def complete_staff_call(self, call_id: int) -> bool:
        """Завершение вызова персонала"""
        async def _complete_staff_call():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE staff_calls 
                    SET status = 'completed', completed_at = CURRENT_TIMESTAMP
                    WHERE id = $1 AND status IN ('pending', 'accepted')
                ''', call_id)
                return True
        try:
            return await self.execute_with_retry(_complete_staff_call)
        except Exception as e:
            logger.error(f"❌ Failed to complete staff call {call_id}: {e}")
            return False

    async def cancel_staff_call(self, call_id: int) -> bool:
        """Отмена вызова персонала"""
        async def _cancel_staff_call():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE staff_calls 
                    SET status = 'cancelled', cancelled_at = CURRENT_TIMESTAMP
                    WHERE id = $1 AND status IN ('pending', 'accepted')
                ''', call_id)
                return True
        try:
            return await self.execute_with_retry(_cancel_staff_call)
        except Exception as e:
            logger.error(f"❌ Failed to cancel staff call {call_id}: {e}")
            return False

    async def get_active_staff_calls(self) -> List[Dict]:
        """Получение активных вызовов персонала"""
        async def _get_active_staff_calls():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT sc.*, u.full_name, u.username
                    FROM staff_calls sc
                    JOIN users u ON sc.user_id = u.user_id
                    WHERE sc.status IN ('pending', 'accepted')
                    ORDER BY sc.created_at ASC
                ''')
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_active_staff_calls)
        except Exception as e:
            logger.error(f"❌ Failed to get active staff calls: {e}")
            return []
        
    async def get_staff_call(self, call_id: int) -> Optional[Dict]:
        """Получить информацию о вызове"""
        async def _get_staff_call():
            async with self.pool.acquire() as conn:
                row = await conn.fetchrow('''
                    SELECT 
                        sc.*,
                        u.full_name as user_name,
                        u.username as user_username
                    FROM staff_calls sc
                    LEFT JOIN users u ON sc.user_id = u.user_id
                    WHERE sc.id = $1
                ''', call_id)
                
                if row:
                    result = dict(row)
                    logger.info(f"📥 Получен вызов #{call_id}: статус={result.get('status')}, message_ids={result.get('message_ids')}")
                    return result
                else:
                    logger.warning(f"⚠️ Вызов #{call_id} не найден в БД")
                    return None
        try:
            return await self.execute_with_retry(_get_staff_call)
        except Exception as e:
            logger.error(f"❌ Ошибка получения вызова {call_id}: {e}")
            return None

    async def update_call_message_ids(self, call_id: int, message_ids: Dict[int, int]) -> bool:
        """Сохранить ID сообщений для каждого официанта"""
        async def _update_call_message_ids():
            async with self.pool.acquire() as conn:
                result = await conn.execute('''
                    UPDATE staff_calls 
                    SET message_ids = $1
                    WHERE id = $2
                ''', json.dumps(message_ids), call_id)
                
                success = "UPDATE 1" in result
                if success:
                    logger.info(f"✅ Message IDs обновлены для вызова #{call_id}: {message_ids}")
                else:
                    logger.warning(f"⚠️ Не удалось обновить message IDs для вызова #{call_id}. Результат: {result}")
                
                return success
        try:    
            return await self.execute_with_retry(_update_call_message_ids)
        except Exception as e:
            logger.error(f"❌ Ошибка обновления message IDs для вызова {call_id}: {e}")
            return False

    # ==================== USER ACTIONS ====================
    async def add_user_action(self, user_id: int, action_type: str, action_data: Dict = None) -> bool:
        """Безопасное добавление действия пользователя (с проверкой существования пользователя)"""
        async def _add_user_action():
            async with self.pool.acquire() as conn:
                # Сначала проверяем существование пользователя
                user_exists = await conn.fetchval(
                    "SELECT 1 FROM users WHERE user_id = $1", 
                    user_id
                )
                
                if not user_exists:
                    logger.warning(f"⚠️ User {user_id} not found, skipping action logging")
                    return False
                
                # Если пользователь существует, добавляем действие
                await conn.execute('''
                    INSERT INTO user_actions (user_id, action_type, action_data)
                    VALUES ($1, $2, $3)
                ''', user_id, action_type, json.dumps(action_data) if action_data else None)
                return True
        
        try:
            return await self.execute_with_retry(_add_user_action)
        except Exception as e:
            logger.error(f"❌ Failed to add user action for {user_id}: {e}")
            return False

    # ==================== MENU VIEWS ====================
    async def add_menu_view(self, user_id: int, category: str) -> bool:
        """Добавление/обновление просмотра категории меню"""
        async def _add_menu_view():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    INSERT INTO menu_views (user_id, category)
                    VALUES ($1, $2)
                    ON CONFLICT (user_id, category) DO UPDATE SET
                    view_count = menu_views.view_count + 1,
                    last_viewed_at = CURRENT_TIMESTAMP
                ''', user_id, category)
                return True
        try:
            return await self.execute_with_retry(_add_menu_view)
        except Exception as e:
            logger.error(f"❌ Failed to add menu view for user {user_id}: {e}")
            return False
        
    
    # ==================== DELIVERY METHODS ====================

    async def get_delivery_categories(self) -> List[Dict]:
        """Получение уникальных категорий доставки"""
        try:
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT DISTINCT category 
                    FROM delivery_menu 
                    WHERE is_available = TRUE
                    ORDER BY category
                ''')
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"❌ Failed to get delivery categories: {e}")
            return []

    async def get_delivery_menu(self, category: str = None) -> List[Dict]:
        """Получение меню доставки"""
        try:
            async with self.pool.acquire() as conn:
                if category:
                    rows = await conn.fetch('''
                        SELECT * FROM delivery_menu 
                        WHERE category = $1 AND is_available = TRUE
                        ORDER BY name
                    ''', category)
                else:
                    rows = await conn.fetch('''
                        SELECT * FROM delivery_menu 
                        WHERE is_available = TRUE
                        ORDER BY category, name
                    ''')
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"❌ Failed to get delivery menu: {e}")
            return []

    async def create_delivery_order(self, user_id: int, order_data: Dict, 
                              discount_amount: float = 0, bonus_used: float = 0, 
                              final_amount: float = None) -> Optional[int]:
        """Создание заказа доставки с учетом скидок и бонусов"""
        try:
            if final_amount is None:
                final_amount = order_data['total'] - discount_amount - bonus_used
            
            async with self.pool.acquire() as conn:
                order_id = await conn.fetchval('''
                    INSERT INTO delivery_orders 
                    (user_id, order_data, customer_name, customer_phone, 
                    delivery_address, total_amount, discount_amount, bonus_used, final_amount, delivery_time)
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                    RETURNING id
                ''', 
                user_id, 
                json.dumps(order_data), 
                order_data['customer_name'],
                order_data['customer_phone'],
                order_data['delivery_address'],
                order_data['total'],  # Исходная сумма
                discount_amount,      # Сумма скидки
                bonus_used,           # Использованные бонусы
                final_amount,         # Итоговая сумма
                order_data.get('delivery_time', 'Как можно скорее'))
                return order_id
        except Exception as e:
            logger.error(f"❌ Failed to create delivery order: {e}")
            return None

    async def get_delivery_orders_by_status(self, status: str) -> List[Dict]:
        """Получение заказов по статусу"""
        try:
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT delivery_orders.*, u.full_name as user_name
                    FROM delivery_orders
                    LEFT JOIN users u ON delivery_orders.user_id = u.user_id
                    WHERE delivery_orders.status = $1
                    ORDER BY delivery_orders.created_at DESC
                ''', status)
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"❌ Failed to get delivery orders: {e}")
            return []

    async def update_delivery_order_status(self, order_id: int, status: str) -> bool:
        """Обновление статуса заказа доставки"""
        try:
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE delivery_orders 
                    SET status = $1, updated_at = CURRENT_TIMESTAMP
                    WHERE id = $2
                ''', status, order_id)
                return True
        except Exception as e:
            logger.error(f"❌ Failed to update delivery order status: {e}")
            return False
        

    async def get_all_delivery_orders(self) -> List[Dict]:
        """Получение всех заказов доставки"""
        try:
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM delivery_orders 
                    ORDER BY created_at DESC
                ''')
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"❌ Failed to get all delivery orders: {e}")
            return []
        
    async def get_delivery_orders_today(self) -> List[Dict]:
        """Получение заказов за сегодня"""
        try:
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM delivery_orders 
                    WHERE DATE(created_at) = CURRENT_DATE
                    ORDER BY created_at DESC
                ''')
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"❌ Failed to get today's delivery orders: {e}")
            return []

    async def get_delivery_order_by_id(self, order_id: int) -> Optional[Dict]:
        """Получение заказа по ID"""
        try:
            async with self.pool.acquire() as conn:
                row = await conn.fetchrow('''
                    SELECT * FROM delivery_orders WHERE id = $1
                ''', order_id)
                return dict(row) if row else None
        except Exception as e:
            logger.error(f"❌ Failed to get delivery order {order_id}: {e}")
            return None
        

    async def get_delivery_orders_by_user(self, user_id: int) -> List[Dict]:
        """Получение всех заказов пользователя"""
        try:
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM delivery_orders 
                    WHERE user_id = $1
                    ORDER BY created_at DESC
                ''', user_id)
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"❌ Failed to get user delivery orders: {e}")
            return []
        

    # ==================== BROADCASTS ====================
    async def create_broadcast(self, title: str, message_text: str, target_sex: str = 'all', 
                         target_major: str = 'all', message_type: str = 'text', 
                         image_file_id: str = None) -> Optional[int]:
        """Создание рассылки с поддержкой разных типов контента"""
        async def _create_broadcast():
            async with self.pool.acquire() as conn:
                broadcast_id = await conn.fetchval('''
                    INSERT INTO broadcasts 
                    (title, message_text, target_sex, target_major, message_type, image_file_id, total_count)
                    VALUES ($1, $2, $3, $4, $5, $6, (
                        SELECT COUNT(*) FROM users 
                        WHERE is_blocked = FALSE
                    ))
                    RETURNING id
                ''', title, message_text, target_sex, target_major, message_type, image_file_id)
                return broadcast_id
        
        try:
            return await self.execute_with_retry(_create_broadcast)
        except Exception as e:
            logger.error(f"❌ Failed to create broadcast: {e}")
            return None

    async def update_broadcast_stats(self, broadcast_id: int, sent_count: int) -> bool:
        """Обновление статистики рассылки"""
        async def _update_broadcast_stats():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE broadcasts 
                    SET sent_count = $1, 
                        status = CASE WHEN sent_count >= total_count THEN 'completed' ELSE 'sending' END,
                        sent_at = CASE WHEN sent_count >= total_count THEN CURRENT_TIMESTAMP ELSE sent_at END
                    WHERE id = $2
                ''', sent_count, broadcast_id)
                return True
        
        try:
            return await self.execute_with_retry(_update_broadcast_stats)
        except Exception as e:
            logger.error(f"❌ Failed to update broadcast stats {broadcast_id}: {e}")
            return False

    # ==================== ANALYTICS METHODS ====================
    async def get_general_stats(self) -> Dict[str, Any]:
        """📊 Общая статистика"""
        async def _get_general_stats():
            async with self.pool.acquire() as conn:
                stats = await conn.fetchrow('''
                    SELECT 
                        (SELECT COUNT(*) FROM users) as total_users,
                        (SELECT COUNT(*) FROM users WHERE created_at::date = CURRENT_DATE) as new_users_today,
                        (SELECT COUNT(*) FROM users WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as new_users_week,
                        (SELECT COUNT(DISTINCT user_id) FROM user_actions 
                         WHERE created_at >= CURRENT_DATE - INTERVAL '30 days') as active_users,
                        (SELECT COUNT(*) FROM reservations) as total_reservations,
                        (SELECT COUNT(*) FROM staff_calls) as total_staff_calls,
                        (SELECT COUNT(*) FROM reservations WHERE created_at::date = CURRENT_DATE) as reservations_today
                ''')
                return dict(stats) if stats else {}
        try:
            return await self.execute_with_retry(_get_general_stats)
        except Exception as e:
            logger.error(f"❌ Failed to get general stats: {e}")
            return {}

    async def get_user_demographics(self) -> List[Dict]:
        """👥 Демографика пользователей"""
        async def _get_user_demographics():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT 
                        sex,
                        major,
                        COUNT(*) as count,
                        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users), 2) as percentage
                    FROM users 
                    WHERE sex IS NOT NULL AND major IS NOT NULL
                    GROUP BY sex, major
                    ORDER BY count DESC
                ''')
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_user_demographics)
        except Exception as e:
            logger.error(f"❌ Failed to get user demographics: {e}")
            return []

    async def get_user_growth(self, days: int = 30) -> List[Dict]:
        """📈 Рост пользователей"""
        async def _get_user_growth():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT 
                        DATE(created_at) as date,
                        COUNT(*) as new_users,
                        SUM(COUNT(*)) OVER (ORDER BY DATE(created_at)) as total_users
                    FROM users 
                    WHERE created_at >= CURRENT_DATE - $1 * INTERVAL '1 day'
                    GROUP BY DATE(created_at)
                    ORDER BY date
                ''', days)
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_user_growth)
        except Exception as e:
            logger.error(f"❌ Failed to get user growth: {e}")
            return []

    async def get_daily_activity(self, days: int = 7) -> List[Dict]:
        """📈 Активность по дням"""
        async def _get_daily_activity():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT 
                        DATE(created_at) as date,
                        COUNT(*) as actions_count,
                        COUNT(DISTINCT user_id) as unique_users,
                        action_type
                    FROM user_actions 
                    WHERE created_at >= CURRENT_DATE - $1 * INTERVAL '1 day'
                    GROUP BY DATE(created_at), action_type
                    ORDER BY date DESC, actions_count DESC
                ''', days)
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_daily_activity)
        except Exception as e:
            logger.error(f"❌ Failed to get daily activity: {e}")
            return []

    async def get_target_segments(self) -> Dict[str, Any]:
        """🎯 Целевые сегменты"""
        async def _get_target_segments():
            async with self.pool.acquire() as conn:
                segments = await conn.fetchrow('''
                    SELECT 
                        (SELECT COUNT(*) FROM users WHERE sex = 'male') as male_count,
                        (SELECT COUNT(*) FROM users WHERE sex = 'female') as female_count,
                        (SELECT COUNT(*) FROM users WHERE major = 'student') as students_count,
                        (SELECT COUNT(*) FROM users WHERE major = 'entrepreneur') as entrepreneurs_count,
                        (SELECT COUNT(*) FROM users WHERE major = 'frilans') as freelancers_count,
                        (SELECT COUNT(*) FROM users WHERE major = 'hire') as employees_count,
                        (SELECT COUNT(*) FROM users WHERE sex = 'male' AND major = 'entrepreneur') as male_entrepreneurs,
                        (SELECT COUNT(*) FROM users WHERE sex = 'female' AND major = 'student') as female_students,
                        (SELECT COUNT(*) FROM users WHERE sex = 'male' AND major = 'frilans') as male_freelancers
                ''')
                return dict(segments) if segments else {}
        try:
            return await self.execute_with_retry(_get_target_segments)
        except Exception as e:
            logger.error(f"❌ Failed to get target segments: {e}")
            return {}

    async def get_reservation_stats(self) -> Dict[str, Any]:
        """📋 Статистика бронирований"""
        async def _get_reservation_stats():
            async with self.pool.acquire() as conn:
                stats = await conn.fetchrow('''
                    SELECT 
                        COUNT(*) as total_reservations,
                        COALESCE(AVG(guests_count), 0) as avg_guests,
                        COALESCE(MAX(guests_count), 0) as max_guests,
                        COUNT(*) FILTER (WHERE status = 'confirmed') as confirmed,
                        COUNT(*) FILTER (WHERE status = 'pending') as pending,
                        COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled,
                        COUNT(*) FILTER (WHERE status = 'completed') as completed,
                        COUNT(*) FILTER (WHERE reservation_date = CURRENT_DATE) as today_reservations,
                        MODE() WITHIN GROUP (ORDER BY EXTRACT(DOW FROM reservation_date)) as most_popular_day
                    FROM reservations
                ''')
                return dict(stats) if stats else {}
        try:
            return await self.execute_with_retry(_get_reservation_stats)
        except Exception as e:
            logger.error(f"❌ Failed to get reservation stats: {e}")
            return {}

    async def get_reservation_trends(self, days: int = 30) -> List[Dict]:
        """📈 Тренды бронирований"""
        async def _get_reservation_trends():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT 
                        reservation_date as date,
                        COUNT(*) as reservations_count,
                        AVG(guests_count) as avg_guests,
                        SUM(guests_count) as total_guests
                    FROM reservations 
                    WHERE reservation_date >= CURRENT_DATE - $1 * INTERVAL '1 day'
                    GROUP BY reservation_date
                    ORDER BY date DESC
                ''', days)
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_reservation_trends)
        except Exception as e:
            logger.error(f"❌ Failed to get reservation trends: {e}")
            return []

    async def get_staff_calls_stats(self) -> Dict[str, Any]:
        """👨‍💼 Статистика вызовов персонала"""
        async def _get_staff_calls_stats():
            async with self.pool.acquire() as conn:
                stats = await conn.fetchrow('''
                    SELECT 
                        COUNT(*) as total_calls,
                        COUNT(*) FILTER (WHERE status = 'pending') as pending_calls,
                        COUNT(*) FILTER (WHERE status = 'accepted') as accepted_calls,
                        COUNT(*) FILTER (WHERE status = 'completed') as completed_calls,
                        COUNT(*) FILTER (WHERE status = 'cancelled') as cancelled_calls,
                        COALESCE(AVG(EXTRACT(EPOCH FROM (completed_at - created_at))/60) FILTER 
                            (WHERE completed_at IS NOT NULL), 0) as avg_completion_time_min,
                        MODE() WITHIN GROUP (ORDER BY table_number) as most_active_table,
                        COUNT(*) FILTER (WHERE created_at::date = CURRENT_DATE) as today_calls
                    FROM staff_calls
                ''')
                return dict(stats) if stats else {}
        try:
            return await self.execute_with_retry(_get_staff_calls_stats)    
        except Exception as e:
            logger.error(f"❌ Failed to get staff calls stats: {e}")
            return {}

    async def get_popular_menu_categories(self) -> List[Dict]:
        """📊 Популярные категории меню"""
        try:
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT 
                        category,
                        SUM(view_count) as total_views,
                        COUNT(DISTINCT user_id) as unique_viewers,
                        MAX(last_viewed_at) as last_viewed
                    FROM menu_views 
                    GROUP BY category
                    ORDER BY total_views DESC
                    LIMIT 10
                ''')
                return [dict(row) for row in rows]
        except Exception as e:
            logger.error(f"❌ Failed to get popular menu categories: {e}")
            return []
        

        # ==================== REFERRAL METHODS ====================

    async def generate_referral_code(self, user_id: int) -> str:
        """Генерация уникального реферального кода"""
        async def _generate_referral_code():
            async with self.pool.acquire() as conn:
                # Пытаемся использовать username + user_id для создания кода
                user = await self.get_user(user_id)
                base_code = ""
                if user and user.get('username'):
                    base_code = user['username'].upper()[:8]
                else:
                    base_code = "REF"
                
                # Добавляем последние 4 цифры user_id
                code_suffix = str(user_id)[-4:]
                referral_code = f"{base_code}{code_suffix}"
                
                # Проверяем уникальность и при необходимости модифицируем
                counter = 0
                original_code = referral_code
                
                while counter < 10:  # Максимум 10 попыток
                    existing = await conn.fetchval(
                        "SELECT user_id FROM users WHERE referral_code = $1", 
                        referral_code
                    )
                    if not existing:
                        break
                    # Если код уже существует, добавляем случайный символ
                    import random
                    import string
                    referral_code = original_code + random.choice(string.ascii_uppercase)
                    counter += 1
                else:
                    # Если все попытки исчерпаны, используем user_id
                    referral_code = f"REF{user_id}"
                
                # Сохраняем код в БД
                await conn.execute(
                    "UPDATE users SET referral_code = $1 WHERE user_id = $2",
                    referral_code, user_id
                )
                
                return referral_code
        
        try:
            return await self.execute_with_retry(_generate_referral_code)
        except Exception as e:
            logger.error(f"❌ Failed to generate referral code for user {user_id}: {e}")
            return f"REF{user_id}"

    async def get_referral_code(self, user_id: int) -> str:
        """Получение реферального кода пользователя (генерирует если нет)"""
        async def _get_referral_code():
            async with self.pool.acquire() as conn:
                # Проверяем есть ли уже код
                existing_code = await conn.fetchval(
                    "SELECT referral_code FROM users WHERE user_id = $1",
                    user_id
                )
                
                if existing_code:
                    return existing_code
                else:
                    # Генерируем новый код
                    return await self.generate_referral_code(user_id)
        
        try:
            return await self.execute_with_retry(_get_referral_code)
        except Exception as e:
            logger.error(f"❌ Failed to get referral code for user {user_id}: {e}")
            return f"REF{user_id}"

    async def get_user_by_referral_code(self, referral_code: str) -> Optional[Dict]:
        """Получение пользователя по реферальному коду"""
        async def _get_user_by_referral_code():
            async with self.pool.acquire() as conn:
                row = await conn.fetchrow(
                    "SELECT * FROM users WHERE referral_code = $1",
                    referral_code.upper()
                )
                return dict(row) if row else None
        
        try:
            return await self.execute_with_retry(_get_user_by_referral_code)
        except Exception as e:
            logger.error(f"❌ Failed to get user by referral code {referral_code}: {e}")
            return None

    async def set_user_referrer(self, user_id: int, referrer_id: int) -> bool:
        """Установка реферера для пользователя с АТОМАРНОЙ проверкой"""
        async def _set_user_referrer():
            async with self.pool.acquire() as conn:
                # АТОМАРНАЯ проверка и установка в одной транзакции
                current_referrer = await conn.fetchval(
                    "SELECT referrer_id FROM users WHERE user_id = $1",
                    user_id
                )
                
                if current_referrer:
                    logger.warning(f"⚠️ User {user_id} already has referrer {current_referrer}")
                    return False
                
                # Устанавливаем реферера
                await conn.execute(
                    "UPDATE users SET referrer_id = $1 WHERE user_id = $2",
                    referrer_id, user_id
                )
                
                # Увеличиваем счетчик рефералов у реферера
                await conn.execute(
                    "UPDATE users SET referral_count = referral_count + 1 WHERE user_id = $1",
                    referrer_id
                )
                
                logger.info(f"✅ Set referrer {referrer_id} for user {user_id}")
                return True
        
        try:
            return await self.execute_with_retry(_set_user_referrer)
        except Exception as e:
            logger.error(f"❌ Failed to set referrer for user {user_id}: {e}")
            return False

    async def add_referral_bonus(self, referrer_id: int, referred_id: int, bonus_amount: float) -> bool:
        """Добавление реферального бонуса"""
        async def _add_referral_bonus():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    INSERT INTO referral_bonuses (referrer_id, referred_id, bonus_amount, status)
                    VALUES ($1, $2, $3, 'pending')
                ''', referrer_id, referred_id, bonus_amount)
                return True
        
        try:
            return await self.execute_with_retry(_add_referral_bonus)
        except Exception as e:
            logger.error(f"❌ Failed to add referral bonus: {e}")
            return False

    async def complete_referral_bonus(self, referred_id: int, order_id: int) -> bool:
        """Завершение реферального бонуса после успешного заказа - ИСПРАВЛЕННАЯ ВЕРСИЯ"""
        async def _complete_referral_bonus():
            async with self.pool.acquire() as conn:
                # АТОМАРНО находим и обновляем бонус в одной транзакции
                bonus = await conn.fetchrow('''
                    UPDATE referral_bonuses 
                    SET status = 'completed', 
                        completed_at = CURRENT_TIMESTAMP, 
                        order_id = $1
                    WHERE referred_id = $2 
                        AND status = 'pending'
                    RETURNING id, referrer_id, bonus_amount
                ''', order_id, referred_id)
                
                if not bonus:
                    logger.warning(f"⚠️ No pending referral bonus found for referred_id {referred_id}")
                    return False
                
                # Проверяем, не начислялся ли уже бонус за этот заказ
                existing_bonus = await conn.fetchval(
                    "SELECT 1 FROM bonus_transactions WHERE order_id = $1 AND type = 'referral'",
                    order_id
                )
                
                if existing_bonus:
                    logger.warning(f"⚠️ Referral bonus already awarded for order {order_id}")
                    return False
                
                # Начисляем бонус рефереру на баланс
                bonus_amount = bonus['bonus_amount']
                await conn.execute('''
                    UPDATE users 
                    SET total_referral_bonus = total_referral_bonus + $1,
                        bonus_balance = bonus_balance + $1
                    WHERE user_id = $2
                ''', bonus_amount, bonus['referrer_id'])
                
                # Добавляем запись в бонусные транзакции
                await conn.execute('''
                    INSERT INTO bonus_transactions 
                    (user_id, order_id, amount, type, description)
                    VALUES ($1, $2, $3, 'referral', $4)
                ''', bonus['referrer_id'], order_id, bonus_amount, 
                    f'Реферальный бонус за пользователя {referred_id}')
                
                logger.info(f"✅ Completed referral bonus: referrer {bonus['referrer_id']}, amount: {bonus_amount}, order: {order_id}")
                return True
        
        try:
            return await self.execute_with_retry(_complete_referral_bonus)
        except Exception as e:
            logger.error(f"❌ Failed to complete referral bonus: {e}")
            return False

    async def get_referral_stats(self, user_id: int) -> Dict[str, Any]:
        """Получение статистики по реферальной программе"""
        async def _get_referral_stats():
            async with self.pool.acquire() as conn:
                stats = await conn.fetchrow('''
                    SELECT 
                        referral_count as total_referrals,
                        total_referral_bonus,
                        (SELECT COUNT(*) FROM referral_bonuses 
                        WHERE referrer_id = $1 AND status = 'completed') as completed_referrals,
                        (SELECT COUNT(*) FROM referral_bonuses 
                        WHERE referrer_id = $1 AND status = 'pending') as pending_referrals
                    FROM users 
                    WHERE user_id = $1
                ''', user_id)
                
                return dict(stats) if stats else {
                    'total_referrals': 0,
                    'total_referral_bonus': 0,
                    'completed_referrals': 0,
                    'pending_referrals': 0
                }
        
        try:
            return await self.execute_with_retry(_get_referral_stats)
        except Exception as e:
            logger.error(f"❌ Failed to get referral stats for user {user_id}: {e}")
            return {
                'total_referrals': 0,
                'total_referral_bonus': 0,
                'completed_referrals': 0,
                'pending_referrals': 0
            }
        

    async def get_loyalty_card_info(self, user_id: int) -> Dict:
        """Получение информации для карты лояльности"""
        try:
            async with self.pool.acquire() as conn:
                # Получаем баланс пользователя
                balance = await conn.fetchval(
                    "SELECT bonus_balance FROM users WHERE user_id = $1",
                    user_id
                ) or 0.0
                
                # Получаем статистику по транзакциям
                stats_row = await conn.fetchrow('''
                    SELECT 
                        COALESCE(SUM(CASE WHEN amount > 0 THEN amount ELSE 0 END), 0) as earned,
                        COALESCE(SUM(CASE WHEN amount < 0 THEN ABS(amount) ELSE 0 END), 0) as spent,
                        COUNT(DISTINCT order_id) as total_orders
                    FROM bonus_transactions 
                    WHERE user_id = $1
                ''', user_id)
                
                # Получаем последние транзакции
                transactions = await conn.fetch('''
                    SELECT amount, description, created_at, type
                    FROM bonus_transactions 
                    WHERE user_id = $1
                    ORDER BY created_at DESC
                    LIMIT 5
                ''', user_id)
                
                return {
                    'balance': float(balance),
                    'stats': {
                        'earned': float(stats_row['earned']) if stats_row else 0.0,
                        'spent': float(stats_row['spent']) if stats_row else 0.0,
                        'total_orders': stats_row['total_orders'] if stats_row else 0
                    },
                    'transactions': [dict(transaction) for transaction in transactions]
                }
                
        except Exception as e:
            self.logger.error(f"❌ Error getting loyalty card info: {e}")
            return {
                'balance': 0.0,
                'stats': {'earned': 0.0, 'spent': 0.0, 'total_orders': 0},
                'transactions': []
            }


    # ==================== BONUS BALANCE METHODS ====================

    async def get_user_bonus_balance(self, user_id: int) -> float:
        """Получение бонусного баланса пользователя"""
        async def _get_user_bonus_balance():
            async with self.pool.acquire() as conn:
                balance = await conn.fetchval(
                    "SELECT bonus_balance FROM users WHERE user_id = $1",
                    user_id
                )
                return float(balance) if balance else 0.0
        
        try:
            return await self.execute_with_retry(_get_user_bonus_balance)
        except Exception as e:
            logger.error(f"❌ Failed to get bonus balance for user {user_id}: {e}")
            return 0.0

    async def update_user_bonus_balance(self, user_id: int, amount: float) -> bool:
        """Обновление бонусного баланса пользователя"""
        async def _update_user_bonus_balance():
            async with self.pool.acquire() as conn:
                await conn.execute(
                    "UPDATE users SET bonus_balance = bonus_balance + $1 WHERE user_id = $2",
                    amount, user_id
                )
                return True
        
        try:
            return await self.execute_with_retry(_update_user_bonus_balance)
        except Exception as e:
            logger.error(f"❌ Failed to update bonus balance for user {user_id}: {e}")
            return False

    async def get_user_referral_discount_eligible(self, user_id: int) -> bool:
        """Проверка, имеет ли пользователь право на скидку по реферальной программе"""
        async def _get_user_referral_discount_eligible():
            async with self.pool.acquire() as conn:
                # Проверяем, есть ли у пользователя реферер И это его первый заказ
                user = await self.get_user(user_id)
                if not user or not user.get('referrer_id'):
                    return False
                
                # Проверяем, есть ли уже завершенные заказы у пользователя
                orders_count = await conn.fetchval(
                    "SELECT COUNT(*) FROM delivery_orders WHERE user_id = $1 AND status = 'delivered'",
                    user_id
                )
                
                return orders_count == 0  # Скидка только на первый заказ
        
        try:
            return await self.execute_with_retry(_get_user_referral_discount_eligible)
        except Exception as e:
            logger.error(f"❌ Failed to check referral discount eligibility for user {user_id}: {e}")
            return False
        

    # ==================== BONUS SYSTEM METHODS ====================
    
    async def add_bonus_transaction(self, user_id: int, amount: float, transaction_type: str, 
                                description: str = None, order_id: int = None) -> bool:
        """Добавление бонусной транзакции"""
        async def _add_bonus_transaction():
            async with self.pool.acquire() as conn:
                # Добавляем транзакцию
                await conn.execute('''
                    INSERT INTO bonus_transactions (user_id, order_id, amount, type, description)
                    VALUES ($1, $2, $3, $4, $5)
                ''', user_id, order_id, amount, transaction_type, description)
                
                # Обновляем баланс пользователя
                await conn.execute('''
                    UPDATE users 
                    SET bonus_balance = bonus_balance + $1
                    WHERE user_id = $2
                ''', amount, user_id)
                return True
        
        try:
            return await self.execute_with_retry(_add_bonus_transaction)
        except Exception as e:
            logger.error(f"❌ Failed to add bonus transaction: {e}")
            return False

    async def get_bonus_transactions(self, user_id: int, limit: int = 10) -> List[Dict]:
        """Получение истории бонусных транзакций"""
        async def _get_bonus_transactions():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM bonus_transactions 
                    WHERE user_id = $1 
                    ORDER BY created_at DESC 
                    LIMIT $2
                ''', user_id, limit)
                return [dict(row) for row in rows]
        
        try:
            return await self.execute_with_retry(_get_bonus_transactions)
        except Exception as e:
            logger.error(f"❌ Failed to get bonus transactions: {e}")
            return []

    async def calculate_order_cashback(self, order_amount: float) -> float:
        """Расчет кешбэка для заказа (5%)"""
        return round(order_amount * 0.05, 2)

    async def get_max_bonus_usage(self, order_amount: float) -> float:
        """Максимальное количество бонусов для списания (50% от заказа)"""
        return round(order_amount * 0.5, 2)
    


    async def get_blocked_users(self) -> List[Dict]:
        """Получение списка заблокированных пользователей"""
        async def _get_blocked_users():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT user_id, username, full_name, created_at 
                    FROM users 
                    WHERE is_blocked = TRUE
                    ORDER BY created_at DESC
                ''')
                return [dict(row) for row in rows]
        
        try:
            return await self.execute_with_retry(_get_blocked_users)
        except Exception as e:
            logger.error(f"❌ Failed to get blocked users: {e}")
            return []

    async def block_user(self, user_id: int) -> bool:
        """Блокировка пользователя"""
        async def _block_user():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE users 
                    SET is_blocked = TRUE 
                    WHERE user_id = $1
                ''', user_id)
                return True
        
        try:
            return await self.execute_with_retry(_block_user)
        except Exception as e:
            logger.error(f"❌ Failed to block user {user_id}: {e}")
            return False

    async def unblock_user(self, user_id: int) -> bool:
        """Разблокировка пользователя"""
        async def _unblock_user():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE users 
                    SET is_blocked = FALSE 
                    WHERE user_id = $1
                ''', user_id)
                return True
        
        try:
            return await self.execute_with_retry(_unblock_user)
        except Exception as e:
            logger.error(f"❌ Failed to unblock user {user_id}: {e}")
            return False




    # ==================== ADMIN/STAFF MANAGEMENT ====================

    async def is_admin(self, user_id: int) -> bool:
        """Проверка, является ли пользователь администратором"""
        async def _is_admin():
            async with self.pool.acquire() as conn:
                exists = await conn.fetchval(
                    "SELECT 1 FROM admin_users WHERE user_id = $1",
                    user_id
                )
                return exists is not None
        try:
            return await self.execute_with_retry(_is_admin)
        except Exception as e:
            logger.error(f"❌ Error checking admin status: {e}")
            return False

    async def is_staff(self, user_id: int) -> bool:
        """Проверка, является ли пользователь персоналом"""
        async def _is_staff():
            async with self.pool.acquire() as conn:
                # Персонал = админы + официанты
                exists = await conn.fetchval('''
                    SELECT 1 FROM (
                        SELECT user_id FROM admin_users 
                        UNION 
                        SELECT user_id FROM staff_users
                    ) AS staff WHERE user_id = $1
                ''', user_id)
                return exists is not None
        try:
            return await self.execute_with_retry(_is_staff)
        except Exception as e:
            logger.error(f"❌ Error checking staff status: {e}")
            return False

    async def add_admin(self, user_id: int, username: str, full_name: str) -> bool:
        """Добавление администратора"""
        async def _add_admin():
            async with self.pool.acquire() as conn:
                # Сначала убедимся, что пользователь существует в users
                await self.ensure_user_exists(user_id, username, full_name)
                
                await conn.execute('''
                    INSERT INTO admin_users (user_id, username, full_name)
                    VALUES ($1, $2, $3)
                    ON CONFLICT (user_id) DO UPDATE SET
                    username = EXCLUDED.username,
                    full_name = EXCLUDED.full_name
                ''', user_id, username, full_name)
                return True
        try:
            return await self.execute_with_retry(_add_admin)
        except Exception as e:
            logger.error(f"❌ Error adding admin: {e}")
            return False

    async def remove_admin(self, user_id: int) -> bool:
        """Удаление администратора"""
        async def _remove_admin():
            async with self.pool.acquire() as conn:
                await conn.execute(
                    "DELETE FROM admin_users WHERE user_id = $1",
                    user_id
                )
                return True
        try:
            return await self.execute_with_retry(_remove_admin)
        except Exception as e:
            logger.error(f"❌ Error removing admin: {e}")
            return False

    async def get_admins(self) -> List[Dict]:
        """Получение списка администраторов"""
        async def _get_admins():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM admin_users ORDER BY created_at
                ''')
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_admins)
        except Exception as e:
            logger.error(f"❌ Error getting admins: {e}")
            return []

    async def add_staff(self, user_id: int, username: str, full_name: str) -> bool:
        """Добавление официанта"""
        async def _add_staff():
            async with self.pool.acquire() as conn:
                # Сначала убедимся, что пользователь существует в users
                await self.ensure_user_exists(user_id, username, full_name)
                
                await conn.execute('''
                    INSERT INTO staff_users (user_id, username, full_name)
                    VALUES ($1, $2, $3)
                    ON CONFLICT (user_id) DO UPDATE SET
                    username = EXCLUDED.username,
                    full_name = EXCLUDED.full_name
                ''', user_id, username, full_name)
                return True
        try:
            return await self.execute_with_retry(_add_staff)
        except Exception as e:
            logger.error(f"❌ Error adding staff: {e}")
            return False

    async def remove_staff(self, user_id: int) -> bool:
        """Удаление официанта"""
        async def _remove_staff():
            async with self.pool.acquire() as conn:
                await conn.execute(
                    "DELETE FROM staff_users WHERE user_id = $1",
                    user_id
                )
                return True
        try:
            return await self.execute_with_retry(_remove_staff)
        except Exception as e:
            logger.error(f"❌ Error removing staff: {e}")
            return False

    async def get_staff(self) -> List[Dict]:
        """Получение списка официантов"""
        async def _get_staff():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM staff_users ORDER BY created_at
                ''')
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_staff)
        except Exception as e:
            logger.error(f"❌ Error getting staff: {e}")
            return []

    async def add_dish_to_menu(self, category: str, name: str, description: str, price: float, image_url: str = None) -> bool:
        """Добавление блюда в меню"""
        async def _add_dish_to_menu():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    INSERT INTO delivery_menu (category, name, description, price, image_url)
                    VALUES ($1, $2, $3, $4, $5)
                ''', category, name, description, price, image_url)
                return True
        try:
            return await self.execute_with_retry(_add_dish_to_menu)
        except Exception as e:
            logger.error(f"❌ Error adding dish to menu: {e}")
            return False

    async def remove_dish_from_menu(self, dish_id: int) -> bool:
        """Удаление блюда из меню"""
        async def _remove_dish_from_menu():
            async with self.pool.acquire() as conn:
                await conn.execute(
                    "DELETE FROM delivery_menu WHERE id = $1",
                    dish_id
                )
                return True
        try:
            return await self.execute_with_retry(_remove_dish_from_menu)
        except Exception as e:
            logger.error(f"❌ Error removing dish from menu: {e}")
            return False

    async def get_blocked_users(self) -> List[Dict]:
        """Получение списка заблокированных пользователей"""
        async def _get_blocked_users():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT user_id, username, full_name, created_at 
                    FROM users 
                    WHERE is_blocked = TRUE
                    ORDER BY created_at DESC
                ''')
                return [dict(row) for row in rows]
        try:
            return await self.execute_with_retry(_get_blocked_users)
        except Exception as e:
            logger.error(f"❌ Error getting blocked users: {e}")
            return []
        


    # ==================== PAYMENT METHODS ====================

    async def update_order_payment_method(self, order_id: int, payment_method: str) -> bool:
        """Обновление способа оплаты для заказа"""
        async def _update_order_payment_method():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    UPDATE delivery_orders 
                    SET payment_method = $1 
                    WHERE id = $2
                ''', payment_method, order_id)
                return True
        
        try:
            return await self.execute_with_retry(_update_order_payment_method)
        except Exception as e:
            logger.error(f"❌ Failed to update payment method: {e}")
            return False

    async def confirm_payment(self, order_id: int, confirmed_by: int = None) -> bool:
        async def _fn():
            async with self.pool.acquire() as conn:
                row = await conn.fetchrow("""
                    UPDATE delivery_orders
                    SET payment_status = 'confirmed',
                        status = 'preparing',
                        payment_confirmed_by = $2,
                        payment_confirmed_at = NOW(),
                        updated_at = NOW()
                    WHERE id = $1 AND (payment_status IS DISTINCT FROM 'confirmed')
                    RETURNING id
                """, order_id, confirmed_by)
                return bool(row)
        return await self.execute_with_retry(_fn)

    async def get_orders_with_pending_payment(self) -> List[Dict]:
        """Получение заказов, ожидающих подтверждения оплаты"""
        async def _get_orders_with_pending_payment():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM delivery_orders 
                    WHERE payment_status = 'pending'
                    AND status NOT IN ('cancelled', 'delivered')
                    ORDER BY created_at DESC
                ''')
                return [dict(row) for row in rows]
        
        try:
            return await self.execute_with_retry(_get_orders_with_pending_payment)
        except Exception as e:
            logger.error(f"❌ Failed to get pending payment orders: {e}")
            return []
        
    async def save_payment_receipt(self, order_id: int, user_id: int, file_id: str, note: str = None) -> bool:
        """Сохранить информацию о присланном платёжном документе/скрине"""
        async def _save_receipt():
            async with self.pool.acquire() as conn:
                await conn.execute('''
                    INSERT INTO payment_receipts (order_id, user_id, file_id, note)
                    VALUES ($1, $2, $3, $4)
                ''', order_id, user_id, file_id, note)
                return True

        try:
            return await self.execute_with_retry(_save_receipt)
        except Exception as e:
            logger.error(f"❌ Failed to save payment receipt for order {order_id}: {e}")
            return False

    async def reject_payment(self, order_id: int, rejected_by: int = None) -> bool:
        async def _fn():
            async with self.pool.acquire() as conn:
                row = await conn.fetchrow("""
                    UPDATE delivery_orders
                    SET payment_status = 'rejected',
                        payment_rejected_by = $2,
                        payment_rejected_at = NOW(),
                        updated_at = NOW()
                    WHERE id = $1 AND (payment_status IS DISTINCT FROM 'rejected')
                    RETURNING id
                """, order_id, rejected_by)
                return bool(row)
        return await self.execute_with_retry(_fn)

    async def get_payment_receipts_for_order(self, order_id: int):
        async def _get():
            async with self.pool.acquire() as conn:
                rows = await conn.fetch('''
                    SELECT * FROM payment_receipts WHERE order_id = $1 ORDER BY created_at DESC
                ''', order_id)
                return [dict(r) for r in rows]
        try:
            return await self.execute_with_retry(_get)
        except Exception as e:
            logger.error(f"❌ Failed to get payment receipts for order {order_id}: {e}")
            return []


=== src/database/reservation_manager.py ===
import asyncio
from datetime import datetime, date, time, timedelta
from typing import Dict, List, Optional
import asyncpg
from contextlib import asynccontextmanager
import logging

logger = logging.getLogger(__name__)

class ReservationManager:
    def __init__(self, db_manager):
        self.db_manager = db_manager
        self.restaurant_config = {
            'opening_time': time(10, 0),  # 10:00
            'closing_time': time(22, 0),  # 22:00
            'table_capacity': 40,         # Общая вместимость
            'max_tables': 10,             # Количество столов
            'reservation_duration': timedelta(hours=2),  # Длительность брони
            'cleaning_interval': timedelta(minutes=30)   # Время на уборку
        }
    
    async def check_table_availability(self, reservation_date: str, reservation_time: str, guests_count: int) -> Dict[str, any]:
        """Проверка доступности столов с правильной логикой пересечений"""
        try:
            # Преобразуем дату и время
            day, month, year = map(int, reservation_date.split('.'))
            reservation_date_obj = date(year, month, day)
            
            time_parts = reservation_time.split(':')
            hour, minute = map(int, time_parts)
            reservation_time_obj = time(hour, minute)
            target_datetime = datetime(year, month, day, hour, minute)
            
            # Проверка базовых условий
            basic_checks = await self._check_basic_conditions(target_datetime, guests_count)
            if not basic_checks["available"]:
                return basic_checks
            
            # Получаем все брони на эту дату
            reservations = await self._get_reservations_for_date(reservation_date_obj)
            
            # Проверяем доступность с учетом пересечений
            availability = await self._check_availability_with_overlaps(
                target_datetime, guests_count, reservations
            )
            
            return availability
            
        except Exception as e:
            logger.error(f"❌ Error checking table availability: {e}")
            return {"available": False, "reason": "error", "message": str(e)}
    
    async def _check_basic_conditions(self, target_datetime: datetime, guests_count: int) -> Dict[str, any]:
        """Проверка базовых условий (время работы, валидность даты и т.д.)"""
        hour = target_datetime.hour
        
        # Проверка времени работы
        if hour < self.restaurant_config['opening_time'].hour or hour >= self.restaurant_config['closing_time'].hour:
            return {"available": False, "reason": "restaurant_closed"}
        
        # Проверка на прошедшую дату
        if target_datetime < datetime.now():
            return {"available": False, "reason": "past_date"}
        
        # Проверка количества гостей
        if guests_count <= 0 or guests_count > 20:
            return {"available": False, "reason": "invalid_guests_count"}
        
        return {"available": True}
    
    async def _get_reservations_for_date(self, reservation_date: date) -> List[Dict]:
        """Получение всех бронирований на указанную дату"""
        query = """
            SELECT reservation_time, guests_count, status 
            FROM reservations 
            WHERE reservation_date = $1 
            AND status IN ('pending', 'confirmed')
        """
        
        async with self.db_manager.pool.acquire() as conn:
            rows = await conn.fetch(query, reservation_date)
            return [dict(row) for row in rows]
    
    async def _check_availability_with_overlaps(self, target_datetime: datetime, guests_count: int, reservations: List[Dict]) -> Dict[str, any]:
        """Проверка доступности с учетом пересечений временных интервалов"""
        
        # Рассчитываем временной интервал брони
        reservation_start = target_datetime
        reservation_end = reservation_start + self.restaurant_config['reservation_duration']
        
        # Считаем занятые места в пересекающихся интервалах
        overlapping_guests = 0
        overlapping_reservations = 0
        
        for reservation in reservations:
            # Время существующей брони
            existing_time = reservation['reservation_time']
            if isinstance(existing_time, str):
                # Если время в строковом формате
                existing_hour, existing_minute = map(int, existing_time.split(':'))
                existing_start = datetime(
                    target_datetime.year, target_datetime.month, target_datetime.day,
                    existing_hour, existing_minute
                )
            else:
                # Если время в формате time
                existing_start = datetime.combine(target_datetime, existing_time)
            
            existing_end = existing_start + self.restaurant_config['reservation_duration']
            
            # Проверяем пересечение интервалов
            if self._time_intervals_overlap(
                reservation_start, reservation_end,
                existing_start, existing_end
            ):
                overlapping_guests += reservation['guests_count']
                overlapping_reservations += 1
        
        # Проверяем вместимость
        total_guests_during_overlap = overlapping_guests + guests_count
        
        if overlapping_reservations >= self.restaurant_config['max_tables']:
            return {
                "available": False, 
                "reason": "no_tables",
                "details": f"Все {self.restaurant_config['max_tables']} столов заняты в это время"
            }
        
        if total_guests_during_overlap > self.restaurant_config['table_capacity']:
            return {
                "available": False, 
                "reason": "capacity_exceeded",
                "details": f"Превышена вместимость: {total_guests_during_overlap}/{self.restaurant_config['table_capacity']}"
            }
        
        return {
            "available": True,
            "reason": "available",
            "details": {
                "overlapping_reservations": overlapping_reservations,
                "available_tables": self.restaurant_config['max_tables'] - overlapping_reservations,
                "current_guests": overlapping_guests,
                "capacity_after": self.restaurant_config['table_capacity'] - total_guests_during_overlap
            }
        }
    
    def _time_intervals_overlap(self, start1: datetime, end1: datetime, start2: datetime, end2: datetime) -> bool:
        """Проверяет пересекаются ли два временных интервала"""
        return (start1 < end2) and (start2 < end1)
    

    @asynccontextmanager
    async def reservation_transaction(self, reservation_date: str, reservation_time: str):
        """Контекстный менеджер для безопасного создания брони"""
        day, month, year = map(int, reservation_date.split('.'))
        reservation_date_obj = date(year, month, day)
        
        async with self.db_manager.pool.acquire() as conn:
            try:
                # Начинаем транзакцию с высоким уровнем изоляции
                async with conn.transaction(isolation='serializable'):
                    # Блокируем таблицу для предотвращения race conditions
                    await conn.execute("LOCK TABLE reservations IN SHARE UPDATE EXCLUSIVE MODE")
                    
                    yield conn
                    
            except asyncpg.SerializationError:
                logger.warning("⚡ Transaction serialization error - retrying might be needed")
                raise
            except Exception as e:
                logger.error(f"❌ Transaction error: {e}")
                raise
    
    async def create_reservation_atomic(self, user_id: int, reservation_date: str, reservation_time: str,
                                      guests_count: int, customer_name: str, customer_phone: str) -> Optional[int]:
        """Атомарное создание брони с проверкой доступности внутри транзакции"""
        
        max_retries = 3
        for attempt in range(max_retries):
            try:
                async with self.reservation_transaction(reservation_date, reservation_time) as conn:
                    # Повторная проверка доступности внутри транзакции
                    availability = await self.check_table_availability(reservation_date, reservation_time, guests_count)
                    
                    if not availability["available"]:
                        logger.warning(f"❌ Reservation no longer available: {availability['reason']}")
                        return None
                    
                    # Создаем бронь
                    reservation_id = await self._create_reservation_in_transaction(
                        conn, user_id, reservation_date, reservation_time, guests_count, customer_name, customer_phone
                    )
                    
                    logger.info(f"✅ Reservation #{reservation_id} created atomically")
                    return reservation_id
                    
            except asyncpg.SerializationError:
                if attempt < max_retries - 1:
                    wait_time = (attempt + 1) * 0.1  # Exponential backoff
                    logger.info(f"🔄 Retrying reservation after serialization error (attempt {attempt + 1})")
                    await asyncio.sleep(wait_time)
                    continue
                else:
                    logger.error("❌ Max retries exceeded for reservation")
                    return None
            except Exception as e:
                logger.error(f"❌ Error in atomic reservation: {e}")
                return None
        
        return None
    
    async def _create_reservation_in_transaction(self, conn, user_id: int, reservation_date: str, reservation_time: str,
                                               guests_count: int, customer_name: str, customer_phone: str) -> int:
        """Создание брони внутри транзакции"""
        
        day, month, year = map(int, reservation_date.split('.'))
        reservation_date_obj = date(year, month, day)
        
        time_parts = reservation_time.split(':')
        hour, minute = map(int, time_parts)
        reservation_time_obj = time(hour, minute)
        
        reservation_id = await conn.fetchval('''
            INSERT INTO reservations 
            (user_id, reservation_date, reservation_time, guests_count, customer_name, customer_phone, status)
            VALUES ($1, $2, $3, $4, $5, $6, 'pending')
            RETURNING id
        ''', user_id, reservation_date_obj, reservation_time_obj, guests_count, customer_name, customer_phone)
        
        return reservation_id

=== src/handlers/__init__.py ===
__all__ = ("router", )

from aiogram import Router

router = Router()

# Импортируем и включаем роутеры ПОСЛЕ определения router
from .admin import router as admin_router
from .user import router as user_router

router.include_router(admin_router)
router.include_router(user_router)

=== src/handlers/admin/broadcast.py ===
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InputMediaPhoto, FSInputFile
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder, ReplyKeyboardBuilder
from fluent.runtime import FluentLocalization
import logging
from datetime import datetime
import json

from src.states.broadcast import BroadcastStates
from src.database.db_manager import DatabaseManager
from src.utils.config import settings
from src.utils.logger import get_logger

router = Router()
logger = get_logger(__name__)

class BroadcastManager:
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        
        # Определяем сегменты для рассылки
        self.segments = {
            "all": {"name": "👥 Все пользователи", "filter": {}},
            "male": {"name": "👨 Мужчины", "filter": {"sex": "male"}},
            "female": {"name": "👩 Женщины", "filter": {"sex": "female"}},
            "students": {"name": "🎓 Студенты", "filter": {"major": "student"}},
            "entrepreneurs": {"name": "💼 Предприниматели", "filter": {"major": "entrepreneur"}},
            "employees": {"name": "💻 Работающие по найму", "filter": {"major": "hire"}},
            "freelancers": {"name": "🚀 Фрилансеры", "filter": {"major": "frilans"}}
        }
        
        # Типы контента для рассылки
        self.content_types = {
            "text": {"name": "📝 Только текст", "icon": "📝"},
            "image": {"name": "🖼️ Картинка + текст", "icon": "🖼️"}
        }
    
    async def get_segment_users_count(self, segment_key: str) -> int:
        """Получение количества пользователей в сегменте"""
        try:
            if segment_key == "all":
                stats = await self.db_manager.get_general_stats()
                return stats.get('total_users', 0)
            elif segment_key in ["male", "female"]:
                segments = await self.db_manager.get_target_segments()
                return segments.get(f'{segment_key}_count', 0)
            elif segment_key in ["students", "entrepreneurs", "employees", "freelancers"]:
                segment_map = {
                    "students": "students_count",
                    "entrepreneurs": "entrepreneurs_count", 
                    "employees": "employees_count",
                    "freelancers": "freelancers_count"
                }
                segments = await self.db_manager.get_target_segments()
                return segments.get(segment_map[segment_key], 0)
            else:
                # Для сложных сегментов пока возвращаем примерное количество
                stats = await self.db_manager.get_general_stats()
                return max(1, stats.get('total_users', 0) // 10)
        except Exception as e:
            logger.error(f"❌ Error getting segment count: {e}")
            return 0
    
    async def send_broadcast_message(self, bot: Bot, user_id: int, message_type: str, 
                                text: str, image_file_id: str = None) -> bool:
        """Отправка сообщения пользователю в зависимости от типа"""
        try:
            if message_type == "text":
                await bot.send_message(
                    chat_id=user_id,
                    text=text,
                    parse_mode="HTML"
                )
                return True
                
            elif message_type == "image":
                if not image_file_id:
                    logger.error(f"❌ No image_file_id for image broadcast to {user_id}")
                    # Fallback to text only
                    await bot.send_message(
                        chat_id=user_id,
                        text=text,
                        parse_mode="HTML"
                    )
                    return True
                
                try:
                    # Ограничиваем длину подписи для фото
                    caption = text[:1024] if len(text) > 1024 else text
                    await bot.send_photo(
                        chat_id=user_id,
                        photo=image_file_id,
                        caption=caption,
                        parse_mode="HTML"
                    )
                    return True
                except Exception as photo_error:
                    logger.error(f"❌ Failed to send photo to {user_id}: {photo_error}")
                    # Fallback to text only
                    await bot.send_message(
                        chat_id=user_id,
                        text=f"🖼️ {text}",  # Добавляем эмодзи чтобы показать, что должно было быть изображение
                        parse_mode="HTML"
                    )
                    return True
                    
            else:
                # Fallback для неизвестного типа
                await bot.send_message(
                    chat_id=user_id,
                    text=text,
                    parse_mode="HTML"
                )
                return True
                
        except Exception as e:
            logger.error(f"❌ Failed to send broadcast to {user_id}: {e}")
            return False

@router.message(F.text == "📢 Сделать рассылку подписчикам")
async def start_broadcast(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Начало процесса создания рассылки"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Эта команда доступна только администраторам.")
        return
    
    try:
        # Гарантируем, что пользователь существует в базе
        await db_manager.ensure_user_exists(
            user_id=message.from_user.id,
            username=message.from_user.username,
            full_name=message.from_user.full_name
        )
        
        broadcast_manager = BroadcastManager(db_manager)
        
        # Создаем клавиатуру для выбора сегмента
        builder = InlineKeyboardBuilder()
        
        for segment_key, segment_info in broadcast_manager.segments.items():
            users_count = await broadcast_manager.get_segment_users_count(segment_key)
            builder.button(
                text=f"{segment_info['name']} ({users_count})",
                callback_data=f"broadcast_segment_{segment_key}"
            )
        
        builder.button(text="❌ Отмена", callback_data="broadcast_cancel")
        builder.adjust(1)
        
        await message.answer(
            "📤 <b>СОЗДАНИЕ РАССЫЛКИ</b>\n\n"
            "👥 <b>Выберите аудиторию для рассылки:</b>",
            parse_mode="HTML",
            reply_markup=builder.as_markup()
        )
        
        await state.set_state(BroadcastStates.choosing_segment)
        await db_manager.add_user_action(
            user_id=message.from_user.id,
            action_type='broadcast_started'
        )
        
    except Exception as e:
        logger.error(f"❌ Error starting broadcast: {e}")
        await message.answer("❌ Ошибка при запуске рассылки")
        await state.clear()

@router.callback_query(BroadcastStates.choosing_segment, F.data.startswith("broadcast_segment_"))
async def choose_broadcast_segment(callback: CallbackQuery, state: FSMContext, db_manager: DatabaseManager):
    """Обработка выбора сегмента для рассылки"""
    try:
        segment_key = callback.data.split("_")[2]
        broadcast_manager = BroadcastManager(db_manager)
        
        if segment_key not in broadcast_manager.segments:
            await callback.answer("❌ Неверный сегмент")
            return
        
        segment_info = broadcast_manager.segments[segment_key]
        users_count = await broadcast_manager.get_segment_users_count(segment_key)
        
        await state.update_data(
            segment_key=segment_key,
            segment_name=segment_info["name"],
            users_count=users_count
        )
        
        # Создаем клавиатуру для выбора типа контента
        builder = InlineKeyboardBuilder()
        
        for content_key, content_info in broadcast_manager.content_types.items():
            builder.button(
                text=f"{content_info['icon']} {content_info['name']}",
                callback_data=f"broadcast_type_{content_key}"
            )
        
        builder.button(text="🔙 Назад", callback_data="broadcast_back_to_segments")
        builder.adjust(1)
        
        await callback.message.edit_text(
            f"✅ <b>Выбран сегмент:</b> {segment_info['name']}\n"
            f"👥 <b>Количество пользователей:</b> {users_count}\n\n"
            "🎨 <b>Выберите тип контента:</b>",
            parse_mode="HTML",
            reply_markup=builder.as_markup()
        )
        
        await state.set_state(BroadcastStates.choosing_type)
        await callback.answer()
        
    except Exception as e:
        logger.error(f"❌ Error choosing broadcast segment: {e}")
        await callback.answer("❌ Ошибка при выборе сегмента")

@router.callback_query(BroadcastStates.choosing_type, F.data.startswith("broadcast_type_"))
async def choose_broadcast_type(callback: CallbackQuery, state: FSMContext):
    """Обработка выбора типа контента"""
    try:
        content_type = callback.data.split('_')[2]

        
        
        await state.update_data(content_type=content_type)
        
        if content_type == "text":
            await callback.message.edit_text(
                "📝 <b>Введите текст рассылки:</b>\n\n"
                "💡 <i>Поддерживается HTML-разметка</i>\n"
                "• <b>жирный текст</b>\n" 
                "• <i>курсив</i>\n"
                "• <code>моноширинный</code>\n\n"
                "❌ Для отмены введите /cancel",
                parse_mode="HTML"
            )
            await state.set_state(BroadcastStates.entering_text)
        elif content_type == "image":
            await callback.message.edit_text(
                "🖼️ <b>Отправьте изображение для рассылки:</b>\n\n"
                "💡 <i>Отправьте картинку как фото (не файлом)</i>\n\n"
                "❌ Для отмены введите /cancel",
                parse_mode="HTML"
            )
            await state.set_state(BroadcastStates.entering_image)
        
        await callback.answer()
        
    except Exception as e:
        logger.error(f"❌ Error choosing broadcast type: {e}")
        await callback.answer("❌ Ошибка при выборе типа")

@router.message(BroadcastStates.entering_image, F.photo)
async def process_broadcast_image(message: Message, state: FSMContext, bot: Bot):
    """Обработка загруженного изображения"""
    try:
        # Сохраняем file_id изображения (берем самое высокое качество)
        image_file_id = message.photo[-1].file_id
        
        # Проверяем, что file_id валидный
        try:
            # Пробуем получить информацию о файле
            file_info = await bot.get_file(image_file_id)
            logger.info(f"✅ Image file validated: {file_info.file_id}, size: {file_info.file_size}")
        except Exception as file_error:
            logger.error(f"❌ Invalid image file_id: {file_error}")
            await message.answer("❌ Ошибка: неверный формат изображения. Попробуйте отправить другое изображение.")
            return
        
        # Сохраняем в состояние
        await state.update_data(image_file_id=image_file_id)
        
        # Показываем предпросмотр и запрашиваем текст
        await message.answer_photo(
            photo=image_file_id,
            caption="✅ <b>Изображение получено!</b>\n\n"
                   "📝 Теперь введите текст для рассылки:\n\n"
                   "💡 <i>Этот текст будет подписью к изображению</i>\n"
                   "⚠️ <i>Ограничение: 1024 символа</i>",
            parse_mode="HTML"
        )
        
        await state.set_state(BroadcastStates.entering_text)
        
    except Exception as e:
        logger.error(f"❌ Error processing broadcast image: {e}")
        await message.answer("❌ Ошибка при обработке изображения. Попробуйте отправить другое изображение.")

@router.message(BroadcastStates.entering_image)
async def wrong_image_input(message: Message):
    """Неправильный ввод для изображения"""
    await message.answer("❌ Пожалуйста, отправьте изображение как фото (не файлом)")

@router.message(BroadcastStates.entering_text, F.text)
async def process_broadcast_text(message: Message, state: FSMContext, bot: Bot, db_manager: DatabaseManager):
    """Обработка текста рассылки и показ предпросмотра"""
    try:
        text = message.text
        
        if text.startswith('/cancel'):
            await message.answer("❌ Рассылка отменена")
            await state.clear()
            return
        
        # Проверяем длину текста для изображений
        data = await state.get_data()
        content_type = data.get('content_type', 'text')
        
        if content_type == "image" and len(text) > 1024:
            await message.answer(
                f"❌ <b>Слишком длинный текст!</b>\n\n"
                f"Для изображений максимальная длина подписи: 1024 символа\n"
                f"Ваш текст: {len(text)} символов\n\n"
                f"Сократите текст и отправьте снова:",
                parse_mode="HTML"
            )
            return
        
        await state.update_data(broadcast_text=text)
        
        data = await state.get_data()
        segment_name = data.get('segment_name', 'Неизвестно')
        users_count = data.get('users_count', 0)
        content_type = data.get('content_type', 'text')
        image_file_id = data.get('image_file_id')
        
        # Показываем предпросмотр
        preview_text = (
            f"👁️ <b>ПРЕДПРОСМОТР РАССЫЛКИ</b>\n\n"
            f"👥 <b>Аудитория:</b> {segment_name}\n"
            f"📊 <b>Пользователей:</b> {users_count}\n"
            f"🎨 <b>Тип:</b> {content_type}\n\n"
            f"💬 <b>Сообщение:</b>\n{text}\n\n"
            f"⚠️ <b>Внимание!</b> После подтверждения рассылка начнется немедленно."
        )
        
        # Создаем клавиатуру подтверждения
        builder = InlineKeyboardBuilder()
        builder.button(text="✅ Подтвердить рассылку", callback_data="broadcast_confirm")
        builder.button(text="✏️ Изменить текст", callback_data="broadcast_edit_text")
        builder.button(text="🔄 Выбрать другой сегмент", callback_data="broadcast_back_to_segments")
        builder.button(text="❌ Отмена", callback_data="broadcast_cancel")
        builder.adjust(1)
        
        if content_type == "image" and image_file_id:
            try:
                await message.answer_photo(
                    photo=image_file_id,
                    caption=preview_text,
                    parse_mode="HTML",
                    reply_markup=builder.as_markup()
                )
            except Exception as preview_error:
                logger.error(f"❌ Error showing image preview: {preview_error}")
                await message.answer(
                    f"❌ <b>Ошибка предпросмотра изображения</b>\n\n"
                    f"{preview_text}",
                    parse_mode="HTML",
                    reply_markup=builder.as_markup()
                )
        else:
            await message.answer(
                preview_text,
                parse_mode="HTML",
                reply_markup=builder.as_markup()
            )
        
        await state.set_state(BroadcastStates.confirming)
        
    except Exception as e:
        logger.error(f"❌ Error processing broadcast text: {e}")
        await message.answer("❌ Ошибка при обработке текста")

@router.callback_query(BroadcastStates.confirming, F.data == "broadcast_confirm")
async def confirm_broadcast(callback: CallbackQuery, state: FSMContext, bot: Bot, db_manager: DatabaseManager):
    """Подтверждение и запуск рассылки"""
    try:
        await callback.answer()

        data = await state.get_data()
        segment_key = data.get('segment_key')
        segment_name = data.get('segment_name')
        users_count = data.get('users_count', 0)
        content_type = data.get('content_type')
        text = data.get('broadcast_text')
        image_file_id = data.get('image_file_id')
        
        logger.info(f"📤 Starting broadcast: type={content_type}, segment={segment_key}, users={users_count}, has_image={bool(image_file_id)}")
        
        # Вместо редактирования существующего сообщения, отправляем новое
        progress_message = await callback.message.answer(
            f"🚀 <b>ЗАПУСК РАССЫЛКИ</b>\n\n"
            f"📤 Отправка {users_count} сообщений...\n"
            f"⏳ Это может занять несколько минут",
            parse_mode="HTML"
        )
        
        # Создаем запись о рассылке в БД
        broadcast_id = await db_manager.create_broadcast(
            title=f"Рассылка {datetime.now().strftime('%d.%m.%Y %H:%M')}",
            message_text=text,
            target_sex='all',
            target_major='all',
            message_type=content_type,
            image_file_id=image_file_id
        )
        
        if not broadcast_id:
            await progress_message.edit_text("❌ Ошибка при создании рассылки в БД")
            await state.clear()
            return
        
        # Получаем пользователей для рассылки
        users = await db_manager.get_users_by_segment(segment_key)
        
        # Запускаем рассылку
        broadcast_manager = BroadcastManager(db_manager)
        sent_count = 0
        failed_count = 0
        
        for user in users:
            try:
                success = await broadcast_manager.send_broadcast_message(
                    bot=bot,
                    user_id=user['user_id'],
                    message_type=content_type,
                    text=text,
                    image_file_id=image_file_id
                )
                
                if success:
                    sent_count += 1
                else:
                    failed_count += 1
                    
                # Обновляем прогресс каждые 10 сообщений
                if (sent_count + failed_count) % 10 == 0:
                    try:
                        await progress_message.edit_text(
                            f"📤 <b>РАССЫЛКА В ПРОЦЕССЕ</b>\n\n"
                            f"✅ Отправлено: {sent_count}\n"
                            f"❌ Ошибок: {failed_count}\n"
                            f"⏳ Осталось: {len(users) - sent_count - failed_count}",
                            parse_mode="HTML"
                        )
                    except Exception as edit_error:
                        logger.error(f"Ошибка редактирования progress_message: {edit_error}")
                        # Продолжаем рассылку даже если не удалось обновить прогресс
                        
            except Exception as e:
                logger.error(f"❌ Failed to send to {user['user_id']}: {e}")
                failed_count += 1
        
        # Финальный отчет
        report_text = (
            f"✅ <b>РАССЫЛКА ЗАВЕРШЕНА</b>\n\n"
            f"📊 <b>Итоги:</b>\n"
            f"• ✅ Успешно: {sent_count}\n"
            f"• ❌ Ошибок: {failed_count}\n"
            f"• 📈 Эффективность: {sent_count/max(1, len(users))*100:.1f}%\n\n"
            f"👥 <b>Аудитория:</b> {segment_name}\n"
            f"🎨 <b>Тип:</b> {content_type}\n"
            f"🆔 <b>ID рассылки:</b> {broadcast_id}"
        )
        
        if content_type == "image":
            report_text += f"\n🖼️ <b>Изображение:</b> {'✅' if image_file_id else '❌'}"
        
        # Обновляем статистику рассылки в БД
        await db_manager.update_broadcast_stats(broadcast_id, sent_count)
        
        await progress_message.edit_text(report_text, parse_mode="HTML")
        
        # Логируем действие
        await db_manager.add_user_action(
            user_id=callback.from_user.id,
            action_type='broadcast_completed',
            action_data={
                'broadcast_id': broadcast_id,
                'segment': segment_key,
                'sent_count': sent_count,
                'failed_count': failed_count,
                'content_type': content_type,
                'has_image': bool(image_file_id)
            }
        )
        
        logger.info(f"✅ Broadcast #{broadcast_id} completed: {sent_count} sent, {failed_count} failed")
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"❌ Error confirming broadcast: {e}")
        try:
            # Пытаемся отправить сообщение об ошибке новым сообщением
            await callback.message.answer("❌ Ошибка при запуске рассылки")
        except Exception as send_error:
            logger.error(f"❌ Failed to send error message: {send_error}")
        await state.clear()

@router.callback_query(F.data == "broadcast_back_to_segments")
async def back_to_segments(callback: CallbackQuery, state: FSMContext, db_manager: DatabaseManager, l10n: FluentLocalization):
    """Возврат к выбору сегмента"""
    # Используем существующую функцию start_broadcast, но передаем правильные параметры
    if not settings.is_admin(callback.from_user.id):
        await callback.answer("❌ Эта команда доступна только администраторам.")
        return
    
    try:
        # Гарантируем, что пользователь существует в базе
        await db_manager.ensure_user_exists(
            user_id=callback.from_user.id,
            username=callback.from_user.username,
            full_name=callback.from_user.full_name
        )
        
        broadcast_manager = BroadcastManager(db_manager)
        
        # Создаем клавиатуру для выбора сегмента
        builder = InlineKeyboardBuilder()
        
        for segment_key, segment_info in broadcast_manager.segments.items():
            users_count = await broadcast_manager.get_segment_users_count(segment_key)
            builder.button(
                text=f"{segment_info['name']} ({users_count})",
                callback_data=f"broadcast_segment_{segment_key}"
            )
        
        builder.button(text="❌ Отмена", callback_data="broadcast_cancel")
        builder.adjust(1)
        
        await callback.message.edit_text(
            "📤 <b>СОЗДАНИЕ РАССЫЛКИ</b>\n\n"
            "👥 <b>Выберите аудиторию для рассылки:</b>",
            parse_mode="HTML",
            reply_markup=builder.as_markup()
        )
        
        await state.set_state(BroadcastStates.choosing_segment)
        await db_manager.add_user_action(
            user_id=callback.from_user.id,
            action_type='broadcast_restarted'
        )
        
        await callback.answer()
        
    except Exception as e:
        logger.error(f"❌ Error in back_to_segments: {e}")
        await callback.answer("❌ Ошибка при возврате к выбору сегмента")

@router.callback_query(F.data == "broadcast_edit_text")
async def edit_broadcast_text(callback: CallbackQuery, state: FSMContext):
    """Редактирование текста рассылки"""
    data = await state.get_data()
    content_type = data.get('content_type', 'text')
    
    if content_type == "text":
        await callback.message.edit_text(
            "📝 <b>Введите новый текст рассылки:</b>\n\n"
            "💡 <i>Поддерживается HTML-разметка</i>",
            parse_mode="HTML"
        )
    else:
        await callback.message.edit_text(
            "📝 <b>Введите новый текст для изображения:</b>",
            parse_mode="HTML"
        )
    
    await state.set_state(BroadcastStates.entering_text)
    await callback.answer()

@router.callback_query(F.data == "broadcast_cancel")
async def cancel_broadcast(callback: CallbackQuery, state: FSMContext):
    """Отмена рассылки"""
    await callback.message.edit_text("❌ Рассылка отменена")
    await state.clear()
    await callback.answer()

# Обработка команды отмены
@router.message(BroadcastStates.entering_text, F.text == "/cancel")
@router.message(BroadcastStates.entering_image, F.text == "/cancel")
async def cancel_broadcast_command(message: Message, state: FSMContext):
    """Отмена рассылки по команде"""
    await message.answer("❌ Рассылка отменена")
    await state.clear()

=== src/handlers/admin/callback.py ===
from aiogram import Router, F
from aiogram.types import CallbackQuery
import logging
import json
from src.utils.time_utils import format_restaurant_time
from src.utils.config import settings
from functools import wraps

from aiogram.utils.keyboard import InlineKeyboardBuilder

router = Router()
logger = logging.getLogger(__name__)

def staff_required_callback(func):
    """Декоратор для проверки прав доступа в callback хэндлерах (админы + стафф)"""
    @wraps(func)
    async def wrapper(callback: CallbackQuery, *args, **kwargs):
        if not settings.is_staff(callback.from_user.id):
            await callback.answer("❌ У вас нет доступа к этой команде.", show_alert=True)
            return
        return await func(callback, *args, **kwargs)
    return wrapper

async def notify_all_staff_call_accepted(bot, staff_name: str, staff_username: str, table_number: int, call_id: int, user_info: str, call_time: str, accepted_by_staff_id: int, original_message_ids: dict):
    """Уведомляем всех официантов, что вызов принят с сохранением всех данных"""
    try:
        logger.info(f"🔔 Уведомление о принятии вызова #{call_id}. Принял: {staff_name} (ID: {accepted_by_staff_id})")
        logger.info(f"📋 Message IDs для обновления: {original_message_ids}")
        logger.info(f"🔍 Тип accepted_by_staff_id: {type(accepted_by_staff_id)}")
        
        # 🔥 ИСПРАВЛЕННЫЙ ТЕКСТ: Теперь user_info содержит информацию о клиенте
        base_text = (
            f"✅ <b>ВЫЗОВ ПРИНЯТ</b>\n"
            f"👨‍💼 <b>Принял:</b> {staff_name} (@{staff_username})\n\n"
            f"🪑 <b>Стол:</b> #{table_number}\n"
            f"👤 <b>Клиент:</b> {user_info}\n"  # 🔥 Теперь здесь информация о клиенте
            f"⏰ <b>Время вызова:</b> {call_time}\n"
            f"🆔 <b>ID вызова:</b> {call_id}\n\n"
            f"<i>Официант уже направляется к столу</i>"
        )
        
        # Обновляем сообщения у всех официантов
        update_count = 0
        for staff_id_str, message_id in original_message_ids.items():
            try:
                # Преобразуем строковый staff_id в int для сравнения
                staff_id_int = int(staff_id_str)
                
                logger.info(f"🔄 Обновление сообщения для staff_id: {staff_id_str}->{staff_id_int}, message_id: {message_id}")
                logger.info(f"🔍 Сравнение: {staff_id_int} == {accepted_by_staff_id} -> {staff_id_int == accepted_by_staff_id}")
                
                # Если это тот официант, который принял вызов - даем кнопку завершения
                if staff_id_int == accepted_by_staff_id:
                    logger.info(f"🎯 Это принявший официант, добавляем кнопку завершения")
                    keyboard = InlineKeyboardBuilder()
                    keyboard.button(text="✅ Завершить вызов", callback_data=f"complete_call_{call_id}")
                    
                    updated_text = base_text + "\n\n<b>Нажмите 'Завершить' после обслуживания стола</b>"
                    
                    await bot.edit_message_text(
                        chat_id=staff_id_int,
                        message_id=message_id,
                        text=updated_text,
                        reply_markup=keyboard.as_markup(),
                        parse_mode="HTML"
                    )
                    logger.info(f"✅ Добавлена кнопку завершения для принявшего официанта")
                else:
                    # Для остальных - просто информация (без кнопок)
                    logger.info(f"📝 Это другой официант, убираем кнопки")
                    await bot.edit_message_text(
                        chat_id=staff_id_int,
                        message_id=message_id,
                        text=base_text,
                        reply_markup=None,
                        parse_mode="HTML"
                    )
                
                update_count += 1
                
            except Exception as e:
                logger.error(f"❌ Ошибка при обновлении сообщения для staff {staff_id_str}: {e}")
        
        logger.info(f"✅ Успешно обновлено {update_count} сообщений из {len(original_message_ids)}")
        
    except Exception as e:
        logger.error(f"❌ Критическая ошибка в notify_all_staff_call_accepted: {e}", exc_info=True)

@router.callback_query(F.data.startswith("accept_call_"))
@staff_required_callback
async def accept_staff_call(callback: CallbackQuery, db_manager=None, settings=None):
    """Обработка принятия вызова персоналом - ТОЛЬКО принятие, без завершения"""
    try:
        call_id = int(callback.data.split("_")[2])
        staff_id = callback.from_user.id
        staff_name = callback.from_user.full_name
        staff_username = callback.from_user.username
        
        logger.info(f"🔄 Начало принятия вызова #{call_id} персоналом {staff_name} (ID: {staff_id})")
        
        # Проверяем, не принят ли вызов уже другим официантом
        call = await db_manager.get_staff_call(call_id)
        if not call:
            logger.error(f"❌ Вызов #{call_id} не найден")
            await callback.answer("❌ Вызов не найден", show_alert=True)
            return

        logger.info(f"📊 Статус вызова #{call_id}: {call['status']}")
        
        if call['status'] != 'pending':
            logger.warning(f"⚠️ Вызов #{call_id} уже принят. Текущий статус: {call['status']}")
            await callback.answer("❌ Этот вызов уже принят другим официантом", show_alert=True)
            return
        
        # Принимаем вызов (меняем статус на 'accepted')
        success = await db_manager.accept_staff_call(call_id, staff_id, staff_name)
        if not success:
            logger.error(f"❌ Не удалось принять вызов #{call_id} в БД")
            await callback.answer("❌ Не удалось принять вызов", show_alert=True)
            return
        
        logger.info(f"✅ Вызов #{call_id} принят в БД")
        
        # Получаем message_ids из БД
        message_ids = {}
        if call.get('message_ids'):
            try:
                if isinstance(call['message_ids'], str):
                    message_ids = json.loads(call['message_ids'])
                else:
                    message_ids = call['message_ids']
                
                logger.info(f"📨 Получены message_ids для вызова #{call_id}: {message_ids}")
                logger.info(f"🔍 Типы ключей: {[type(k) for k in message_ids.keys()]}")
                
            except Exception as e:
                logger.error(f"❌ Failed to parse message_ids for call {call_id}: {e}")
        else:
            logger.warning(f"⚠️ Нет message_ids для вызова #{call_id}")
        
        
        user_info = await get_client_info_for_call(call, db_manager)
        
        # Получаем время создания вызова
        call_time = format_restaurant_time(call['created_at']) if call.get('created_at') else "Неизвестно"
        
        # Уведомляем всех официантов об принятии вызова
        if message_ids:
            logger.info(f"🔔 Начинаем уведомление персонала о принятии вызова #{call_id}")
            await notify_all_staff_call_accepted(
                bot=callback.bot,
                staff_name=staff_name,
                staff_username=staff_username,
                table_number=call['table_number'],
                call_id=call_id,
                user_info=user_info,
                call_time=call_time,
                accepted_by_staff_id=staff_id,
                original_message_ids=message_ids
            )
            logger.info(f"✅ Уведомления отправлены для вызова #{call_id}")
        else:
            logger.error(f"❌ Не могу уведомить персонала - нет message_ids для вызова #{call_id}")
        
        await callback.answer(f"✅ Вы приняли вызов стола #{call['table_number']}", show_alert=True)
        logger.info(f"🎯 Вызов стола #{call['table_number']} принят персоналом {staff_name}")
        
    except Exception as e:
        logger.error(f"❌ Критическая ошибка в accept_staff_call: {e}", exc_info=True)
        await callback.answer("❌ Произошла ошибка при принятии вызова", show_alert=True)

async def get_client_info_for_call(call: dict, db_manager) -> str:
    """Получение информации о клиенте для вызова персонала"""
    try:
        # Получаем информацию о пользователе из базы данных
        user = await db_manager.get_user(call['user_id'])
        
        if user:
            # Формируем информацию о клиенте
            client_info = user.get('full_name', 'Неизвестный клиент')
            
            # Добавляем username, если есть
            if user.get('username'):
                client_info += f" (@{user['username']})"
            
            # Добавляем демографическую информацию, если есть
            demographics = []
            if user.get('sex') and user['sex'] != 'unknown':
                sex_display = {
                    'male': '👨',
                    'female': '👩', 
                    'other': '👤'
                }.get(user['sex'], '👤')
                demographics.append(sex_display)
            
            if user.get('major') and user['major'] != 'unknown':
                major_display = {
                    'student': '🎓',
                    'entrepreneur': '💼',
                    'hire': '💻', 
                    'frilans': '🚀'
                }.get(user['major'], '👤')
                demographics.append(major_display)
            
            if demographics:
                client_info += f" {''.join(demographics)}"
            
            logger.info(f"👤 Получена информация о клиенте: {client_info}")
            return client_info
        else:
            logger.warning(f"⚠️ Пользователь {call['user_id']} не найден в БД")
            return "Неизвестный клиент"
            
    except Exception as e:
        logger.error(f"❌ Ошибка при получении информации о клиенте: {e}")
        return "Клиент"

@router.callback_query(F.data.startswith("complete_call_"))
@staff_required_callback
async def complete_staff_call(callback: CallbackQuery, db_manager=None):
    """Завершение вызова персоналом"""
    try:
        call_id = int(callback.data.split("_")[2])
        staff_id = callback.from_user.id
        
        logger.info(f"🔄 Завершение вызова #{call_id} персоналом {staff_id}")
        
        # Проверяем, что вызов принят этим официантом
        call = await db_manager.get_staff_call(call_id)
        if not call:
            await callback.answer("❌ Вызов не найден", show_alert=True)
            return
            
        # 🔥 Проверяем, что вызов принят этим официантом (учитываем типы данных)
        accepted_by = call.get('accepted_by')
        if call['status'] != 'accepted' or accepted_by != staff_id:
            logger.warning(f"⚠️ Попытка завершения чужого вызова: accepted_by={accepted_by}, staff_id={staff_id}")
            await callback.answer("❌ Вы не принимали этот вызов", show_alert=True)
            return

        # Завершаем вызов
        success = await db_manager.complete_staff_call(call_id)
        if success:
            # Обновляем сообщение у официанта
            await callback.message.edit_text(
                f"✅ Вызов стола #{call['table_number']} завершен",
                parse_mode="Markdown"
            )
            await callback.answer("✅ Вызов завершен")
            logger.info(f"✅ Вызов #{call_id} завершен")
        else:
            await callback.answer("❌ Не удалось завершить вызов", show_alert=True)
            
    except Exception as e:
        logger.error(f"❌ Error in complete_staff_call: {e}")
        await callback.answer("❌ Произошла ошибка при завершении вызова", show_alert=True)

@router.callback_query(F.data.startswith("cancel_call_"))
@staff_required_callback
async def cancel_staff_call(callback: CallbackQuery, db_manager = None):
    """Обработка отмены вызова персоналом"""
    try:
        call_id = int(callback.data.split("_")[2])
        
        success = await db_manager.cancel_staff_call(call_id)
        if success:
            await callback.answer("✅ Вызов отменен", show_alert=True)
        else:
            await callback.answer("❌ Не удалось отменить вызов", show_alert=True)
            
    except Exception as e:
        logger.error(f"❌ Error in cancel_staff_call: {e}")
        await callback.answer("❌ Произошла ошибка при отмене вызова", show_alert=True)






@router.callback_query(F.data == "refresh_health")
@staff_required_callback
async def refresh_health_check(callback: CallbackQuery, db_manager=None, bot=None):
    """Обновление проверки здоровья"""
    try:
        from src.utils.health_monitor import HealthMonitor
        monitor = HealthMonitor(db_manager, bot)
        health_data = await monitor.perform_full_health_check()
        
        status_emoji = {
            "healthy": "✅",
            "degraded": "⚠️", 
            "unhealthy": "❌"
        }
        
        text = f"🏥 <b>SYSTEM HEALTH MONITOR</b> (Updated)\n\n"
        text += f"📊 <b>Overall Status:</b> {status_emoji[health_data['status'].value]} {health_data['status'].value.upper()}\n"
        text += f"🕐 <b>Last Check:</b> {health_data['timestamp'].strftime('%H:%M:%S')}\n\n"
        
        # Обновляем сообщение
        await callback.message.edit_text(text, parse_mode="HTML")
        await callback.answer("✅ Health check refreshed")
        
    except Exception as e:
        await callback.answer("❌ Failed to refresh health check", show_alert=True)

=== src/handlers/admin/delivery_dashboard.py ===
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, ReplyKeyboardRemove
from aiogram.utils.keyboard import InlineKeyboardBuilder
from datetime import datetime, timedelta
import logging
import re

from src.database.db_manager import DatabaseManager
from src.utils.config import settings
from fluent.runtime import FluentLocalization

router = Router()
logger = logging.getLogger(__name__)


# helper: считаем длину caption без HTML тегов (для ограничения Telegram ~1024 символа)
def _strip_html_tags(text: str) -> str:
    if not text:
        return ""
    return re.sub(r'<[^>]+>', '', text)

def _caption_too_long(text: str, limit: int = 1024) -> bool:
    # считаем длину без HTML тегов (Telegram считает символы без тегов)
    return len(_strip_html_tags(text)) > limit


class DeliveryDashboard:
    def __init__(self, db_manager):
        self.db_manager = db_manager
    
    async def get_dashboard_stats(self):
        """Получение статистики для дашборда с правильными суммами"""
        stats = {
            'today': 0,
            'pending': 0,
            'preparing': 0,
            'on_way': 0,
            'delivered': 0,
            'urgent': 0,
            'total_revenue': 0,  # Добавляем общую выручку
            'total_discounts': 0,  # Добавляем общие скидки
        }
        
        try:
            # Получаем заказы за сегодня
            today_orders = await self.db_manager.get_delivery_orders_today()
            stats['today'] = len(today_orders)
            
            # Считаем по статусам и суммам
            for order in today_orders:
                status = order['status']
                if status in stats:
                    stats[status] += 1
                
                # Считаем выручку для доставленных заказов
                if status in ['delivered', 'completed']:
                    stats['total_revenue'] += order.get('final_amount', 0)
                
                # Считаем общие скидки
                stats['total_discounts'] += order.get('discount_amount', 0)
            
            # Срочные заказы (менее 30 минут)
            from datetime import datetime, timezone
            now_utc = datetime.now(timezone.utc)
            
            urgent_orders = []
            for order in today_orders:
                if order['status'] in ['pending', 'preparing']:
                    created_at = order['created_at']
                    if created_at.tzinfo is None:
                        created_at = created_at.replace(tzinfo=timezone.utc)
                    
                    time_diff = (now_utc - created_at).total_seconds()
                    if time_diff < 1800:  # 30 минут
                        urgent_orders.append(order)
            
            stats['urgent'] = len(urgent_orders)
            
        except Exception as e:
            logger.error(f"❌ Error getting dashboard stats: {e}")
        
        return stats
    
    async def format_dashboard_message(self, stats, urgent_orders, active_orders):
        """Форматирование сообщения дашборда с правильными суммами"""
        
        message = "🛵 <b>ПАНЕЛЬ УПРАВЛЕНИЯ ДОСТАВКОЙ</b>\n\n"
        
        # Статистика с выручкой
        message += f"📊 <b>СЕГОДНЯ:</b> {stats['today']} заказов\n"
        message += f"⏳ Ожидают: {stats['pending']} | 👨‍🍳 Готовятся: {stats['preparing']} | "
        message += f"🚗 В пути: {stats['on_way']} | ✅ Завершены: {stats['delivered']}\n"
        
        if stats['total_revenue'] > 0:
            message += f"💰 <b>Выручка за сегодня:</b> {stats['total_revenue']}₽\n"
        
        if stats['total_discounts'] > 0:
            message += f"🎁 <b>Предоставлено скидок:</b> -{stats['total_discounts']}₽\n"
        
        message += "\n"
        
        # Срочные заказы
        if urgent_orders:
            message += "🔥 <b>СРОЧНЫЕ ЗАКАЗЫ (менее 30 минут):</b>\n"
            message += "──────────────────────────────\n"
            
            for order in urgent_orders:  # БЕЗ ограничения
                message += await self.format_order_card(order, urgent=True)
                message += "\n"
        else:
            message += "✅ <b>Срочных заказов нет</b>\n\n"
        
        # Активные заказы - БЕЗ ограничения [:5]
        if active_orders:
            message += "📋 <b>ВСЕ АКТИВНЫЕ ЗАКАЗЫ:</b>\n"
            message += "──────────────────────────────\n"
            
            for order in active_orders:  # БЕЗ ограничения
                message += await self.format_order_card(order, urgent=False)
                message += "\n"
        
        return message
    
    async def format_order_card(self, order, urgent=False):
        """Форматирование карточки заказа с указанием количества блюд и типа оплаты"""
        time_ago = self.get_time_ago(order['created_at'])
        phone_masked = self.mask_phone(order.get('customer_phone', '—'))

        card = ""
        if urgent:
            card += "🆕 "
        else:
            status_emoji = {
                'pending': '⏳',
                'preparing': '👨‍🍳',
                'on_way': '🚗',
                'delivered': '✅'
            }.get(order.get('status'), '📦')
            card += f"{status_emoji} "

        # Заголовок: id, время, имя, телефон, время с момента
        created_at = order.get('created_at')
        created_time_str = created_at.strftime('%H:%M') if created_at else "—:—"
        card += f"<b>#{order.get('id')}</b> | {created_time_str} | "
        card += f"{order.get('customer_name', '—')} 📞 {phone_masked} | {time_ago}\n"

        try:
            # Получаем order_data (поддерживаем строку JSON и dict)
            order_data = order.get('order_data', {}) or {}
            if isinstance(order_data, str):
                import json
                try:
                    order_data = json.loads(order_data)
                except Exception:
                    order_data = {}

            items = order_data.get('items', []) if isinstance(order_data, dict) else []

            # Формируем краткий список позиций с количествами: "Пицца x2, Салат x1"
            item_lines = []
            for it in items:
                try:
                    name = it.get('name', '—')
                    qty = it.get('quantity', 1)
                    item_lines.append(f"{name} x{qty}")
                except Exception:
                    continue

            if item_lines:
                # Показываем до 2 позиций + "и ещё N"
                preview = ", ".join(item_lines[:2])
                if len(item_lines) > 2:
                    preview += f" и ещё {len(item_lines) - 2}"
                card += f"   {preview}"
            else:
                card += "   Состав заказа не доступен"

            # Сумма: старая/новая + инфо о скидках/бонусах
            final_amount = order.get('final_amount')
            total_amount = order.get('total_amount', 0) or 0

            if final_amount and final_amount != total_amount:
                card += f" | <s>{int(total_amount)}₽</s> <b>{int(final_amount)}₽</b>"
                discount_info = []
                if order.get('discount_amount', 0) > 0:
                    discount_info.append(f"🎁 -{int(order['discount_amount'])}₽")
                if order.get('bonus_used', 0) > 0:
                    discount_info.append(f"💎 -{int(order['bonus_used'])}₽")
                if discount_info:
                    card += f" ({' '.join(discount_info)})"
            else:
                amount_to_show = int(final_amount) if final_amount is not None else int(total_amount)
                card += f" | {amount_to_show}₽"

            card += "\n"

            # Если срочный — покажем короткий адрес
            if urgent:
                addr = order.get('delivery_address', '') or ''
                short_addr = (addr[:30] + '...') if len(addr) > 30 else addr
                card += f"   🏠 {short_addr}\n"

            # Добавляем информацию о типе оплаты и статусе оплаты
            payment_method = order.get('payment_method') or (order_data.get('payment_method') if isinstance(order_data, dict) else None) or '—'
            payment_status = order.get('payment_status') or '—'
            card += f"   💳 Оплата: {payment_method} ({payment_status})\n"

        except Exception as e:
            logger.error(f"❌ Error formatting order items: {e}")
            card += "   Состав заказа не доступен\n"

        return card
    
    def get_time_ago(self, created_at):
        """Время с момента создания заказа"""
        from datetime import datetime, timezone
        
        try:
            now = datetime.now(timezone.utc)
            
            if created_at.tzinfo is None:
                created_at = created_at.replace(tzinfo=timezone.utc)
            
            diff = now - created_at
            minutes = int(diff.total_seconds() / 60)
            
            if minutes < 1:
                return "только что"
            elif minutes < 60:
                return f"{minutes} мин назад"
            else:
                hours = minutes // 60
                return f"{hours} ч назад"
                
        except Exception as e:
            logger.error(f"❌ Error in get_time_ago: {e}")
            return "неизвестно"
    
    def mask_phone(self, phone):
        """Маскировка номера телефона"""
        phone_str = str(phone)
        if len(phone_str) >= 6:
            return phone_str[:4] + '***' + phone_str[-2:]
        return phone_str
    
    async def get_dashboard_keyboard(self, orders):
        """Клавиатура для дашборда - кнопки для ВСЕХ активных заказов"""
        builder = InlineKeyboardBuilder()
        
        # Кнопки для ВСЕХ активных заказов (не только срочных)
        active_orders = [o for o in orders if o['status'] in ['pending', 'preparing', 'on_way']]
        
        for order in active_orders:  # БЕЗ ограничения
            if order['status'] == 'pending':
                builder.row(
                    InlineKeyboardButton(
                        text=f"👨‍🍳 Начать #{order['id']}",
                        callback_data=f"dashboard_start_{order['id']}"
                    ),
                    InlineKeyboardButton(
                        text=f"📞 #{order['id']}",
                        callback_data=f"dashboard_call_{order['id']}"
                    )
                )
            elif order['status'] == 'preparing':
                builder.row(
                    InlineKeyboardButton(
                        text=f"🚗 В путь #{order['id']}",
                        callback_data=f"dashboard_ship_{order['id']}"
                    ),
                    InlineKeyboardButton(
                        text=f"📞 #{order['id']}",
                        callback_data=f"dashboard_call_{order['id']}"
                    )
                )
            elif order['status'] == 'on_way':
                builder.row(
                    InlineKeyboardButton(
                        text=f"✅ Доставлен #{order['id']}",
                        callback_data=f"dashboard_delivered_{order['id']}"
                    ),
                    InlineKeyboardButton(
                        text=f"📞 #{order['id']}",
                        callback_data=f"dashboard_call_{order['id']}"
                    )
                )
        
        # Общие кнопки
        builder.row(
            InlineKeyboardButton(text="🔄 Обновить", callback_data="dashboard_refresh"),
            InlineKeyboardButton(text="📊 Статистика", callback_data="dashboard_stats")
        )
        
        return builder.as_markup()

async def refresh_dashboard(message: Message, db_manager: DatabaseManager):
    """Обновление дашборда — теперь через safe_refresh_dashboard, чтобы не падать на фото/документах."""
    try:
        dashboard = DeliveryDashboard(db_manager)

        stats = await dashboard.get_dashboard_stats()
        all_orders = await db_manager.get_all_delivery_orders()

        urgent_orders = [o for o in all_orders if o['status'] in ['pending', 'preparing']]
        active_orders = [o for o in all_orders if o['status'] in ['pending', 'preparing', 'on_way']]

        text = await dashboard.format_dashboard_message(stats, urgent_orders, active_orders)
        keyboard = await dashboard.get_dashboard_keyboard(active_orders)

        # Используем safe_refresh_dashboard — она умеет работать с сообщениями-изображениями
        try:
            await safe_refresh_dashboard(bot=message.bot, message=message, new_text=text, new_kb=keyboard)
        except Exception as e:
            # Логируем и как последний фоллбек пробуем старый подход (как раньше)
            logger.exception(f"refresh_dashboard: safe_refresh_dashboard failed: {e}")
            try:
                await message.edit_text(text, parse_mode="HTML", reply_markup=keyboard)
            except Exception as edit_error:
                if "message is not modified" not in str(edit_error):
                    logger.exception(f"refresh_dashboard: fallback edit_text also failed: {edit_error}")
    except Exception as e:
        logger.error(f"❌ Error refreshing dashboard: {e}")



async def safe_refresh_dashboard(bot: Bot, message: Message, new_text: str, new_kb=None, parse_mode="HTML"):
    """
    Универсальная, устойчивая функция обновления админского сообщения:
    - если сообщение — фото/document/media_group -> пытаемся edit_message_caption (если в лимите)
      иначе -> delete + send_message
    - если сообщение текстовое -> edit_message_text
    - fallback -> delete + send_message
    """
    chat_id = message.chat.id
    message_id = message.message_id

    # подготовка reply_markup (InlineKeyboardBuilder или InlineKeyboardMarkup)
    reply_markup = None
    if new_kb is not None:
        try:
            reply_markup = new_kb.as_markup() if hasattr(new_kb, "as_markup") else new_kb
        except Exception:
            reply_markup = new_kb

    # флаги наличия контента
    has_photo = bool(getattr(message, "photo", None))
    has_document = getattr(message, "document", None) is not None
    has_media_group = getattr(message, "media_group_id", None) is not None
    has_caption = getattr(message, "caption", None) is not None
    has_text = getattr(message, "text", None) is not None

    logger.debug(f"safe_refresh_dashboard: msg_id={message_id} has_photo={has_photo} has_document={has_document} "
                 f"has_media_group={has_media_group} has_caption={bool(has_caption)} has_text={bool(has_text)}")

    # 1) Если сообщение содержит медиа (photo/document/media_group) — пробуем редактировать caption
    try:
        if has_photo or has_document or has_media_group:
            # если caption не слишком длинный — пробуем edit_message_caption
            if not _caption_too_long(new_text, limit=1024):
                try:
                    await bot.edit_message_caption(
                        chat_id=chat_id,
                        message_id=message_id,
                        caption=new_text,
                        parse_mode=parse_mode,
                        reply_markup=reply_markup
                    )
                    logger.debug("safe_refresh_dashboard: used edit_message_caption")
                    return True
                except Exception as e:
                    logger.debug(f"safe_refresh_dashboard: edit_message_caption failed: {e}")

            # либо caption слишком длинный, либо edit упал -> удаляем старое медиа и отправляем новое текстовое сообщение
            try:
                await bot.delete_message(chat_id=chat_id, message_id=message_id)
            except Exception as e:
                logger.debug(f"safe_refresh_dashboard: failed to delete old media message: {e}")

            await bot.send_message(chat_id=chat_id, text=new_text, parse_mode=parse_mode, reply_markup=reply_markup)
            logger.debug("safe_refresh_dashboard: deleted media and sent text message fallback")
            return True

        # 2) Если сообщение было обычным текстом — пробуем edit_message_text
        if has_text:
            try:
                await bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=message_id,
                    text=new_text,
                    parse_mode=parse_mode,
                    reply_markup=reply_markup
                )
                logger.debug("safe_refresh_dashboard: used edit_message_text")
                return True
            except Exception as e:
                # если сообщение не изменилось — это не ошибка
                if "message is not modified" in str(e):
                    return True
                logger.debug(f"safe_refresh_dashboard: edit_message_text failed: {e}")

        # 3) Фоллбек: удаляем и отправляем новое сообщение
        try:
            await bot.delete_message(chat_id=chat_id, message_id=message_id)
        except Exception as e:
            logger.debug(f"safe_refresh_dashboard: delete_message fallback failed: {e}")

        await bot.send_message(chat_id=chat_id, text=new_text, parse_mode=parse_mode, reply_markup=reply_markup)
        logger.debug("safe_refresh_dashboard: final fallback sent new text message")
        return True

    except Exception as final_e:
        logger.exception(f"safe_refresh_dashboard: final fallback failed: {final_e}")
        return False

async def show_delivery_stats(message: Message, db_manager: DatabaseManager):
    """Показать статистику доставки с ПРАВИЛЬНЫМ расчетом выручки"""
    dashboard = DeliveryDashboard(db_manager)
    
    today_orders = await db_manager.get_delivery_orders_today()
    
    stats_text = "📊 <b>СТАТИСТИКА ДОСТАВКИ</b>\n\n"
    
    if today_orders:
        total_orders = len(today_orders)
        completed_orders = len([o for o in today_orders if o['status'] == 'delivered'])
        
        # 🔥 ПРАВИЛЬНЫЙ РАСЧЕТ ВЫРУЧКИ - используем final_amount для завершенных заказов
        total_revenue = sum(o['final_amount'] for o in today_orders if o['status'] in ['delivered', 'completed'])
        
        # Общая сумма всех заказов за сегодня (по final_amount)
        total_amount_all = sum(o['final_amount'] for o in today_orders)
        
        # Сумма примененных скидок и бонусов
        total_discounts = sum(o.get('discount_amount', 0) for o in today_orders)
        total_bonus_used = sum(o.get('bonus_used', 0) for o in today_orders)
        
        stats_text += f"📦 <b>Заказов сегодня:</b> {total_orders}\n"
        stats_text += f"✅ <b>Доставлено:</b> {completed_orders}\n"
        stats_text += f"💰 <b>Выручка (доставлено):</b> {total_revenue}₽\n"
        stats_text += f"💳 <b>Общая сумма заказов:</b> {total_amount_all}₽\n"
        
        if total_discounts > 0:
            stats_text += f"🎁 <b>Всего скидок:</b> -{total_discounts}₽\n"
        
        if total_bonus_used > 0:
            stats_text += f"💎 <b>Использовано бонусов:</b> -{total_bonus_used}₽\n"
        
        if total_orders > 0:
            conversion_rate = (completed_orders / total_orders) * 100
            stats_text += f"📈 <b>Конверсия:</b> {conversion_rate:.1f}%\n"
        else:
            stats_text += "📈 <b>Конверсия:</b> 0%\n"
            
        # Статистика по статусам
        status_counts = {}
        for order in today_orders:
            status = order['status']
            status_counts[status] = status_counts.get(status, 0) + 1
            
        stats_text += f"\n<b>По статусам:</b>\n"
        for status, count in status_counts.items():
            status_emoji = {
                'pending': '⏳',
                'preparing': '👨‍🍳',
                'on_way': '🚗',
                'delivered': '✅',
                'cancelled': '❌'
            }.get(status, '📦')
            stats_text += f"{status_emoji} {status}: {count}\n"
            
    else:
        stats_text += "📭 Заказов сегодня нет\n"
    
    await message.answer(stats_text, parse_mode="HTML")

@router.message(F.text == "📦 Управление доставкой")
async def delivery_dashboard_admin(message: Message, db_manager: DatabaseManager, l10n: FluentLocalization):
    """Главная панель управления доставкой для АДМИНОВ"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ У вас нет прав для управления заказами")
        return
    
    dashboard = DeliveryDashboard(db_manager)
    
    stats = await dashboard.get_dashboard_stats()
    all_orders = await db_manager.get_all_delivery_orders()
    
    urgent_orders = [o for o in all_orders if o['status'] in ['pending', 'preparing']]
    active_orders = [o for o in all_orders if o['status'] in ['pending', 'preparing', 'on_way']]
    
    text = await dashboard.format_dashboard_message(stats, urgent_orders, active_orders)
    keyboard = await dashboard.get_dashboard_keyboard(active_orders)
    
    await message.answer("📦 Загрузка панели доставки...", reply_markup=ReplyKeyboardRemove())
    await message.answer(text, parse_mode="HTML", reply_markup=keyboard)

@router.callback_query(F.data.startswith("dashboard_"))
async def handle_dashboard_actions(callback: CallbackQuery, db_manager: DatabaseManager, bot: Bot):
    """Обработка действий на дашборде"""
    action = callback.data.split("_")[1]
    order_id = int(callback.data.split("_")[2]) if len(callback.data.split("_")) > 2 else None
    
    try:
        if action == "start" and order_id:
            success = await db_manager.update_delivery_order_status(order_id, "preparing")
            if success:
                await callback.answer("✅ Заказ взят в работу")
                await refresh_dashboard(callback.message, db_manager)
            else:
                await callback.answer("❌ Ошибка при обновлении статуса")
        
        elif action == "ship" and order_id:
            success = await db_manager.update_delivery_order_status(order_id, "on_way")
            if success:
                await callback.answer("🚗 Заказ передан курьеру")
                await refresh_dashboard(callback.message, db_manager)
            else:
                await callback.answer("❌ Ошибка при обновлении статуса")
        
        elif action == "call" and order_id:
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order:
                await callback.answer(f"📞 Телефон: {order['customer_phone']}", show_alert=True)
            else:
                await callback.answer("❌ Заказ не найден")
        
        elif action == "refresh":
            await refresh_dashboard(callback.message, db_manager)
            await callback.answer("🔄 Обновлено")
        
        elif action == "stats":
            await show_delivery_stats(callback.message, db_manager)
            await callback.answer()
        
        elif action == "delivered" and order_id:
            success = await db_manager.update_delivery_order_status(order_id, "delivered")
            if success:
                await callback.answer("✅ Заказ доставлен")
                await refresh_dashboard(callback.message, db_manager)
            else:
                await callback.answer("❌ Ошибка при обновлении статуса")
            
    except Exception as e:
        logger.error(f"❌ Dashboard action error: {e}")
        await callback.answer("❌ Ошибка при выполнении действия")


@router.callback_query(F.data.startswith("payment_confirm_"))
async def admin_handle_payment_confirm(callback: CallbackQuery, db_manager: DatabaseManager, bot: Bot):
    """Админ подтвердил оплату -> обновляем карточку: показываем только кнопку 'В приготовление'"""
    try:
        admin_id = callback.from_user.id
        admin_ids = [int(a.strip()) for a in settings.ADMIN_IDS.split(",") if a.strip()]
        if admin_id not in admin_ids:
            await callback.answer("❌ У вас нет прав для этого действия.", show_alert=True)
            return

        # Парсим order_id
        try:
            order_id = int(callback.data.split("payment_confirm_")[-1])
        except Exception:
            await callback.answer("❌ Неверный формат callback.", show_alert=True)
            logger.warning(f"Bad callback data for payment_confirm: {callback.data}")
            return

        # 1) Подтверждаем оплату в БД (атомарно)
        ok = await db_manager.confirm_payment(order_id, confirmed_by=admin_id)
        if not ok:
            await callback.answer("ℹ️ Не удалось подтвердить оплату (возможно уже подтверждена).", show_alert=True)
            # Попробуем обновить карточку корректным текстом
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order:
                new_text, new_kb = build_order_dashboard_payload(order)  # см. функция ниже
                await safe_refresh_dashboard(bot=callback.bot, message=callback.message, new_text=new_text, new_kb=new_kb)
            return

        # 2) Логируем действие
        try:
            await db_manager.add_user_action(user_id=admin_id, action_type='payment_confirmed', action_data={'order_id': order_id})
        except Exception:
            logger.debug("add_user_action failed (non-critical)")

        # 3) Уведомляем клиента
        try:
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order and order.get('user_id'):
                await bot.send_message(order['user_id'], f"✅ Оплата по заказу #{order_id} подтверждена. Спасибо — заказ принят в работу.")
        except Exception as e:
            logger.debug(f"Failed to notify customer about confirmed payment #{order_id}: {e}")

        # 4) Ответ админу и обновление карточки: оставляем только кнопку "В приготовление"
        await callback.answer("✅ Оплата подтверждена", show_alert=False)

        # Формируем короткий текст + клавиатуру с одной кнопкой
        order = await db_manager.get_delivery_order_by_id(order_id)
        if not order:
            # если вдруг не нашли — fallback: просто удаляем кнопку
            try:
                await callback.message.edit_reply_markup(None)
            except Exception:
                pass
            return

        # Короткий текст (можно адаптировать под ваш стиль)
        new_text = (
            f"🆕 <b>Заказ #{order_id}</b>\n\n"
            f"👤 {order.get('customer_name')}\n"
            f"📞 {order.get('customer_phone')}\n"
            f"🏠 {order.get('delivery_address')}\n\n"
            f"💰 Сумма: {order.get('final_amount')}₽\n"
            f"📌 Статус: <b>{order.get('status') or 'pending'}</b>\n"
            f"💳 Оплата: <b>{order.get('payment_method')} ({order.get('payment_status')})</b>\n\n"
            f"<i>Оплата подтверждена — ожидается начало приготовления</i>"
        )

        kb = InlineKeyboardBuilder()
        kb.button(text="👨‍🍳 В приготовление", callback_data=f"dashboard_start_{order_id}")
        kb.adjust(1)

        # Обновляем админское сообщение безопасно
        await safe_refresh_dashboard(bot=callback.bot, message=callback.message, new_text=new_text, new_kb=kb)

    except Exception as e:
        logger.exception(f"Error in admin_handle_payment_confirm: {e}")
        try:
            await callback.answer("❌ Внутренняя ошибка, смотри логи.", show_alert=True)
        except Exception:
            pass


@router.callback_query(F.data.startswith("payment_reject_"))
async def admin_handle_payment_reject(callback: CallbackQuery, db_manager: DatabaseManager, bot: Bot):
    """Админ отклонил оплату (кнопка '❌ Отклонить оплату' на квитанции)."""
    try:
        admin_id = callback.from_user.id
        # Проверка прав
        admin_ids = [int(a.strip()) for a in settings.ADMIN_IDS.split(",") if a.strip()]
        if admin_id not in admin_ids:
            await callback.answer("❌ У вас нет прав для этого действия.", show_alert=True)
            return

        # Разбор order_id
        try:
            order_id = int(callback.data.split("payment_reject_")[-1])
        except Exception:
            await callback.answer("❌ Неверный формат callback.", show_alert=True)
            logger.warning(f"Bad callback data for payment_reject: {callback.data}")
            return

        # Отклоняем оплату (атомарно) — предполагается, что это ставит payment_status = 'rejected'
        ok = await db_manager.reject_payment(order_id, rejected_by=admin_id)
        if not ok:
            await callback.answer("ℹ️ Не удалось отклонить оплату (возможно уже отклонена).", show_alert=True)
            try:
                order = await db_manager.get_delivery_order_by_id(order_id)
                if order:
                    # Попробуем обновить карточку в админском сообщении
                    new_text, new_kb = build_order_dashboard_payload(order)
                    await safe_refresh_dashboard(bot=callback.bot, message=callback.message, new_text=new_text, new_kb=new_kb)
            except Exception:
                logger.debug("Failed to refresh dashboard after failed reject (non-critical)")
            return

        # Лог действия
        try:
            await db_manager.add_user_action(user_id=admin_id, action_type='payment_rejected', action_data={'order_id': order_id})
        except Exception:
            logger.debug("add_user_action failed (non-critical)")

        # Нотификация клиента
        try:
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order and order.get('user_id'):
                await bot.send_message(
                    order['user_id'],
                    f"❌ Оплата по заказу #{order_id} отклонена. Пожалуйста, пришлите корректный скрин или свяжитесь с нами."
                )
        except Exception as e:
            logger.debug(f"Failed to notify customer about rejected payment #{order_id}: {e}")

        # Попробуем изменить статус заказа на 'cancelled' если он всё ещё в 'pending'
        try:
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order:
                current_status = (order.get('status') or '').lower()
                if current_status == 'pending':
                    try:
                        await db_manager.update_delivery_order_status(order_id, "cancelled")
                        logger.info(f"Order #{order_id} status set to 'cancelled' after payment rejected")
                    except Exception as e:
                        logger.exception(f"Failed to set order #{order_id} to 'cancelled': {e}")
                else:
                    logger.info(f"Order #{order_id} not cancelled after payment reject (current status: {current_status})")
        except Exception as e:
            logger.exception(f"Failed to fetch order #{order_id} after reject: {e}")

        await callback.answer("❌ Оплата отклонена", show_alert=False)

        # Обновляем сообщение админа через безопасную функцию (показать, что оплата отклонена).
        try:
            # Подгрузим актуальный order ещё раз (чтобы показать обновлённый статус)
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order:
                new_text = (
                    f"❌ <b>ОПЛАТА ОТКЛОНЕНА</b>\n\n"
                    f"🆕 Заказ #{order_id}\n\n"
                    f"👤 {order.get('customer_name', '—')}\n"
                    f"📞 {order.get('customer_phone', '—')}\n"
                    f"🏠 {order.get('delivery_address', '—')}\n\n"
                    f"💰 Сумма: {order.get('final_amount') or order.get('total_amount', 0)}₽\n"
                    f"📌 Статус: <b>{order.get('status') or '—'}</b>\n"
                    f"💳 Оплата: <b>{order.get('payment_method') or '—'} (rejected)</b>\n\n"
                    f"<i>Админ отклонил оплату. Клиенту отправлено уведомление.</i>"
                )

                from aiogram.utils.keyboard import InlineKeyboardBuilder
                kb = InlineKeyboardBuilder()
                kb.button(text="🔁 Обновить панель", callback_data="dashboard_refresh")
                kb.adjust(1)

                await safe_refresh_dashboard(
                    bot=callback.bot,
                    message=callback.message,
                    new_text=new_text,
                    new_kb=kb
                )
            else:
                # Если по какой-то причине order не найден — просто уберём клавиатуру и покажем уведомление
                try:
                    await callback.message.edit_reply_markup(None)
                except Exception:
                    logger.debug("Could not clear reply_markup on callback.message")
        except Exception as e:
            logger.exception(f"Failed to refresh admin message after rejecting payment #{order_id}: {e}")

        # Обновляем общую панель управления (чтобы заказ исчез/обновился в списках)
        try:
            await refresh_dashboard(callback.message, db_manager)
        except Exception as e:
            logger.debug(f"Failed to refresh main dashboard after payment reject: {e}")

    except Exception as e:
        logger.exception(f"Error in admin_handle_payment_reject: {e}")
        try:
            await callback.answer("❌ Внутренняя ошибка, смотри логи.", show_alert=True)
        except Exception:
            pass



def build_order_dashboard_payload(order: dict):
    """
    Возвращает (text, inline_kb) для админского сообщения по order dict.
    Подстраивается под текущий статус и payment_status.
    """
    order_id = order.get('id')
    customer = order.get('customer_name') or '—'
    phone = order.get('customer_phone') or '—'
    addr = order.get('delivery_address') or '—'
    total = order.get('final_amount') or order.get('total_amount') or 0
    status = order.get('status') or 'pending'
    payment_method = order.get('payment_method') or order.get('order_data', {}).get('payment_method')
    payment_status = order.get('payment_status') or 'pending'

    # Формируем текст
    items_text = ""
    try:
        items = order.get('order_data', {}).get('items', [])
        if items:
            items_text = "<b>Состав заказа:</b>\n"
            for it in items:
                name = it.get('name', '—')
                qty = it.get('quantity', 1)
                price = it.get('price', 0)
                line_sum = (float(price) * int(qty)) if price is not None else 0
                items_text += f"• {name} x{qty} — {int(line_sum)}₽\n"
            items_text += "\n"
    except Exception:
        items_text = ""

    text = (
        f"🆕 <b>Заказ #{order_id}</b>\n\n"
        f"👤 {customer}\n"
        f"📞 {phone}\n"
        f"🏠 {addr}\n\n"
        f"💰 Сумма: {total}₽\n"
        f"📌 Статус: <b>{status}</b>\n"
        f"💳 Оплата: <b>{payment_method} ({payment_status})</b>\n\n"
        f"{items_text}"
    )

    # Формируем клавиатуру
    kb = InlineKeyboardBuilder()
    # Payment buttons: только если ожидается подтверждение
    if str(payment_status).lower() == 'pending' and str(payment_method) in ('card', 'bank_transfer'):
        kb.button(text="✅ Подтвердить оплату", callback_data=f"payment_confirm_{order_id}")
        kb.button(text="❌ Отклонить оплату", callback_data=f"payment_reject_{order_id}")

    # Стандартные кнопки управления заказом
    kb.button(text="👨‍🍳 В приготовление", callback_data=f"dashboard_start_{order_id}")
    kb.button(text="🚗 Передать курьеру", callback_data=f"dashboard_ship_{order_id}")
    kb.button(text="✅ Доставлен", callback_data=f"dashboard_delivered_{order_id}")
    kb.button(text="📞 Позвонить", callback_data=f"dashboard_call_{order_id}")
    kb.adjust(2)

    return text, kb



@router.callback_query(F.data.startswith("dashboard_start_"))
async def start_preparing_order(callback: CallbackQuery, db_manager: DatabaseManager):
    """Начать приготовление заказа (теперь с безопасной обработкой фото-сообщений)."""
    try:
        order_id = int(callback.data.split("_")[2])

        # Обновляем статус
        success = await db_manager.update_delivery_order_status(order_id, "preparing")
        if success:
            await callback.answer("👨‍🍳 Заказ взят в приготовление")

            # Получаем заказ
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order:
                dashboard = DeliveryDashboard(db_manager)
                updated_text = await dashboard.format_order_card(order, urgent=False)
                updated_text = f"👨‍🍳 <b>В ПРИГОТОВЛЕНИИ</b>\n\n{updated_text}"

                from aiogram.utils.keyboard import InlineKeyboardBuilder
                keyboard = InlineKeyboardBuilder()
                keyboard.button(text="🚗 В путь", callback_data=f"dashboard_ship_{order_id}")
                keyboard.button(text="📞 Позвонить", callback_data=f"dashboard_call_{order_id}")
                keyboard.adjust(2)

                # Унифицированное безопасное обновление админского сообщения
                try:
                    await safe_refresh_dashboard(
                        bot=callback.bot,
                        message=callback.message,
                        new_text=updated_text,
                        new_kb=keyboard
                    )
                except Exception as e:
                    logger.exception(f"Failed to refresh admin message on start_preparing_order: {e}")
                    # fallback: отправим отдельное сообщение админу
                    try:
                        await callback.message.answer(updated_text, parse_mode="HTML", reply_markup=keyboard.as_markup())
                    except Exception as send_e:
                        logger.debug(f"Fallback send failed: {send_e}")

            # Обновляем дашборд
            await refresh_dashboard(callback.message, db_manager)

        else:
            await callback.answer("❌ Ошибка при обновлении статуса")

    except Exception as e:
        logger.error(f"❌ Error starting order preparation: {e}")
        await callback.answer("❌ Ошибка при обновлении заказа")


@router.callback_query(F.data.startswith("dashboard_ship_"))
async def ship_order(callback: CallbackQuery, db_manager: DatabaseManager):
    """Передать заказ курьеру"""
    try:
        order_id = int(callback.data.split("_")[2])
        
        success = await db_manager.update_delivery_order_status(order_id, "on_way")
        if success:
            await callback.answer("🚗 Заказ передан курьеру")
            
            # Обновляем сообщение
            order = await db_manager.get_delivery_order_by_id(order_id)
            if order:
                dashboard = DeliveryDashboard(db_manager)
                updated_text = await dashboard.format_order_card(order, urgent=False)
                updated_text = f"🚗 <b>В ПУТИ</b>\n\n{updated_text}"
                
                from aiogram.utils.keyboard import InlineKeyboardBuilder
                keyboard = InlineKeyboardBuilder()
                keyboard.button(text="✅ Доставлен", callback_data=f"dashboard_delivered_{order_id}")
                keyboard.button(text="📞 Позвонить", callback_data=f"dashboard_call_{order_id}")
                
                # Унифицированное безопасное обновление админского сообщения
                try:
                    await safe_refresh_dashboard(
                        bot=callback.bot,
                        message=callback.message,
                        new_text=updated_text,
                        new_kb=keyboard
                    )
                except Exception as e:
                    logger.exception(f"Failed to refresh admin message on ship_order: {e}")
                    # fallback: попробуем редактировать текст как раньше
                    try:
                        await callback.message.edit_text(updated_text, parse_mode="HTML", reply_markup=keyboard.as_markup())
                    except Exception as edit_error:
                        if "message is not modified" not in str(edit_error):
                            logger.exception(f"ship_order: fallback edit_text failed: {edit_error}")
            
            await refresh_dashboard(callback.message, db_manager)
        else:
            await callback.answer("❌ Ошибка при обновлении статуса")
            
    except Exception as e:
        logger.error(f"❌ Error shipping order: {e}")
        await callback.answer("❌ Ошибка при обновлении заказа")

@router.callback_query(F.data.startswith("dashboard_delivered_"))
async def mark_order_delivered(callback: CallbackQuery, db_manager: DatabaseManager):
    """Отметить заказ как доставленный - ИСПРАВЛЕННАЯ ВЕРСИЯ"""
    try:
        order_id = int(callback.data.split("_")[2])
        
        # СНАЧАЛА получаем информацию о заказе
        order = await db_manager.get_delivery_order_by_id(order_id)
        if not order:
            await callback.answer("❌ Заказ не найден")
            return
        
        user_id = order['user_id']
        
        # Проверяем, не доставлен ли заказ уже
        if order['status'] == 'delivered':
            await callback.answer("❌ Заказ уже доставлен")
            return
        
        # ОБНОВЛЯЕМ статус заказа
        success = await db_manager.update_delivery_order_status(order_id, "delivered")
        
        if success:
            # ПРОВЕРЯЕМ и НАЧИСЛЯЕМ реферальный бонус
            user = await db_manager.get_user(user_id)
            if user and user.get('referrer_id'):
                # Проверяем, это первый ДОСТАВЛЕННЫЙ заказ пользователя
                user_orders = await db_manager.get_delivery_orders_by_user(user_id)
                delivered_orders = [o for o in user_orders if o['status'] == 'delivered']
                
                if len(delivered_orders) == 1:  # Это первый доставленный заказ
                    bonus_success = await db_manager.complete_referral_bonus(user_id, order_id)
                    if bonus_success:
                        logger.info(f"✅ Referral bonus awarded for order {order_id}, user {user_id}")
                    else:
                        logger.warning(f"⚠️ Failed to award referral bonus for order {order_id}")
            
            await callback.answer("✅ Заказ доставлен")
            await refresh_dashboard(callback.message, db_manager)
        else:
            await callback.answer("❌ Ошибка при обновлении статуса")
            
    except Exception as e:
        logger.error(f"❌ Error marking order delivered: {e}")
        await callback.answer("❌ Ошибка при обновлении заказа")

@router.callback_query(F.data.startswith("dashboard_call_"))
async def show_customer_phone(callback: CallbackQuery, db_manager: DatabaseManager):
    """Показать номер телефона клиента"""
    try:
        order_id = int(callback.data.split("_")[2])
        
        order = await db_manager.get_delivery_order_by_id(order_id)
        if order:
            await callback.answer(f"📞 Телефон: +{order['customer_phone']}", show_alert=True)
        else:
            await callback.answer("❌ Заказ не найден")
            
    except Exception as e:
        logger.error(f"❌ Error getting customer phone: {e}")
        await callback.answer("❌ Ошибка при получении данных")

=== src/handlers/admin/delivery_management.py ===
# from aiogram import Router, F, Bot
# from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, ReplyKeyboardRemove
# from aiogram.utils.keyboard import InlineKeyboardBuilder
# from fluent.runtime import FluentLocalization
# import logging
# import json

# from src.handlers.admin.delivery_dashboard import DeliveryDashboard
# from src.database.db_manager import DatabaseManager
# from src.utils.config import settings

# router = Router()
# logger = logging.getLogger(__name__)

# @router.message(F.text == "📦 Управление доставкой__")
# async def show_delivery_orders_menu(message: Message, db_manager: DatabaseManager, l10n: FluentLocalization):
#     """Меню управления заказами доставки для АДМИНОВ"""
#     if not settings.is_admin(message.from_user.id):
#         await message.answer("❌ У вас нет прав для управления заказами")
#         return
    
#     builder = InlineKeyboardBuilder()
#     builder.row(
#         InlineKeyboardButton(text="⏳ Ожидающие", callback_data="admin_pending_delivery"),
#         InlineKeyboardButton(text="👨‍🍳 В приготовлении", callback_data="admin_preparing_delivery")
#     )
#     builder.row(
#         InlineKeyboardButton(text="🚗 В пути", callback_data="admin_onway_delivery"),
#         InlineKeyboardButton(text="✅ Доставленные", callback_data="admin_delivered_delivery")
#     )
    
#     await message.answer(
#         "📦 Панель управления заказами доставки:",
#         reply_markup=builder.as_markup()
#     )

# @router.callback_query(F.data.startswith("admin_"))
# async def show_delivery_orders(callback: CallbackQuery, db_manager: DatabaseManager, l10n: FluentLocalization):
#     """Показ заказов доставки по статусу"""
#     status_map = {
#         "admin_pending_delivery": "pending",
#         "admin_preparing_delivery": "preparing", 
#         "admin_onway_delivery": "on_way",
#         "admin_delivered_delivery": "delivered"
#     }
    
#     status = status_map.get(callback.data)
#     if not status:
#         await callback.answer("❌ Неизвестный статус")
#         return
    
#     orders = await db_manager.get_delivery_orders_by_status(status)
    
#     if not orders:
#         await callback.message.edit_text(f"📭 Нет заказов со статусом: {status}")
#         return
    
#     for order in orders[:3]:  # Показываем первые 3 заказа
#         order_text = format_delivery_order_text(order)
        
#         builder = InlineKeyboardBuilder()
#         if status == "pending":
#             builder.row(
#                 InlineKeyboardButton(text="👨‍🍳 В приготовление", callback_data=f"delivery_preparing_{order['id']}"),
#             )
#         elif status == "preparing":
#             builder.row(
#                 InlineKeyboardButton(text="🚗 В путь", callback_data=f"delivery_onway_{order['id']}"),
#             )
#         elif status == "on_way":
#             builder.row(
#                 InlineKeyboardButton(text="✅ Доставлен", callback_data=f"delivery_delivered_{order['id']}"),
#             )
        
#         await callback.message.answer(order_text, reply_markup=builder.as_markup())
    
#     await callback.answer()

# @router.callback_query(F.data.startswith("delivery_"))
# async def update_delivery_order_status(callback: CallbackQuery, db_manager: DatabaseManager, l10n: FluentLocalization, bot: Bot):
#     """Обновление статуса заказа доставки"""
#     try:
#         action, order_id = callback.data.split("_")[1], int(callback.data.split("_")[2])
        
#         status_map = {
#             "preparing": "preparing",
#             "onway": "on_way", 
#             "delivered": "delivered"
#         }
        
#         new_status = status_map.get(action)
#         if not new_status:
#             await callback.answer("❌ Неизвестное действие")
#             return
        
#         success = await db_manager.update_delivery_order_status(order_id, new_status)
        
#         if success:
#             # Получаем обновленный заказ
#             orders = await db_manager.get_delivery_orders_by_status(new_status)
#             updated_order = next((o for o in orders if o['id'] == order_id), None)
            
#             if updated_order:
#                 # Уведомляем пользователя
#                 await notify_user_about_delivery_status(bot, updated_order)
                
#                 # Обновляем сообщение у админа
#                 updated_text = format_delivery_order_text(updated_order)
#                 await callback.message.edit_text(
#                     updated_text,
#                     reply_markup=None
#                 )
                
#             await callback.answer(f"✅ Статус заказа обновлен на: {new_status}")
#         else:
#             await callback.answer("❌ Ошибка при обновлении статуса")
        
#     except Exception as e:
#         logger.error(f"❌ Error updating delivery order: {e}")
#         await callback.answer("❌ Ошибка при обновлении заказа")

# def format_delivery_order_text(order: dict) -> str:
#     """Форматирование текста заказа доставки"""
#     # Преобразуем order_data из JSON строки в словарь
#     try:
#         if isinstance(order['order_data'], str):
#             order_data = json.loads(order['order_data'])
#         else:
#             order_data = order['order_data']
#     except (json.JSONDecodeError, KeyError, TypeError):
#         order_data = {}
    
#     text = f"🛵 <b>ЗАКАЗ ДОСТАВКИ #{order['id']}</b>\n\n"
    
#     text += "<b>Состав заказа:</b>\n"
#     items = order_data.get('items', [])
    
#     if not items:
#         text += "• Состав заказа не указан\n"
#     else:
#         for item in items:
#             text += f"• {item.get('name', 'Unknown')} x{item.get('quantity', 1)}\n"
    
#     text += f"\n💰 <b>Сумма: {order['total_amount']}₽</b>\n\n"
    
#     text += "<b>Данные клиента:</b>\n"
#     text += f"👤 Имя: {order['customer_name']}\n"
#     text += f"📞 Телефон: {order['customer_phone']}\n"
#     text += f"🏠 Адрес: {order['delivery_address']}\n"
#     text += f"🕐 Время: {order.get('delivery_time', 'Как можно скорее')}\n\n"
    
#     text += f"📊 <b>Статус:</b> {order['status']}\n"
#     text += f"⏰ Создан: {order['created_at'].strftime('%d.%m.%Y %H:%M')}\n"
    
#     return text

# async def notify_user_about_delivery_status(bot: Bot, order: dict):
#     """Уведомление пользователя об изменении статуса заказа"""
#     try:
#         status_messages = {
#             "preparing": "👨‍🍳 Ваш заказ начали готовить!",
#             "on_way": "🚗 Ваш заказ в пути! Курьер уже едет к вам.",
#             "delivered": "✅ Ваш заказ доставлен! Приятного аппетита!"
#         }
        
#         message = status_messages.get(order['status'])
#         if message and order['user_id']:
#             await bot.send_message(
#                 order['user_id'],
#                 f"{message}\n\nЗаказ #{order['id']}"
#             )
#     except Exception as e:
#         logger.error(f"❌ Failed to notify user about delivery status: {e}")

=== src/handlers/admin/keyboards.py ===
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from fluent.runtime import FluentLocalization

async def get_analytics_keyboard(l10n: FluentLocalization):
    """Клавиатура для аналитики"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="📊 Общая статистика")
    builder.button(text="👥 Анализ пользователей")
    builder.button(text="📈 Активность по дням")
    builder.button(text="🎯 Целевые сегменты")
    builder.button(text="📋 Бронирования")
    builder.button(text="👨‍💼 Вызовы персонала")
    builder.button(text="📋 Брони сегодня")
    builder.button(text="📦 Управление доставкой")
    builder.button(text="🏥 Health Monitor")
    builder.button(text="🔙 В главное меню")
    
    builder.adjust(2, 2, 2, 1, 1, 1)
    return builder.as_markup(resize_keyboard=True)


async def get_settings_keyboard():
    """Клавиатура для настроек (только админы)"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="👑 Управление админами")
    builder.button(text="👨‍💼 Управление официантами") 
    builder.button(text="🍽️ Управление меню")
    builder.button(text="🚫 Блокировка пользователей")
    builder.button(text="🔙 В главное меню")
    
    builder.adjust(2, 2, 1)
    return builder.as_markup(resize_keyboard=True)

async def get_admin_management_keyboard():
    """Клавиатура управления админами"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="➕ Добавить админа")
    builder.button(text="➖ Удалить админа")
    builder.button(text="📋 Список админов")
    builder.button(text="🔙 Назад в настройки")
    
    builder.adjust(2, 1, 1)
    return builder.as_markup(resize_keyboard=True)

async def get_staff_management_keyboard():
    """Клавиатура управления официантами"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="➕ Добавить официанта")
    builder.button(text="➖ Удалить официанта")
    builder.button(text="📋 Список официантов")
    builder.button(text="🔙 Назад в настройки")
    
    builder.adjust(2, 1, 1)
    return builder.as_markup(resize_keyboard=True)

async def get_menu_management_keyboard():
    """Клавиатура управления меню"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="🍕 Добавить блюдо")
    builder.button(text="🗑️ Удалить блюдо")
    builder.button(text="📋 Просмотреть меню")
    builder.button(text="🔙 Назад в настройки")
    
    builder.adjust(2, 1, 1)
    return builder.as_markup(resize_keyboard=True)

async def get_block_management_keyboard():
    """Клавиатура блокировки пользователей"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="🚫 Заблокировать")
    builder.button(text="✅ Разблокировать")
    builder.button(text="📋 Заблокированные")
    builder.button(text="🔙 Назад в настройки")
    
    builder.adjust(2, 1, 1)
    return builder.as_markup(resize_keyboard=True)

=== src/handlers/admin/message.py ===
from datetime import datetime
from aiogram import Router, F
from aiogram.types import Message, FSInputFile
from aiogram.filters import StateFilter
from fluent.runtime import FluentLocalization
from functools import wraps

from src.utils.config import settings
import src.handlers.admin.keyboards as kb
from src.utils.logger import get_logger

router = Router()
logger = get_logger(__name__)


def admin_required(func):
    """Декоратор для проверки прав доступа (ТОЛЬКО админы) через базу данных"""
    @wraps(func)
    async def wrapper(message: Message, *args, **kwargs):
        db_manager = kwargs.get('db_manager')
        if not db_manager:
            await message.answer("❌ Система проверки прав недоступна")
            return
        
        # Гарантируем существование пользователя
        await db_manager.ensure_user_exists(
            user_id=message.from_user.id,
            username=message.from_user.username,
            full_name=message.from_user.full_name
        )
        
        if not await db_manager.is_admin(message.from_user.id):
            await message.answer("❌ Эта команда доступна только администраторам.")
            return
        return await func(message, *args, **kwargs)
    return wrapper

def staff_required(func):
    """Декоратор для проверки прав доступа (админы или персонал) через базу данных"""
    @wraps(func)
    async def wrapper(message: Message, *args, **kwargs):
        db_manager = kwargs.get('db_manager')
        if not db_manager:
            await message.answer("❌ Система проверки прав недоступна")
            return
        
        # Гарантируем существование пользователя
        await db_manager.ensure_user_exists(
            user_id=message.from_user.id,
            username=message.from_user.username,
            full_name=message.from_user.full_name
        )
        
        if not await db_manager.is_staff(message.from_user.id):
            await message.answer("❌ У вас нет доступа к этой команде.")
            return
        return await func(message, *args, **kwargs)
    return wrapper

@router.message(F.text == "📊 Аналитика")
@admin_required
async def analytics_menu(message: Message, l10n: FluentLocalization, db_manager = None):
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
        
    keyboard = await kb.get_analytics_keyboard(l10n)
    await message.answer("📊 <b>Панель аналитики</b>\n\nВыберите тип отчета:", 
                        reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "📊 Общая статистика")
@admin_required
async def general_stats(message: Message, db_manager = None):
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
        
    stats = await db_manager.get_general_stats()
    
    text = f"""
📊 <b>ОБЩАЯ СТАТИСТИКА</b>

👥 <b>Пользователи:</b>
• Всего: {stats.get('total_users', 0)}
• Сегодня: {stats.get('new_users_today', 0)}
• За неделю: {stats.get('new_users_week', 0)}
• Активные (30 дн.): {stats.get('active_users', 0)}

📋 <b>Бронирования:</b>
• Всего: {stats.get('total_reservations', 0)}
• Сегодня: {stats.get('reservations_today', 0)}

👨‍💼 <b>Вызовы персонала:</b>
• Всего: {stats.get('total_staff_calls', 0)}
    """
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "👥 Анализ пользователей")
@admin_required
async def user_analytics(message: Message, db_manager = None):
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
        
    demographics = await db_manager.get_user_demographics()
    growth = await db_manager.get_user_growth(7)
    
    text = "👥 <b>ДЕМОГРАФИКА ПОЛЬЗОВАТЕЛЕЙ</b>\n\n"
    
    for row in demographics:
        sex_emoji = "👨" if row['sex'] == 'male' else "👩" if row['sex'] == 'female' else "❓"
        major_text = {
            'student': '🎓 Студент',
            'entrepreneur': '💰 Предприниматель', 
            'hire': '💼 Работает в найме',
            'frilans': '💻 Фрилансер'
        }.get(row['major'], row['major'])
        
        text += f"{sex_emoji} {major_text}: {row['count']} ({row['percentage']}%)\n"
    
    if growth:
        week_growth = growth[-1]['total_users'] - growth[0]['total_users']
        text += f"\n📈 Прирост за неделю: +{week_growth} пользователей"
    
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "🎯 Целевые сегменты")
@admin_required
async def target_segments(message: Message, db_manager = None):
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
        
    segments = await db_manager.get_target_segments()
    
    text = f"""
🎯 <b>ЦЕЛЕВЫЕ СЕГМЕНТЫ ДЛЯ РАССЫЛОК</b>

<b>Основные группы:</b>
👨 Мужчины: {segments.get('male_count', 0)}
👩 Женщины: {segments.get('female_count', 0)}

🎓 Студенты: {segments.get('students_count', 0)}
💰 Предприниматели: {segments.get('entrepreneurs_count', 0)}  
💻 Фрилансеры: {segments.get('freelancers_count', 0)}
💼 Работающие по найму: {segments.get('employees_count', 0)}

<b>Целевые комбинации:</b>
👨💰 Мужчины-предприниматели: {segments.get('male_entrepreneurs', 0)}
👩🎓 Женщины-студентки: {segments.get('female_students', 0)}
👨💻 Мужчины-фрилансеры: {segments.get('male_freelancers', 0)}
    """
    
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "📋 Бронирования")
@admin_required
async def reservation_analytics(message: Message, db_manager = None):
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
        
    stats = await db_manager.get_reservation_stats()
    trends = await db_manager.get_reservation_trends(7)
    
    avg_guests = stats.get('avg_guests') or 0
    
    day_names = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]
    
    text = f"""
📋 <b>АНАЛИТИКА БРОНИРОВАНИЙ</b>

<b>Общая статистика:</b>
• Всего бронирований: {stats.get('total_reservations', 0)}
• Среднее гостей: {avg_guests:.1f}
• Максимум гостей: {stats.get('max_guests', 0)}

<b>Статусы:</b>
✅ Подтвержденные: {stats.get('confirmed', 0)}
⏳ Ожидание: {stats.get('pending', 0)}  
❌ Отмененные: {stats.get('cancelled', 0)}
🎉 Завершенные: {stats.get('completed', 0)}

<b>Сегодня:</b> {stats.get('today_reservations', 0)} бронирований
<b>Популярный день:</b> {day_names[int(stats.get('most_popular_day', 0))] if stats.get('most_popular_day') else 'Нет данных'}
    """
    
    if trends:
        today_trend = trends[0]['reservations_count'] if trends else 0
        text += f"\n📈 <b>Тренд:</b> {today_trend} бронирований сегодня"
    
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "👨‍💼 Вызовы персонала")
@admin_required
async def staff_calls_analytics(message: Message, db_manager = None):
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
        
    stats = await db_manager.get_staff_calls_stats()
    menu_views = await db_manager.get_popular_menu_categories()
    
    avg_time = stats.get('avg_completion_time_min') or 0
    
    text = f"""
👨‍💼 <b>АНАЛИТИКА ВЫЗОВОВ ПЕРСОНАЛА</b>

<b>Статистика вызовов:</b>
• Всего вызовов: {stats.get('total_calls', 0)}
• Ожидают: {stats.get('pending_calls', 0)}
• В работе: {stats.get('accepted_calls', 0)}
• Выполнено: {stats.get('completed_calls', 0)}

<b>Эффективность:</b>
• Среднее время: {avg_time:.1f} мин.
• Активный стол: #{stats.get('most_active_table', 'Нет данных')}
• Вызовы сегодня: {stats.get('today_calls', 0)}
    """
    
    if menu_views:
        text += "\n\n<b>📊 ПОПУЛЯРНОСТЬ МЕНЮ:</b>\n"
        for i, item in enumerate(menu_views[:5], 1):
            text += f"{i}. {item['category']}: {item['total_views']} просмотров\n"
    
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "📈 Активность по дням")
@admin_required
async def daily_activity(message: Message, db_manager = None):
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
        
    activity = await db_manager.get_daily_activity(7)
    
    if not activity:
        await message.answer("📊 Нет данных об активности за последние 7 дней")
        return
    
    text = "📈 <b>АКТИВНОСТЬ ПО ДНЯМ (неделя)</b>\n\n"
    
    current_date = None
    for row in activity:
        if row['date'] != current_date:
            text += f"\n📅 <b>{row['date']}</b>\n"
            current_date = row['date']
        
        action_name = {
            'menu_view': '📋 Просмотр меню',
            'reservation': '💺 Бронирование',
            'staff_call': '👨‍💼 Вызов персонала',
            'start': '🚀 Старт бота',
            'main_menu_view': '🏠 Главное меню',
            'menu_open': '📃 Открытие меню',
            'menu_category_view': '🍽️ Просмотр категории',
            'staff_call_start': '👨‍💼 Начало вызова',
            'staff_call_confirmed': '✅ Подтверждение вызова',
            'reservation_start': '💺 Начало бронирования',
            'delivery_click': '🛵 Клик доставки',
            'invite_friend_click': '👥 Клик приглашения',
            'loyalty_program_click': '💳 Клик лояльности',
            'get_directions_click': '🗺️ Клик маршрута',
            'help_command': '❓ Команда помощи',
            'unknown_message': '❓ Неизвестное сообщение'
        }.get(row['action_type'], row['action_type'])
        
        text += f"   {action_name}: {row['actions_count']} ({row['unique_users']} пользователей)\n"
    
    await message.answer(text, parse_mode="HTML")

@router.message(F.text == "🔙 В главное меню")
async def back_to_main_menu(message: Message, l10n: FluentLocalization, db_manager = None):
    """Возврат в главное меню"""
    from src.handlers.user.message import show_main_menu
    await show_main_menu(message, l10n, db_manager)


@router.message(F.text == "📋 Брони сегодня")
@admin_required
async def today_reservations_report(message: Message, db_manager=None, bot=None):
    """Отчет по бронированиям на сегодня"""
    if not db_manager:
        await message.answer("❌ База данных недоступна")
        return
    
    try:
        processing_msg = await message.answer("📊 Формирую отчет по бронированиям...")
        
        today = datetime.now().strftime("%d.%m.%Y")
        reservations = await db_manager.get_reservations_for_date(today)
        
        if not reservations:
            await processing_msg.edit_text("📭 На сегодня бронирований нет")
            return
        
        reservations_dict = [dict(reservation) for reservation in reservations]
        
        # 🔥 ТЕКСТОВАЯ СВОДКА ДЛЯ БЫСТРОГО ПРОСМОТРА
        status_emojis = {
            'pending': '⏳',
            'confirmed': '✅', 
            'cancelled': '❌',
            'completed': '🎉'
        }
        
        status_counts = {}
        total_guests = 0
        
        for reservation in reservations_dict:
            status = reservation['status']
            status_counts[status] = status_counts.get(status, 0) + 1
            total_guests += reservation['guests_count']
        
        # Формируем текстовую сводку
        summary_text = f"📋 <b>БРОНИРОВАНИЯ НА СЕГОДНЯ ({today})</b>\n\n"
        summary_text += f"📊 <b>Общая статистика:</b>\n"
        summary_text += f"• Всего бронирований: {len(reservations)}\n"
        summary_text += f"• Общее количество гостей: {total_guests}\n\n"
        
        summary_text += f"📈 <b>По статусам:</b>\n"
        for status, count in status_counts.items():
            emoji = status_emojis.get(status, '📝')
            status_name = {
                'pending': 'Ожидание',
                'confirmed': 'Подтверждено',
                'cancelled': 'Отменено', 
                'completed': 'Завершено'
            }.get(status, status)
            summary_text += f"• {emoji} {status_name}: {count}\n"
        
        # Ближайшие бронирования (первые 5)
        upcoming = sorted(
            [r for r in reservations_dict if r['status'] in ['pending', 'confirmed']],
            key=lambda x: x['reservation_time']
        )[:5]
        
        if upcoming:
            summary_text += f"\n🕐 <b>Ближайшие бронирования:</b>\n"
            for i, reservation in enumerate(upcoming, 1):
                time_str = reservation['reservation_time'].strftime("%H:%M") if hasattr(reservation['reservation_time'], 'strftime') else str(reservation['reservation_time'])
                summary_text += f"{i}. {time_str} - {reservation['customer_name']} ({reservation['guests_count']} чел.)\n"
        
        # Отправляем текстовую сводку
        await message.answer(summary_text, parse_mode="HTML")
        
        # Генерируем и отправляем Excel файл
        from src.utils.report_generator import ReportGenerator
        report_gen = ReportGenerator()
        
        file_path = await report_gen.generate_daily_reservations_report(reservations_dict)
        
        # 🔥 ИСПРАВЛЕННЫЙ КОД ДЛЯ ОТПРАВКИ ФАЙЛА
        try:
            # Создаем InputFile с правильным именем
            input_file = FSInputFile(
                path=file_path,
                filename=f"Бронирования_{datetime.now().strftime('%d.%m.%Y')}.xlsx"
            )
            
            # Отправляем файл
            await bot.send_document(
                chat_id=message.chat.id,
                document=input_file,
                caption="📎 <b>Подробный отчет в Excel</b>\n\n"
                       "💡 <i>Используйте фильтры в файле для анализа</i>",
                parse_mode="HTML"
            )
            
            logger.info(f"✅ Sent reservations report to admin {message.from_user.id}")
            
        except Exception as file_error:
            logger.error(f"❌ Failed to send document: {file_error}")
            await message.answer("❌ Ошибка при отправке файла")
            raise file_error
        finally:
            # Всегда очищаем временный файл
            report_gen.cleanup_file(file_path)
        
        await processing_msg.delete()
        
    except Exception as e:
        logger.error(f"❌ Failed to generate reservations report: {e}", exc_info=True)
        await message.answer("❌ Ошибка при формировании отчета")


@router.message(F.text == "🏥 Health Monitor")
@admin_required
async def health_monitor(message: Message, db_manager=None, bot=None):
    """Мониторинг здоровья системы"""
    if not db_manager or not bot:
        await message.answer("❌ Система мониторинга недоступна")
        return
    
    try:
        from src.utils.health_monitor import HealthMonitor
        monitor = HealthMonitor(db_manager, bot)
        health_data = await monitor.perform_full_health_check()
        
        # Форматируем сообщение
        status_emoji = {
            "healthy": "✅",
            "degraded": "⚠️", 
            "unhealthy": "❌"
        }
        
        text = f"🏥 <b>SYSTEM HEALTH MONITOR</b>\n\n"
        text += f"📊 <b>Overall Status:</b> {status_emoji[health_data['status'].value]} {health_data['status'].value.upper()}\n"
        text += f"🕐 <b>Last Check:</b> {health_data['timestamp'].strftime('%H:%M:%S')}\n\n"
        
        # Сводка
        summary = health_data['summary']
        text += f"<b>Summary:</b>\n"
        text += f"• ✅ Healthy: {summary['healthy_checks']}/{summary['total_checks']}\n"
        text += f"• ⚠️ Degraded: {summary['degraded_checks']}\n"
        text += f"• ❌ Unhealthy: {summary['unhealthy_checks']}\n"
        text += f"• 📈 Success Rate: {summary['success_rate']:.1f}%\n"
        text += f"• ⏱️ Avg Response: {summary['avg_response_time']:.3f}s\n\n"
        
        # Детали проверок
        text += "<b>Detailed Checks:</b>\n"
        for check in health_data['checks']:
            emoji = status_emoji.get(check['status'], '❓')
            response_time = f"{check['response_time']:.3f}s" if check['response_time'] > 0 else "N/A"
            text += f"{emoji} <b>{check['component']}</b> ({response_time}): {check['message']}\n"
        
        # Добавляем кнопку для обновления
        from aiogram.utils.keyboard import InlineKeyboardBuilder
        builder = InlineKeyboardBuilder()
        builder.button(text="🔄 Refresh", callback_data="refresh_health")
        
        await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())
        
    except Exception as e:
        logger.error(f"Health monitor error: {e}")
        await message.answer(f"❌ Ошибка мониторинга: {str(e)}")

=== src/handlers/admin/reservation_management.py ===
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton
from aiogram.filters import Command, StateFilter
from aiogram.utils.keyboard import InlineKeyboardBuilder

from src.database.db_manager import DatabaseManager
from src.utils.config import settings
from fluent.runtime import FluentLocalization
from src.handlers.user.reservation import notify_user_about_reservation_status
from datetime import date, datetime, time
from src.utils.time_utils import format_restaurant_time, parse_reservation_datetime
from src.utils.logger import get_logger

router = Router()
logger = get_logger(__name__)

@router.message(Command("reservations"))
@router.message(F.text == "📋 Управление бронями")
async def show_reservations_menu(message: Message, db_manager: DatabaseManager, l10n: FluentLocalization):
    """Показ меню управления бронями"""
    # Проверяем через базу данных
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("У вас нет прав для управления бронями.")
        return
    
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="⏳ Ожидающие", callback_data="admin_pending_reservations"),
        InlineKeyboardButton(text="✅ Подтвержденные", callback_data="admin_confirmed_reservations")
    )
    builder.row(
        InlineKeyboardButton(text="📅 Сегодня", callback_data="admin_today_reservations"),
        InlineKeyboardButton(text="📊 Статистика", callback_data="admin_reservations_stats")
    )
    
    await message.answer(
        "📋 Меню управления бронями:",
        reply_markup=builder.as_markup()
    )

@router.callback_query(F.data == "admin_pending_reservations")
async def show_pending_reservations(callback: CallbackQuery, db_manager: DatabaseManager, l10n: FluentLocalization):
    """Показ ожидающих подтверждения броней"""
    reservations = await db_manager.get_reservations_by_status("pending")
    
    if not reservations:
        await callback.message.edit_text("⏳ Нет ожидающих подтверждения броней.")
        return
    
    for reservation in reservations[:5]:  # Показываем первые 5
        reservation_text = format_reservation_text(reservation, "ОЖИДАЕТ - ")
        
        builder = InlineKeyboardBuilder()
        builder.row(
            InlineKeyboardButton(text="✅ Подтвердить", callback_data=f"admin_confirm_{reservation['id']}"),
            InlineKeyboardButton(text="❌ Отклонить", callback_data=f"admin_reject_{reservation['id']}")
        )
        
        await callback.message.answer(reservation_text, reply_markup=builder.as_markup())
    
    await callback.answer()

@router.callback_query(F.data.startswith("admin_confirm_"))
async def confirm_reservation_admin(callback: CallbackQuery, db_manager: DatabaseManager, l10n: FluentLocalization, bot: Bot):
    """Подтверждение брони администратором - ОБНОВЛЕННАЯ ВЕРСИЯ"""
    try:
        reservation_id = int(callback.data.split("_")[2])
        logger.info(f"🔄 Admin confirming reservation #{reservation_id}")
        
        success = await db_manager.update_reservation_status(reservation_id, "confirmed")
        
        if success:
            # Получаем обновленные данные брони
            reservation = await db_manager.get_reservation_by_id(reservation_id)
            if reservation:
                # Уведомляем пользователя - ПЕРЕДАЕМ ОБЪЕКТЫ, А НЕ СТРОКИ
                await notify_user_about_reservation_status(
                    bot, reservation['user_id'], 
                    {
                        'id': reservation_id,
                        'date': reservation['reservation_date'],  # объект date
                        'time': reservation['reservation_time'],  # объект time
                        'guests': reservation['guests_count'],
                        'name': reservation['customer_name'],
                        'phone': reservation['customer_phone'],
                        'status': 'подтверждена'
                    },
                    l10n
                )
                
                # Обновляем сообщение у администратора с полной информацией
                updated_text = format_reservation_text(reservation, "ПОДТВЕРЖДЕНА - ")
                
                await callback.message.edit_text(
                    updated_text,
                    reply_markup=None
                )
                logger.info(f"✅ Reservation #{reservation_id} confirmed by admin")
            else:
                await callback.message.edit_text("❌ Бронь не найдена после подтверждения")
        else:
            await callback.message.edit_text("❌ Ошибка при подтверждении брони")
            logger.error(f"❌ Failed to confirm reservation #{reservation_id}")
        
    except Exception as e:
        logger.error(f"❌ Error in confirm_reservation_admin: {e}")
        await callback.message.edit_text("❌ Ошибка при подтверждении брони")
    
    await callback.answer()

@router.callback_query(F.data.startswith("admin_reject_"))
async def reject_reservation_admin(callback: CallbackQuery, db_manager: DatabaseManager, l10n: FluentLocalization, bot: Bot):
    """Отклонение брони администратором"""
    try:
        reservation_id = int(callback.data.split("_")[2])
        print(f"🔄 Admin rejecting reservation #{reservation_id}")
        
        success = await db_manager.update_reservation_status(reservation_id, "cancelled")
        
        if success:
            # Получаем обновленные данные брони
            reservation = await db_manager.get_reservation_by_id(reservation_id)
            if reservation:
                # Уведомляем пользователя
                await notify_user_about_reservation_status(
                    bot, reservation['user_id'], 
                    {
                        'id': reservation_id,
                        'date': str(reservation['reservation_date']),
                        'time': str(reservation['reservation_time']),
                        'guests': reservation['guests_count'],
                        'name': str(reservation['customer_name']),
                        'phone': str(reservation['customer_phone']),
                        'status': 'отклонена'
                    },
                    l10n
                )
                
                # Обновляем сообщение у администратора с полной информацией
                updated_text = format_reservation_text(reservation, "ОТКЛОНЕНА - ")
                
                await callback.message.edit_text(
                    updated_text,
                    reply_markup=None  # Убираем кнопки после отклонения
                )
                print(f"✅ Reservation #{reservation_id} rejected by admin")
            else:
                await callback.message.edit_text("❌ Бронь не найдена после отклонения")
        else:
            await callback.message.edit_text("❌ Ошибка при отклонении брони")
            print(f"❌ Failed to reject reservation #{reservation_id}")
        
    except Exception as e:
        await callback.message.edit_text("❌ Ошибка при отклонении брони")
        print(f"❌ Error in reject_reservation_admin: {e}")
    
    await callback.answer()


def format_reservation_text(reservation: dict, status_prefix: str = "") -> str:
    """Форматирует текст брони для отображения администраторам с правильным временем"""
    
    try:
        # Используем универсальную функцию для парсинга даты и времени
        reservation_datetime = parse_reservation_datetime(
            reservation['reservation_date'],
            reservation['reservation_time']
        )
        
        if reservation_datetime:
            formatted_time = format_restaurant_time(reservation_datetime)
            # Форматируем дату
            if isinstance(reservation['reservation_date'], (datetime, date)):
                formatted_date = reservation['reservation_date'].strftime("%d.%m.%Y")
            else:
                try:
                    if '-' in str(reservation['reservation_date']):
                        year, month, day = map(int, str(reservation['reservation_date']).split('-'))
                        formatted_date = f"{day:02d}.{month:02d}.{year}"
                    else:
                        formatted_date = str(reservation['reservation_date'])
                except:
                    formatted_date = str(reservation['reservation_date'])
        else:
            # Fallback
            formatted_time = str(reservation['reservation_time'])
            formatted_date = str(reservation['reservation_date'])
        
        # Форматируем время создания брони
        created_at = reservation['created_at']
        formatted_created_at = format_restaurant_time(created_at)
        
    except Exception as e:
        logger.error(f"❌ Error formatting reservation text: {e}")
        # Fallback значения
        formatted_date = str(reservation.get('reservation_date', 'N/A'))
        formatted_time = str(reservation.get('reservation_time', 'N/A'))
        formatted_created_at = str(reservation.get('created_at', 'N/A'))
    
    status_emoji = {
        'confirmed': '✅',
        'cancelled': '❌',
        'pending': '⏳',
        'completed': '🎉'
    }.get(reservation.get('status', 'pending'), '📋')
    
    base_text = f"""
{status_emoji} {status_prefix}Бронь #{reservation['id']}

📅 Дата: {formatted_date}
🕐 Время: {formatted_time}
👥 Гости: {reservation['guests_count']}
👤 Имя: {reservation['customer_name']}
📞 Телефон: {reservation['customer_phone']}
👤 ID пользователя: {reservation['user_id']}

📊 Статус: {reservation.get('status', 'pending')}
⏰ Создана: {formatted_created_at}
"""
    
    if reservation.get('notes'):
        base_text += f"📝 Заметки: {reservation['notes']}\n"
    
    return base_text

=== src/handlers/admin/settings.py ===
from aiogram import Router, F
from aiogram.types import Message, ReplyKeyboardRemove
from aiogram.fsm.context import FSMContext
from fluent.runtime import FluentLocalization
import logging

from src.states.settings import SettingsStates
from src.database.db_manager import DatabaseManager
from src.utils.config import settings
from src.utils.logger import get_logger
import src.handlers.admin.keyboards as kb

router = Router()
logger = get_logger(__name__)

@router.message(F.text == "⚙️ Настройки")
async def settings_menu(message: Message, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Главное меню настроек (только для админов)"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Эта команда доступна только администраторам.")
        return
    
    keyboard = await kb.get_settings_keyboard()
    await message.answer(
        "⚙️ <b>ПАНЕЛЬ УПРАВЛЕНИЯ</b>\n\n"
        "Выберите раздел для управления:",
        parse_mode="HTML",
        reply_markup=keyboard
    )

@router.message(F.text == "👑 Управление админами")
async def admin_management(message: Message, db_manager: DatabaseManager):
    """Управление администраторами"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return
    
    keyboard = await kb.get_admin_management_keyboard()
    await message.answer(
        "👑 <b>УПРАВЛЕНИЕ АДМИНИСТРАТОРАМИ</b>\n\n"
        "Добавление или удаление прав администратора:",
        parse_mode="HTML",
        reply_markup=keyboard
    )

@router.message(F.text == "👨‍💼 Управление официантами")
async def staff_management(message: Message, db_manager: DatabaseManager):
    """Управление официантами"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return
    
    keyboard = await kb.get_staff_management_keyboard()
    await message.answer(
        "👨‍💼 <b>УПРАВЛЕНИЕ ОФИЦИАНТАМИ</b>\n\n"
        "Добавление или удаление прав официанта:",
        parse_mode="HTML",
        reply_markup=keyboard
    )

@router.message(F.text == "🍽️ Управление меню")
async def menu_management(message: Message, db_manager: DatabaseManager):
    """Управление меню доставки"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return
    
    keyboard = await kb.get_menu_management_keyboard()
    await message.answer(
        "🍽️ <b>УПРАВЛЕНИЕ МЕНЮ ДОСТАВКИ</b>\n\n"
        "Добавление или удаление блюд:",
        parse_mode="HTML",
        reply_markup=keyboard
    )

@router.message(F.text == "🚫 Блокировка пользователей")
async def block_management(message: Message, db_manager: DatabaseManager):
    """Управление блокировкой пользователей"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return
    
    keyboard = await kb.get_block_management_keyboard()
    await message.answer(
        "🚫 <b>БЛОКИРОВКА ПОЛЬЗОВАТЕЛЕЙ</b>\n\n"
        "Блокировка и разблокировка пользователей:",
        parse_mode="HTML",
        reply_markup=keyboard
    )

@router.message(F.text == "📋 Список админов")
async def list_admins(message: Message, db_manager: DatabaseManager):
    """Показать список администраторов (из базы данных)"""
    try:
        admins = await db_manager.get_admins()
        
        if not admins:
            await message.answer("👑 <b>СПИСОК АДМИНИСТРАТОРОВ</b>\n\nНет администраторов в базе данных.")
            return
        
        text = "👑 <b>СПИСОК АДМИНИСТРАТОРОВ</b>\n\n"
        
        for i, admin in enumerate(admins, 1):
            username = f"@{admin['username']}" if admin.get('username') and admin['username'] != 'unknown' else "нет username"
            created_at = admin.get('created_at', 'неизвестно')
            if hasattr(created_at, 'strftime'):
                created_at = created_at.strftime("%d.%m.%Y %H:%M")
            
            text += f"{i}. {admin['full_name']} ({username})\n"
            text += f"   🆔 ID: {admin['user_id']}\n"
            text += f"   📅 Добавлен: {created_at}\n\n"
        
        await message.answer(text, parse_mode="HTML")
        
    except Exception as e:
        logger.error(f"❌ Error listing admins: {e}")
        await message.answer("❌ Ошибка при получении списка администраторов")

@router.message(F.text == "📋 Список официантов")
async def list_staff(message: Message, db_manager: DatabaseManager):
    """Показать список официантов (из базы данных)"""
    try:
        staff_list = await db_manager.get_staff()
        
        if not staff_list:
            await message.answer("👨‍💼 <b>СПИСОК ОФИЦИАНТОВ</b>\n\nНет официантов в базе данных.")
            return
        
        text = "👨‍💼 <b>СПИСОК ОФИЦИАНТОВ</b>\n\n"
        
        for i, staff_member in enumerate(staff_list, 1):
            username = f"@{staff_member['username']}" if staff_member.get('username') and staff_member['username'] != 'unknown' else "нет username"
            created_at = staff_member.get('created_at', 'неизвестно')
            if hasattr(created_at, 'strftime'):
                created_at = created_at.strftime("%d.%m.%Y %H:%M")
            
            text += f"{i}. {staff_member['full_name']} ({username})\n"
            text += f"   🆔 ID: {staff_member['user_id']}\n"
            text += f"   📅 Добавлен: {created_at}\n\n"
        
        await message.answer(text, parse_mode="HTML")
        
    except Exception as e:
        logger.error(f"❌ Error listing staff: {e}")
        await message.answer("❌ Ошибка при получении списка официантов")

@router.message(F.text == "📋 Просмотреть меню")
async def view_menu(message: Message, db_manager: DatabaseManager):
    """Показать текущее меню"""
    try:
        menu_items = await db_manager.get_delivery_menu()
        
        if not menu_items:
            await message.answer("📭 Меню пустое")
            return
        
        text = "🍽️ <b>ТЕКУЩЕЕ МЕНЮ</b>\n\n"
        
        current_category = ""
        for item in menu_items:
            if item['category'] != current_category:
                current_category = item['category']
                category_name = {
                    'breakfasts': '🍳 ЗАВТРАКИ',
                    'hots': '🍲 ГОРЯЧЕЕ', 
                    'hot_drinks': '☕️ ГОРЯЧИЕ НАПИТКИ',
                    'cold_drinks': '🍸 ХОЛОДНЫЕ НАПИТКИ',
                    'deserts': '🍰 ДЕСЕРТЫ'
                }.get(current_category, current_category)
                text += f"\n{category_name}:\n"
            
            status = "✅" if item['is_available'] else "❌"
            text += f"{status} <b>#{item['id']}</b> {item['name']} - {item['price']}₽\n"
            if item.get('description'):
                text += f"   <i>{item['description']}</i>\n"
        
        await message.answer(text, parse_mode="HTML")
        
    except Exception as e:
        logger.error(f"❌ Error viewing menu: {e}")
        await message.answer("❌ Ошибка при загрузке меню")

@router.message(F.text == "📋 Заблокированные")
async def list_blocked_users(message: Message, db_manager: DatabaseManager):
    """Показать заблокированных пользователей"""
    try:
        blocked_users = await db_manager.get_blocked_users()
        
        if not blocked_users:
            await message.answer("✅ Нет заблокированных пользователей")
            return
        
        text = "🚫 <b>ЗАБЛОКИРОВАННЫЕ ПОЛЬЗОВАТЕЛЕЙ</b>\n\n"
        
        for i, user in enumerate(blocked_users, 1):
            username = f"@{user['username']}" if user.get('username') else "нет username"
            text += f"{i}. {user['full_name']} ({username}) - ID: {user['user_id']}\n"
            
            # Форматируем дату блокировки
            blocked_at = user.get('updated_at', 'неизвестно')
            if hasattr(blocked_at, 'strftime'):
                blocked_at = blocked_at.strftime("%d.%m.%Y %H:%M")
            text += f"   📅 Заблокирован: {blocked_at}\n\n"
        
        await message.answer(text, parse_mode="HTML")
        
    except Exception as e:
        logger.error(f"❌ Error listing blocked users: {e}")
        await message.answer("❌ Ошибка при получении списка заблокированных")

@router.message(F.text == "🔙 Назад в настройки")
async def back_to_settings(message: Message, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Возврат в главное меню настроек"""
    await settings_menu(message, l10n, db_manager)

@router.message(F.text == "🔙 В главное меню")
async def back_to_main_menu_from_settings(message: Message, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Возврат в главное меню из настроек"""
    from src.handlers.user.message import show_main_menu
    await show_main_menu(message, l10n, db_manager)

=== src/handlers/admin/settings_handlers.py ===
from aiogram import Router, F
from aiogram.types import Message, ReplyKeyboardRemove, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from fluent.runtime import FluentLocalization
import logging

from src.states.settings import SettingsStates
from src.database.db_manager import DatabaseManager
from src.utils.config import settings
import src.handlers.admin.keyboards as kb

router = Router()
logger = logging.getLogger(__name__)

# ==================== INLINE KEYBOARDS ====================

def get_cancel_keyboard():
    """Создает инлайн клавиатуру с кнопкой отмены"""
    builder = InlineKeyboardBuilder()
    builder.button(text="❌ Отмена", callback_data="cancel_operation")
    return builder.as_markup()

# ==================== CANCEL HANDLER ====================

@router.callback_query(F.data == "cancel_operation")
async def cancel_operation(callback: CallbackQuery, state: FSMContext):
    """Обработка отмены операции - возврат к предыдущему меню"""
    await state.clear()
    
    # Определяем, из какого меню пришли, и возвращаемся туда
    current_state = await state.get_state()
    
    if current_state in [
        SettingsStates.waiting_for_admin_id,
        SettingsStates.waiting_for_remove_admin_id
    ]:
        # Возврат в меню управления админами
        await callback.message.edit_text(
            "👑 <b>УПРАВЛЕНИЕ АДМИНИСТРАТОРАМИ</b>\n\n"
            "Добавление или удаление прав администратора:",
            parse_mode="HTML"
        )
        await callback.message.answer(
            "Выберите действие:",
            reply_markup=await kb.get_admin_management_keyboard()
        )
    
    elif current_state in [
        SettingsStates.waiting_for_staff_id,
        SettingsStates.waiting_for_remove_staff_id
    ]:
        # Возврат в меню управления официантами
        await callback.message.edit_text(
            "👨‍💼 <b>УПРАВЛЕНИЕ ОФИЦИАНТАМИ</b>\n\n"
            "Добавление или удаление прав официанта:",
            parse_mode="HTML"
        )
        await callback.message.answer(
            "Выберите действие:",
            reply_markup=await kb.get_staff_management_keyboard()
        )
    
    elif current_state in [
        SettingsStates.waiting_for_menu_category,
        SettingsStates.waiting_for_dish_name,
        SettingsStates.waiting_for_dish_description,
        SettingsStates.waiting_for_dish_price,
        SettingsStates.waiting_for_remove_dish_id
    ]:
        # Возврат в меню управления меню
        await callback.message.edit_text(
            "🍽️ <b>УПРАВЛЕНИЕ МЕНЮ ДОСТАВКИ</b>\n\n"
            "Добавление или удаление блюд:",
            parse_mode="HTML"
        )
        await callback.message.answer(
            "Выберите действие:",
            reply_markup=await kb.get_menu_management_keyboard()
        )
    
    elif current_state in [
        SettingsStates.waiting_for_block_user_id,
        SettingsStates.waiting_for_unblock_user_id
    ]:
        # Возврат в меню блокировки пользователей
        await callback.message.edit_text(
            "🚫 <b>БЛОКИРОВКА ПОЛЬЗОВАТЕЛЕЙ</b>\n\n"
            "Блокировка и разблокировка пользователей:",
            parse_mode="HTML"
        )
        await callback.message.answer(
            "Выберите действие:",
            reply_markup=await kb.get_block_management_keyboard()
        )
    
    else:
        # Возврат в главное меню настроек
        await callback.message.edit_text(
            "⚙️ <b>ПАНЕЛЬ УПРАВЛЕНИЯ</b>\n\n"
            "Выберите раздел для управления:",
            parse_mode="HTML"
        )
        await callback.message.answer(
            "Выберите действие:",
            reply_markup=await kb.get_settings_keyboard()
        )
    
    await callback.answer("❌ Операция отменена")

# ==================== ADMIN MANAGEMENT ====================

@router.message(F.text == "➕ Добавить админа")
async def add_admin_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало добавления администратора"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    await message.answer(
        "👑 <b>Добавление администратора</b>\n\n"
        "Введите ID пользователя, которого хотите сделать администратором:\n"
        "💡 <i>ID можно получить с помощью бота @userinfobot</i>",
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_admin_id)

@router.message(SettingsStates.waiting_for_admin_id, F.text)
async def add_admin_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение добавления администратора"""
    try:
        user_id = int(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат ID. Введите целое число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    # Проверяем, не является ли пользователь уже админом
    if await db_manager.is_admin(user_id):
        await message.answer(
            "❌ Этот пользователь уже является администратором.",
            reply_markup=await kb.get_admin_management_keyboard()
        )
        await state.clear()
        return

    # Получаем информацию о пользователе (если есть в базе)
    user = await db_manager.get_user(user_id)
    username = user.get('username', 'unknown') if user else 'unknown'
    full_name = user.get('full_name', f'User_{user_id}') if user else f'User_{user_id}'

    success = await db_manager.add_admin(user_id, username, full_name)
    if success:
        await message.answer(
            f"✅ Пользователь {full_name} (ID: {user_id}) добавлен в администраторы.",
            reply_markup=await kb.get_admin_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось добавить пользователя {user_id} в администраторы.",
            reply_markup=await kb.get_admin_management_keyboard()
        )
    await state.clear()

@router.message(F.text == "➖ Удалить админа")
async def remove_admin_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало удаления администратора"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    # Показываем список админов для удобства
    admins = await db_manager.get_admins()
    if not admins:
        await message.answer("❌ Нет администраторов для удаления.")
        return

    text = "👑 <b>Текущие администраторы:</b>\n\n"
    for admin in admins:
        text += f"• ID: {admin['user_id']} - {admin['full_name']} (@{admin['username']})\n"

    text += "\nВведите ID администратора, которого хотите удалить:"
    
    await message.answer(
        text,
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_remove_admin_id)

@router.message(SettingsStates.waiting_for_remove_admin_id, F.text)
async def remove_admin_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение удаления администратора"""
    try:
        user_id = int(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат ID. Введите целое число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    # Не позволяем удалить себя
    if user_id == message.from_user.id:
        await message.answer("❌ Вы не можете удалить сами себя.")
        await state.clear()
        return

    success = await db_manager.remove_admin(user_id)
    if success:
        await message.answer(
            f"✅ Пользователь {user_id} удален из администраторов.",
            reply_markup=await kb.get_admin_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось удалить пользователя {user_id} из администраторов.",
            reply_markup=await kb.get_admin_management_keyboard()
        )
    await state.clear()

# ==================== STAFF MANAGEMENT ====================

@router.message(F.text == "➕ Добавить официанта")
async def add_staff_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало добавления официанта"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    await message.answer(
        "👨‍💼 <b>Добавление официанта</b>\n\n"
        "Введите ID пользователя, которого хотите сделать официантом:\n"
        "💡 <i>ID можно получить с помощью бота @userinfobot</i>",
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_staff_id)

@router.message(SettingsStates.waiting_for_staff_id, F.text)
async def add_staff_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение добавления официанта"""
    try:
        user_id = int(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат ID. Введите целое число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    # Проверяем, не является ли пользователь уже официантом
    if await db_manager.is_staff(user_id):
        await message.answer(
            "❌ Этот пользователь уже является официантом.",
            reply_markup=await kb.get_staff_management_keyboard()
        )
        await state.clear()
        return

    # Получаем информацию о пользователе
    user = await db_manager.get_user(user_id)
    username = user.get('username', 'unknown') if user else 'unknown'
    full_name = user.get('full_name', f'User_{user_id}') if user else f'User_{user_id}'

    success = await db_manager.add_staff(user_id, username, full_name)
    if success:
        await message.answer(
            f"✅ Пользователь {full_name} (ID: {user_id}) добавлен в официанты.",
            reply_markup=await kb.get_staff_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось добавить пользователя {user_id} в официанты.",
            reply_markup=await kb.get_staff_management_keyboard()
        )
    await state.clear()

@router.message(F.text == "➖ Удалить официанта")
async def remove_staff_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало удаления официанта"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    # Показываем список официантов для удобства
    staff = await db_manager.get_staff()
    if not staff:
        await message.answer("❌ Нет официантов для удаления.")
        return

    text = "👨‍💼 <b>Текущие официанты:</b>\n\n"
    for staff_member in staff:
        text += f"• ID: {staff_member['user_id']} - {staff_member['full_name']} (@{staff_member['username']})\n"

    text += "\nВведите ID официанта, которого хотите удалить:"
    
    await message.answer(
        text,
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_remove_staff_id)

@router.message(SettingsStates.waiting_for_remove_staff_id, F.text)
async def remove_staff_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение удаления официанта"""
    try:
        user_id = int(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат ID. Введите целое число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    success = await db_manager.remove_staff(user_id)
    if success:
        await message.answer(
            f"✅ Пользователь {user_id} удален из официантов.",
            reply_markup=await kb.get_staff_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось удалить пользователя {user_id} из официантов.",
            reply_markup=await kb.get_staff_management_keyboard()
        )
    await state.clear()

# ==================== MENU MANAGEMENT ====================

@router.message(F.text == "🍕 Добавить блюдо")
async def add_dish_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало добавления блюда"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    categories = await db_manager.get_delivery_categories()
    if not categories:
        await message.answer("❌ Нет категорий для добавления блюда.")
        return

    text = "🍽️ <b>Добавление блюда</b>\n\n"
    text += "Выберите категорию:\n"
    for category in categories:
        category_name = {
            'breakfasts': '🍳 ЗАВТРАКИ',
            'hots': '🍲 ГОРЯЧЕЕ', 
            'hot_drinks': '☕️ ГОРЯЧИЕ НАПИТКИ',
            'cold_drinks': '🍸 ХОЛОДНЫЕ НАПИТКИ',
            'deserts': '🍰 ДЕСЕРТЫ'
        }.get(category['category'], category['category'])
        text += f"• {category_name}\n"

    await message.answer(
        text,
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_menu_category)

@router.message(SettingsStates.waiting_for_menu_category, F.text)
async def add_dish_category(message: Message, state: FSMContext):
    """Обработка выбора категории для блюда"""
    category_map = {
        'breakfasts': '🍳 ЗАВТРАКИ',
        'hots': '🍲 ГОРЯЧЕЕ', 
        'hot_drinks': '☕️ ГОРЯЧИЕ НАПИТКИ',
        'cold_drinks': '🍸 ХОЛОДНЫЕ НАПИТКИ',
        'deserts': '🍰 ДЕСЕРТЫ'
    }
    
    # Ищем категорию по русскому названию или английскому
    category_input = message.text.strip()
    category = category_map.get(category_input, category_input.lower())
    
    await state.update_data(category=category)
    
    await message.answer(
        "Введите название блюда:",
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_dish_name)

@router.message(SettingsStates.waiting_for_dish_name, F.text)
async def add_dish_name(message: Message, state: FSMContext):
    """Обработка названия блюда"""
    name = message.text.strip()
    await state.update_data(name=name)
    
    await message.answer(
        "Введите описание блюда (или отправьте '-' чтобы пропустить):",
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_dish_description)

@router.message(SettingsStates.waiting_for_dish_description, F.text)
async def add_dish_description(message: Message, state: FSMContext):
    """Обработка описания блюда"""
    description = message.text.strip()
    if description == '-':
        description = None
    await state.update_data(description=description)
    
    await message.answer(
        "Введите цену блюда (в рублях, только число):",
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_dish_price)

@router.message(SettingsStates.waiting_for_dish_price, F.text)
async def add_dish_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение добавления блюда"""
    try:
        price = float(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат цены. Введите число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    data = await state.get_data()
    category = data['category']
    name = data['name']
    description = data.get('description')

    # Добавляем блюдо в базу
    success = await db_manager.add_dish_to_menu(category, name, description, price)
    if success:
        await message.answer(
            f"✅ Блюдо '{name}' успешно добавлено в категорию '{category}'.",
            reply_markup=await kb.get_menu_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось добавить блюдо '{name}'.",
            reply_markup=await kb.get_menu_management_keyboard()
        )
    await state.clear()

@router.message(F.text == "🗑️ Удалить блюдо")
async def remove_dish_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало удаления блюда"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    menu_items = await db_manager.get_delivery_menu()
    if not menu_items:
        await message.answer("❌ Меню пустое.")
        return

    text = "🍽️ <b>Текущее меню:</b>\n\n"
    for item in menu_items:
        text += f"• ID: {item['id']} - {item['name']} ({item['price']}₽)\n"

    text += "\nВведите ID блюда, которое хотите удалить:"
    
    await message.answer(
        text,
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_remove_dish_id)

@router.message(SettingsStates.waiting_for_remove_dish_id, F.text)
async def remove_dish_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение удаления блюда"""
    try:
        dish_id = int(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат ID. Введите целое число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    success = await db_manager.remove_dish_from_menu(dish_id)
    if success:
        await message.answer(
            f"✅ Блюдо с ID {dish_id} удалено.",
            reply_markup=await kb.get_menu_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось удалить блюдо с ID {dish_id}.",
            reply_markup=await kb.get_menu_management_keyboard()
        )
    await state.clear()

# ==================== BLOCK MANAGEMENT ====================

@router.message(F.text == "🚫 Заблокировать")
async def block_user_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало блокировки пользователя"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    await message.answer(
        "🚫 <b>Блокировка пользователя</b>\n\n"
        "Введите ID пользователя, которого хотите заблокировать:",
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_block_user_id)

@router.message(SettingsStates.waiting_for_block_user_id, F.text)
async def block_user_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение блокировки пользователя"""
    try:
        user_id = int(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат ID. Введите целое число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    # Не позволяем заблокировать себя
    if user_id == message.from_user.id:
        await message.answer("❌ Вы не можете заблокировать сами себя.")
        await state.clear()
        return

    success = await db_manager.block_user(user_id)
    if success:
        await message.answer(
            f"✅ Пользователь {user_id} заблокирован.",
            reply_markup=await kb.get_block_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось заблокировать пользователя {user_id}.",
            reply_markup=await kb.get_block_management_keyboard()
        )
    await state.clear()

@router.message(F.text == "✅ Разблокировать")
async def unblock_user_start(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Начало разблокировки пользователя"""
    if not await db_manager.is_admin(message.from_user.id):
        await message.answer("❌ Недостаточно прав.")
        return

    await message.answer(
        "✅ <b>Разблокировка пользователя</b>\n\n"
        "Введите ID пользователя, которого хотите разблокировать:",
        parse_mode="HTML",
        reply_markup=get_cancel_keyboard()  # Кнопка отмены в том же сообщении
    )
    await state.set_state(SettingsStates.waiting_for_unblock_user_id)

@router.message(SettingsStates.waiting_for_unblock_user_id, F.text)
async def unblock_user_finish(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Завершение разблокировки пользователя"""
    try:
        user_id = int(message.text.strip())
    except ValueError:
        await message.answer(
            "❌ Неверный формат ID. Введите целое число.",
            reply_markup=get_cancel_keyboard()
        )
        return

    success = await db_manager.unblock_user(user_id)
    if success:
        await message.answer(
            f"✅ Пользователь {user_id} разблокирован.",
            reply_markup=await kb.get_block_management_keyboard()
        )
    else:
        await message.answer(
            f"❌ Не удалось разблокировать пользователя {user_id}.",
            reply_markup=await kb.get_block_management_keyboard()
        )
    await state.clear()

=== src/handlers/admin/__init__.py ===
__all__ = ("router", )

from aiogram import Router

router = Router()

# Импортируем и включаем роутеры ПОСЛЕ определения router
from .message import router as message_router
from .callback import router as callback_router
from .reservation_management import router as reservation_router
from .delivery_dashboard import router as delivery_dashboard_router
from .broadcast import router as broadcast_router
from .settings import router as settings_router
from .settings_handlers import router as settings_handlers_router

router.include_router(message_router)
router.include_router(callback_router)
router.include_router(reservation_router)
router.include_router(delivery_dashboard_router)
router.include_router(broadcast_router)
router.include_router(settings_router)
router.include_router(settings_handlers_router)

=== src/handlers/user/bonus.py ===
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from fluent.runtime import FluentLocalization
import logging
from datetime import datetime

from src.database.db_manager import DatabaseManager
from src.utils.logger import get_logger

router = Router()
logger = get_logger(__name__)

class LoyaltyCardManager:
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
    
    async def get_loyalty_card_info(self, user_id: int) -> dict:
        """Получение всей информации для карты лояльности"""
        try:
            user = await self.db_manager.get_user(user_id)
            bonus_balance = user.get('bonus_balance', 0) if user else 0
            transactions = await self.db_manager.get_bonus_transactions(user_id, limit=5)
            
            # Статистика по транзакциям
            earned = sum(t['amount'] for t in transactions if t['amount'] > 0)
            spent = abs(sum(t['amount'] for t in transactions if t['amount'] < 0))
            
            return {
                'balance': bonus_balance,
                'transactions': transactions,
                'stats': {
                    'earned': earned,
                    'spent': spent,
                    'total_orders': len([t for t in transactions if t['type'] == 'cashback'])
                }
            }
        except Exception as e:
            logger.error(f"❌ Error getting loyalty card info: {e}")
            return {'balance': 0, 'transactions': [], 'stats': {'earned': 0, 'spent': 0, 'total_orders': 0}}

@router.message(F.text == "💳 Карта лояльности")
async def loyalty_program_handler(message: Message, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Обработчик кнопки 'Карта лояльности'"""
    try:
        user_id = message.from_user.id
        
        # 🔥 ГАРАНТИРУЕМ, ЧТО ПОЛЬЗОВАТЕЛЬ СУЩЕСТВУЕТ В БАЗЕ
        await db_manager.ensure_user_exists(
            user_id=user_id,
            username=message.from_user.username,
            full_name=message.from_user.full_name
        )
        
        loyalty_manager = LoyaltyCardManager(db_manager)
        card_info = await loyalty_manager.get_loyalty_card_info(user_id)
        
        # Форматируем сообщение
        text = await format_loyalty_card_message(card_info, db_manager)
        
        # Создаем клавиатуру
        builder = InlineKeyboardBuilder()
        
        builder.button(
            text="📊 История операций", 
            callback_data="bonus_history"
        )
        
        builder.button(
            text="ℹ️ Правила программы", 
            callback_data="bonus_rules"
        )
        
        builder.button(
            text="🔄 Обновить", 
            callback_data="refresh_bonus"
        )
        
        builder.adjust(1)
        
        await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())
        
        # Логируем действие
        await db_manager.add_user_action(
            user_id=user_id,
            action_type='loyalty_program_click'
        )
        
        logger.info(f"💳 Loyalty card shown to user {user_id}")
        
    except Exception as e:
        logger.error(f"❌ Error in loyalty_program_handler: {e}")
        await message.answer("❌ Произошла ошибка при загрузке информации о бонусной программе.")

async def format_loyalty_card_message(card_info: dict, db_manager=None) -> str:
    """Форматирование сообщения карты лояльности с улучшенным отображением рефералов"""
    balance = card_info['balance']
    stats = card_info['stats']
    transactions = card_info['transactions']
    
    text = "💳 <b>ВАША КАРТА ЛОЯЛЬНОСТИ</b>\n\n"
    
    # Баланс
    text += f"💰 <b>Текущий баланс:</b> <code>{balance}₽</code>\n\n"
    
    # Статистика
    text += "📊 <b>Ваша статистика:</b>\n"
    text += f"• Всего заработано: {stats['earned']}₽\n"
    text += f"• Использовано: {stats['spent']}₽\n"
    text += f"• Заказов с кешбэком: {stats['total_orders']}\n\n"
    
    # Последние операции
    if transactions:
        text += "🕐 <b>Последние операции:</b>\n"
        for transaction in transactions[:3]:  # Показываем 3 последние
            emoji = "⬆️" if transaction['amount'] > 0 else "⬇️"
            sign = "+" if transaction['amount'] > 0 else ""
            date = transaction['created_at'].strftime("%d.%m %H:%M")
            
            # Улучшаем описание для реферальных бонусов
            description = transaction['description']
            
            # Если это реферальный бонус и есть доступ к db_manager
            if 'реферальный бонус за пользователя' in description.lower() and db_manager:
                try:
                    # Извлекаем user_id из описания
                    import re
                    user_id_match = re.search(r'(\d+)', description)
                    if user_id_match:
                        referred_user_id = int(user_id_match.group(1))
                        # Получаем информацию о пользователе
                        referred_user = await db_manager.get_user(referred_user_id)
                        if referred_user:
                            # Используем username или full_name
                            if referred_user.get('username'):
                                user_display = f"@{referred_user['username']}"
                            else:
                                user_display = referred_user.get('full_name', 'пользователь')
                            
                            # Обновляем описание
                            description = f"Реферальный бонус за {user_display}"
                except Exception as e:
                    # В случае ошибки оставляем оригинальное описание
                    print(f"❌ Error formatting referral description: {e}")
            
            text += f"{emoji} {sign}{transaction['amount']}₽ - {description}\n"
            text += f"   <i>{date}</i>\n\n"
    else:
        text += "📝 <i>У вас пока нет операций по бонусному счету</i>\n\n"
    
    # Правила программы
    text += "🎯 <b>Правила программы:</b>\n"
    text += "• <b>5% кешбэк</b> от каждого заказа\n"
    text += "• Можно оплатить <b>до 50%</b> суммы заказа бонусами\n"
    text += "• Минимальная сумма заказа для бонусов: <b>500₽</b>\n"
    text += "• Бонусы <b>не сгорают</b>\n\n"
    
    text += "💡 <i>Бонусы автоматически начисляются после доставки заказа и применяются при следующем заказе</i>"
    
    return text

@router.callback_query(F.data == "bonus_history")
async def show_bonus_history(callback: CallbackQuery, db_manager: DatabaseManager):
    """Показать полную историю бонусов"""
    try:
        user_id = callback.from_user.id
        transactions = await db_manager.get_bonus_transactions(user_id, limit=20)

        kb = InlineKeyboardBuilder()
        kb.button(text="🔙 Назад к карте", callback_data="back_to_loyalty_card")
        
        if not transactions:
            await callback.message.edit_text(
                "📝 <b>История операций</b>\n\nУ вас пока нет операций по бонусному счету.",
                parse_mode="HTML",
                reply_markup=kb.as_markup()
            )
            return
        
        text = "📊 <b>ПОЛНАЯ ИСТОРИЯ ОПЕРАЦИЙ</b>\n\n"
        
        for transaction in transactions:
            emoji = "🟢" if transaction['amount'] > 0 else "🔴"
            sign = "+" if transaction['amount'] > 0 else ""
            date = transaction['created_at'].strftime("%d.%m.%Y %H:%M")
            
            text += f"{emoji} <b>{date}</b>\n"
            text += f"   {transaction['description']}\n"
            text += f"   Сумма: <code>{sign}{transaction['amount']}₽</code>\n\n"
        
        
        
        await callback.message.edit_text(text, parse_mode="HTML", reply_markup=kb.as_markup())
        await callback.answer()
        
    except Exception as e:
        logger.error(f"❌ Error in show_bonus_history: {e}")
        await callback.answer("❌ Ошибка при загрузке истории", show_alert=True)

@router.callback_query(F.data == "bonus_rules")
async def show_bonus_rules(callback: CallbackQuery):
    """Показать правила бонусной программы"""
    try:
        text = (
            "📋 <b>ПРАВИЛА БОНУСНОЙ ПРОГРАММЫ</b>\n\n"
            
            "💎 <b>Начисление бонусов:</b>\n"
            "• <b>5% кешбэк</b> от суммы каждого доставленного заказа\n"
            "• Бонусы начисляются после подтверждения доставки\n"
            "• Дополнительные бонусы в акциях и специальных предложениях\n\n"
            
            "💰 <b>Использование бонусов:</b>\n"
            "• Можно оплатить <b>до 50%</b> стоимости заказа\n"
            "• Минимальная сумма заказа для использования: <b>500₽</b>\n"
            "• Бонусы применяются автоматически при оформлении\n"
            "• Нельзя вывести наличными или передать другому лицу\n\n"
            
            "⏰ <b>Сроки действия:</b>\n"
            "• Бонусы не сгорают\n"
            "• Начисляются после подтверждения заказа\n"
            "• Доступны для использования сразу после начисления\n\n"
            
            "🎁 <b>Дополнительные возможности:</b>\n"
            "• Участие в специальных акциях\n"
            "• Персональные предложения\n"
            "• Приоритетная доставка для активных пользователей\n\n"
            
            "❓ <b>Вопросы и поддержка:</b>\n"
            "По всем вопросам обращайтесь к администратору"
        )
        
        builder = InlineKeyboardBuilder()
        builder.button(text="🔙 Назад к карте", callback_data="back_to_loyalty_card")
        
        await callback.message.edit_text(text, parse_mode="HTML", reply_markup=builder.as_markup())
        await callback.answer()
        
    except Exception as e:
        logger.error(f"❌ Error in show_bonus_rules: {e}")
        await callback.answer("❌ Ошибка при загрузке правил", show_alert=True)

@router.callback_query(F.data == "refresh_bonus")
async def refresh_bonus_info(callback: CallbackQuery, db_manager: DatabaseManager):
    """Обновить информацию о бонусах"""
    try:
        user_id = callback.from_user.id
        loyalty_manager = LoyaltyCardManager(db_manager)
        card_info = await loyalty_manager.get_loyalty_card_info(user_id)
        
        text = await format_loyalty_card_message(card_info)
        
        # Восстанавливаем клавиатуру
        builder = InlineKeyboardBuilder()
        builder.button(text="📊 История операций", callback_data="bonus_history")
        builder.button(text="ℹ️ Правила программы", callback_data="bonus_rules")
        builder.button(text="🔄 Обновить", callback_data="refresh_bonus")
        builder.adjust(1)
        
        try:
            await callback.message.edit_text(
                text, 
                parse_mode="HTML", 
                reply_markup=builder.as_markup()
            )
            await callback.answer("✅ Информация обновлена")
        except Exception as edit_error:
            if "message is not modified" in str(edit_error):
                # Сообщение не изменилось - это нормально
                await callback.answer("✅ Информация актуальна")
            else:
                # Другая ошибка - пробрасываем дальше
                raise edit_error
        
    except Exception as e:
        logger.error(f"❌ Error in refresh_bonus_info: {e}")
        await callback.answer("❌ Ошибка при обновлении", show_alert=True)

@router.callback_query(F.data == "back_to_loyalty_card")
async def back_to_loyalty_card(callback: CallbackQuery, db_manager: DatabaseManager):
    """Возврат к основной карте лояльности"""
    try:
        user_id = callback.from_user.id
        loyalty_manager = LoyaltyCardManager(db_manager)
        card_info = await loyalty_manager.get_loyalty_card_info(user_id)
        
        text = await format_loyalty_card_message(card_info)
        
        builder = InlineKeyboardBuilder()
        builder.button(text="📊 История операций", callback_data="bonus_history")
        builder.button(text="ℹ️ Правила программы", callback_data="bonus_rules")
        builder.button(text="🔄 Обновить", callback_data="refresh_bonus")
        builder.adjust(1)
        
        await callback.message.edit_text(text, parse_mode="HTML", reply_markup=builder.as_markup())
        await callback.answer()
        
    except Exception as e:
        logger.error(f"❌ Error in back_to_loyalty_card: {e}")
        await callback.answer("❌ Ошибка при возврате", show_alert=True)

=== src/handlers/user/callback.py ===
from typing import List
from aiogram import Router, F
from aiogram.types import CallbackQuery
from fluent.runtime import FluentLocalization
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

import src.handlers.user.keyboards as kb
from src.states.call_stuff import CallStaff
from src.states.greetings import Greeting
from src.utils.logger import get_logger

from src.utils.time_utils import format_restaurant_time

from datetime import datetime

router = Router()
logger = get_logger(__name__)

# Подтвердить вызов персонала
@router.callback_query(F.data == "confirm_staff_call")
async def confirm_staff_call(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization, db_manager=None, settings=None):
    await callback.answer()
    
    # Получаем данные из состояния
    data = await state.get_data()
    call_id = data.get('call_id')
    table_number = data.get('table_number')
    
    if not call_id:
        await callback.message.answer("❌ Ошибка: данные вызова не найдены")
        await state.clear()
        return

    # НЕ завершаем вызов, а только уведомляем официантов
    if db_manager:
        # Добавляем действие пользователя
        await db_manager.add_user_action(
            user_id=callback.from_user.id,
            action_type='staff_call_confirmed',
            action_data={'call_id': call_id, 'table_number': table_number}
        )
        
        # ✅ ОТПРАВЛЯЕМ УВЕДОМЛЕНИЕ ПЕРСОНАЛУ (но НЕ завершаем вызов)
        user = callback.from_user
        user_info = f"{user.full_name} (@{user.username})" if user.username else user.full_name
        
        # Теперь функция возвращает message_ids и время
        message_ids, call_time = await notify_staff_about_call(
            bot=callback.bot,
            table_number=table_number,
            user_info=user_info,
            call_id=call_id,
            db_manager=db_manager
        )
    
    text = l10n.format_value("staff-called-message")
    await callback.message.edit_text(text=text)
    await state.clear()

# Отменить вызов персонала
@router.callback_query(F.data == "cancel_staff_call")
async def cancel_staff_call(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization, db_manager = None):
    await callback.answer()
    
    # Получаем данные из состояния
    data = await state.get_data()
    call_id = data.get('call_id')
    table_number = data.get('table_number')
    
    # Обновляем статус вызова в БД на 'cancelled'
    if db_manager and call_id:
        # Добавляем метод для отмены вызова
        await db_manager.cancel_staff_call(call_id)
        await db_manager.add_user_action(
            user_id=callback.from_user.id,
            action_type='staff_call_cancelled',
            action_data={'call_id': call_id, 'table_number': table_number}
        )
    
    text = l10n.format_value("cancel-staff-call")
    await callback.message.edit_text(text=text)
    await state.clear()  # ✅ Очищаем состояние

# Когда пользователь выбрал что он парень или девушка
@router.callback_query(F.data.in_(["user_sex_male", "user_sex_female"]))
async def confirm_sex_and_ask_major(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization, db_manager = None):
    await callback.answer()

    # Сохраняем данные о поле пользователя
    sex = callback.data
    if sex == "user_sex_male":
        sex = "male"
        await state.update_data(sex=sex)
    else:
        sex = "female"
        await state.update_data(sex=sex)
    
    # Сохраняем пол пользователя в БД
    if db_manager:
        await db_manager.update_user_profile(
            user_id=callback.from_user.id,
            sex=sex,
            major='unknown'  # Пока неизвестно
        )
        await db_manager.add_user_action(
            user_id=callback.from_user.id,
            action_type='sex_selected',
            action_data={'sex': sex}
        )
    
    # Заменяем предыдущее сообщение, на такое же, но без кнопок, чтобы пользователь не менял свой выбор
    text_before = l10n.format_value("who-are-you")
    await callback.message.edit_text(text=text_before)

    text = l10n.format_value(
        "ask-major",
        {
            "sex": await get_ru_by_eng(sex)
        }
    )
    await callback.message.answer(text=text, reply_markup=await kb.get_user_major_kb(l10n))
    await state.set_state(Greeting.get_major)

@router.callback_query(Greeting.get_major, F.data.in_([
    "user_major_student", 
    "user_major_entrepreneur", 
    "user_major_hire", 
    "user_major_frilans"
]))
async def confirm_major_and_send_main_menu(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization, db_manager = None):
    await callback.answer()

    # Сохраняем данные о профессии пользователя
    major = callback.data
    if major == "user_major_student":
        major = "student"
        await state.update_data(major=major)
    elif major == "user_major_entrepreneur":
        major = "entrepreneur"
        await state.update_data(major=major)
    elif major == "user_major_hire":
        major = "hire"
        await state.update_data(major=major)
    elif major == "user_major_frilans":
        major = "frilans"
        await state.update_data(major=major)

    # Получаем пол из состояния
    user_data = await state.get_data()
    user_sex = user_data["sex"]
    
    # Сохраняем профиль пользователя в БД
    if db_manager:
        await db_manager.update_user_profile(
            user_id=callback.from_user.id,
            sex=user_sex,
            major=major
        )
        await db_manager.add_user_action(
            user_id=callback.from_user.id,
            action_type='major_selected',
            action_data={'major': major}
        )

    # Заменяем предыдущее сообщение, на такое же, но без кнопок, чтобы пользователь не менял свой выбор
    text_before = l10n.format_value(
        "ask-major",
        {
            "sex": await get_ru_by_eng(user_sex)
        }
    )
    await callback.message.edit_text(text=text_before)
    
    text = l10n.format_value(
        "messages-before-main-menu",
        {
            "major": await get_ru_by_eng(major)
        }
    )
    await callback.message.answer(text=text)

    # Открываем главное меню (БЕЗ установки состояния)
    welcome_text = l10n.format_value("main-menu-text")
    keyboard = await kb.get_main_menu_keyboard(l10n, user_id=callback.from_user.id)
    await callback.message.answer(welcome_text, reply_markup=keyboard)
    
    # Очищаем состояние после регистрации
    await state.clear()

async def get_ru_by_eng(sex: str) -> str:
    translations = {
        "male": "парень",
        "female": "девушка",
        "student": "студент",
        "entrepreneur": "предпрениматель",
        "hire": "Найм",
        "frilans": "фриланс",
    }

    return translations[sex].capitalize()


async def notify_staff_about_call(bot, table_number: int, user_info: str, call_id: int, db_manager=None):
    """Уведомление всего персонала (админы + стафф) о новом вызове с HTML разметкой"""
    try:
        from src.utils.config import settings
        
        message_ids = {}
        
        keyboard = InlineKeyboardBuilder()
        keyboard.button(text="✅ Принять вызов", callback_data=f"accept_call_{call_id}")
        
        current_time = format_restaurant_time()
        
        message_text = (
            f"🆘 <b>НОВЫЙ ВЫЗОВ ПЕРСОНАЛА</b>\n\n"
            f"🪑 <b>Стол:</b> #{table_number}\n"
            f"👤 <b>Клиент:</b> {user_info}\n"
            f"⏰ <b>Время:</b> {current_time}\n"
            f"🆔 <b>ID вызова:</b> {call_id}\n\n"
            f"<i>Кто первый успеет - того и клиент!</i>"
        )
        
        logger.info(f"📨 Отправка уведомлений персоналу о вызове #{call_id}")
        logger.info(f"👥 ID персонала для уведомления: {settings.all_staff_ids}")
        
        # Отправляем ВСЕМУ персоналу (админы + стафф)
        for staff_id in settings.all_staff_ids:
            try:
                logger.info(f"📤 Отправка сообщения персоналу {staff_id}")
                message = await bot.send_message(
                    chat_id=staff_id,
                    text=message_text,
                    reply_markup=keyboard.as_markup(),
                    parse_mode="HTML"
                )
                message_ids[staff_id] = message.message_id
                logger.info(f"✅ Сообщение отправлено персоналу {staff_id}, message_id: {message.message_id}")
            except Exception as e:
                logger.error(f"❌ Ошибка отправки персоналу {staff_id}: {e}")
        
        logger.info(f"💾 Сохранение message_ids в БД: {message_ids}")
        
        # Сохраняем время вызова и информацию о клиенте в БД
        if db_manager:
            success = await db_manager.update_call_message_ids(call_id, message_ids)
            if success:
                logger.info(f"✅ Message_ids сохранены в БД для вызова #{call_id}")
            else:
                logger.error(f"❌ Ошибка сохранения message_ids в БД для вызова #{call_id}")
        else:
            logger.error(f"❌ DB manager не доступен для сохранения message_ids")
        
        return message_ids, current_time
        
    except Exception as e:
        logger.error(f"❌ Критическая ошибка в notify_staff_about_call: {e}", exc_info=True)
        return {}, ""

=== src/handlers/user/delivery.py ===
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, Contact, ReplyKeyboardRemove, ContentType, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from fluent.runtime import FluentLocalization
import logging

from src.database.db_manager import DatabaseManager
from src.states.delivery import DeliveryStates
import src.handlers.user.keyboards as kb
from src.utils.rate_limiter import rate_limit
from src.handlers.user.message import show_main_menu
from src.utils.config import settings
from src.states.payment import PaymentStates

router = Router()
logger = logging.getLogger(__name__)

@router.message(F.text == "🛵 Доставка")
@rate_limit(cooldown=10, action="delivery_start")
async def start_delivery(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager=None):
    """Начало оформления доставки для пользователей"""
        
    try:
        await state.clear()
        await state.update_data(cart=[], delivery_info={})
        
        text = "🍽️ <b>ДОСТАВКА ЕДЫ</b>\n\n"
        text += "🚗 <b>Условия доставки:</b>\n"
        text += "• Минимальный заказ: 500₽\n"
        text += "• Бесплатная доставка от 1500₽\n"
        text += "• Время доставки: 30-45 минут\n"
        text += "• Работаем: 10:00 - 23:00\n\n"
        text += "Выберите категорию:"
        
        await state.set_state(DeliveryStates.choosing_category)
        await message.answer(text, parse_mode="HTML", reply_markup=await kb.get_delivery_categories_kb(l10n))
        
        if db_manager:
            await db_manager.add_user_action(
                user_id=message.from_user.id,
                action_type='delivery_started'
            )
            
    except Exception as e:
        logger.error(f"❌ Error starting delivery: {e}")
        await message.answer("❌ Ошибка при запуске доставки")
        await state.clear()

@router.message(F.text == "🛒 Корзина")
async def view_cart_handler(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Обработчик корзины из любого состояния"""
    await view_cart_from_anywhere(message, state, l10n)

@router.message(DeliveryStates.viewing_menu, F.text == "📋 Категории")
async def back_to_categories_from_menu(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Возврат к категориям из меню"""
    await state.set_state(DeliveryStates.choosing_category)
    await message.answer("Выберите категорию:", reply_markup=await kb.get_delivery_categories_kb(l10n))

@router.message(F.text == "🔙 Назад")
async def back_handler(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager=None):
    """Обработка кнопки Назад"""
    current_state = await state.get_state()
    
    if current_state == DeliveryStates.choosing_category:
        await state.clear()
        await show_main_menu(message, l10n, db_manager)
    elif current_state == DeliveryStates.viewing_menu:
        await state.set_state(DeliveryStates.choosing_category)
        await message.answer("Выберите категорию:", reply_markup=await kb.get_delivery_categories_kb(l10n))
    elif current_state == DeliveryStates.viewing_cart:
        data = await state.get_data()
        current_category_name = data.get('current_category_name', 'меню')
        await state.set_state(DeliveryStates.viewing_menu)
        await message.answer(f"Возвращаемся к {current_category_name}", reply_markup=await kb.get_delivery_menu_kb(l10n))
    else:
        await state.clear()
        await show_main_menu(message, l10n, db_manager)

@router.message(DeliveryStates.choosing_category, F.text.in_(["🍳 ЗАВТРАКИ", "🍲 ГОРЯЧЕЕ", "☕️ ГОРЯЧИЕ НАПИТКИ", "🍸 ХОЛОДНЫЕ НАПИТКИ", "🍰 ДЕСЕРТЫ"]))
async def choose_category(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager=None):
    """Обработка выбора категории"""
    try:
        category_map = {
            '🍳 ЗАВТРАКИ': 'breakfasts',
            '🍲 ГОРЯЧЕЕ': 'hots', 
            '☕️ ГОРЯЧИЕ НАПИТКИ': 'hot_drinks',
            '🍸 ХОЛОДНЫЕ НАПИТКИ': 'cold_drinks',
            '🍰 ДЕСЕРТЫ': 'deserts'
        }
        
        category_key = category_map.get(message.text)
        if not category_key:
            await message.answer("❌ Пожалуйста, выберите категорию из списка")
            return
        
        menu_items = await db_manager.get_delivery_menu(category_key) if db_manager else []
        
        if not menu_items:
            await message.answer("😔 В этой категории пока нет блюд")
            return
        
        await state.update_data(current_category=category_key, current_category_name=message.text)
        
        text = f"<b>{message.text}</b>\n\n"
        
        for item in menu_items:
            text += f"<b>{item['id']}. {item['name']}</b> - {item['price']}₽\n"
            if item.get('description'):
                text += f"<i>{item['description']}</i>\n"
            text += "\n"
        
        text += "💡 <b>Как добавить в корзину:</b>\n"
        text += "• Напишите номер товара (например: <code>1</code>)\n"
        text += "• Или <code>добавить [номер]</code> (например: <code>добавить 1</code>)\n\n"
        text += "🛒 Нажмите 'Корзина' чтобы посмотреть ваш заказ"
        
        await state.set_state(DeliveryStates.viewing_menu)
        await message.answer(text, parse_mode="HTML", reply_markup=await kb.get_delivery_menu_kb(l10n))
        
    except Exception as e:
        logger.error(f"❌ Error choosing category: {e}")
        await message.answer("❌ Ошибка при загрузке меню")

@router.message(DeliveryStates.viewing_menu, F.text)
async def add_to_cart_flexible(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager=None):
    """Гибкое добавление товара в корзину"""
    try:
        text = message.text.lower().strip()
        
        if text == "🔙 назад":
            await state.set_state(DeliveryStates.choosing_category)
            await message.answer("Выберите категорию:", reply_markup=await kb.get_delivery_categories_kb(l10n))
            return
            
        if text == "📋 категории":
            await state.set_state(DeliveryStates.choosing_category)
            await message.answer("Выберите категорию:", reply_markup=await kb.get_delivery_categories_kb(l10n))
            return
        
        item_id = None
        if text.isdigit():
            item_id = int(text)
        elif text.startswith('добавить') and len(text.split()) > 1:
            try:
                item_id = int(text.split()[1])
            except ValueError:
                pass
        
        if not item_id:
            await message.answer("❌ Укажите номер товара. Например: '1' или 'добавить 1'")
            return
        
        data = await state.get_data()
        current_category = data.get('current_category', 'pizza')
        menu_items = await db_manager.get_delivery_menu(current_category) if db_manager else []
        
        item = next((item for item in menu_items if item['id'] == item_id), None)
        
        if not item:
            await message.answer("❌ Товар с таким номером не найден. Используйте номер из списка.")
            return
        
        cart = data.get('cart', [])
        existing_item = next((cart_item for cart_item in cart if cart_item['id'] == item['id']), None)
        
        if existing_item:
            existing_item['quantity'] += 1
        else:
            cart.append({
                'id': item['id'],
                'name': item['name'],
                'price': float(item['price']),
                'quantity': 1
            })
        
        await state.update_data(cart=cart)
        total = sum(item['price'] * item['quantity'] for item in cart)
        
        await message.answer(
            f"✅ <b>{item['name']}</b> добавлен в корзину\n\n"
            f"🛒 В корзине: {len(cart)} позиций\n"
            f"💰 Общая сумма: {total}₽",
            parse_mode="HTML"
        )
        
        if db_manager:
            await db_manager.add_user_action(
                user_id=message.from_user.id,
                action_type='delivery_item_added',
                action_data={'item_id': item['id'], 'item_name': item['name']}
            )
            
    except Exception as e:
        logger.error(f"❌ Error adding to cart: {e}")
        await message.answer("❌ Ошибка при добавлении в корзину")

@router.message(DeliveryStates.viewing_cart, F.text == "✅ Оформить заказ")
async def start_checkout(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager = None):
    """Начало оформления заказа с расчетом скидок и бонусов"""
    try:
        data = await state.get_data()
        cart = data.get('cart', [])
        
        if not cart:
            await message.answer("🛒 Корзина пуста! Добавьте товары перед оформлением.")
            return
        
        # Базовая сумма товаров
        subtotal = sum(item['price'] * item['quantity'] for item in cart)
        
        # Проверяем минимальный заказ
        if subtotal < 500:
            await message.answer(
                f"❌ Минимальная сумма заказа 500₽\n"
                f"💰 Ваша сумма: {subtotal}₽\n"
                f"📦 Добавьте товаров еще на {500 - subtotal}₽"
            )
            return
        
        # Расчет доставки
        delivery_cost = 0 if subtotal >= 1500 else 200
        total_before_discount = subtotal + delivery_cost
        
        # Проверяем, есть ли у пользователя реферер и применяем скидку
        user = await db_manager.get_user(message.from_user.id)
        discount = 0
        
        logger.info(f"🔍 Start checkout: user_id={message.from_user.id}, has_referrer={user and user.get('referrer_id')}")
        
        if user and user.get('referrer_id'):
            is_first = await is_first_order(message.from_user.id, db_manager)
            logger.info(f"🔍 First order check in checkout: {is_first}")
            if is_first:
                discount = total_before_discount * 0.10
                logger.info(f"🔍 Applying 10% discount in checkout: {discount}₽")
        
        total_after_discount = total_before_discount - discount
        
        # Получаем бонусный баланс
        bonus_balance = await db_manager.get_user_bonus_balance(message.from_user.id)
        max_bonus_usage = total_after_discount * 0.6  # Можно использовать до 60% от суммы
        
        # Сохраняем расчеты для использования на следующих шагах
        await state.update_data(
            subtotal=subtotal,
            delivery_cost=delivery_cost,
            total_before_discount=total_before_discount,
            discount=discount,
            total_after_discount=total_after_discount,
            bonus_balance=bonus_balance,
            max_bonus_usage=max_bonus_usage
        )
        
        logger.info(f"🔢 Checkout totals: subtotal={subtotal}, delivery={delivery_cost}, discount={discount}, total_after_discount={total_after_discount}")
        
        text = "📝 <b>ОФОРМЛЕНИЕ ЗАКАЗА</b>\n\n"
        text += f"🛒 <b>Ваш заказ:</b>\n"
        
        for item in cart:
            text += f"• {item['name']} x{item['quantity']} - {item['price'] * item['quantity']}₽\n"
        
        text += f"\n💰 <b>Сумма товаров:</b> {subtotal}₽\n"
        
        if delivery_cost > 0:
            text += f"🚗 <b>Доставка:</b> {delivery_cost}₽\n"
        else:
            text += f"🎉 <b>Доставка:</b> бесплатно!\n"
        
        # Показываем скидку, если она уже есть
        if discount > 0:
            text += f"🎁 <b>Реферальная скидка 10%:</b> -{discount:.0f}₽\n"
        
        text += f"💰 <b>Итого к оплате:</b> {total_after_discount}₽\n\n"
        
        if bonus_balance > 0:
            text += f"💳 <b>Ваш бонусный баланс:</b> {bonus_balance}₽\n"
            text += f"💎 <b>Можно использовать:</b> до {max_bonus_usage:.0f}₽\n\n"
        
        text += "Пожалуйста, введите ваше <b>имя</b>:"
        
        await state.set_state(DeliveryStates.entering_name)
        await message.answer(text, parse_mode="HTML", reply_markup=ReplyKeyboardRemove())
        
    except Exception as e:
        logger.error(f"❌ Error starting checkout: {e}")
        await message.answer("❌ Ошибка при оформлении заказа")

@router.message(DeliveryStates.entering_name, F.text)
async def enter_customer_name(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Ввод имени клиента"""
    name = message.text.strip()
    
    if len(name) < 2:
        await message.answer("❌ Имя должно содержать минимум 2 символа. Введите еще раз:")
        return
    
    await state.update_data(customer_name=name)
    await state.set_state(DeliveryStates.entering_phone)
    
    builder = ReplyKeyboardBuilder()
    builder.button(text="📱 Отправить телефон", request_contact=True)
    builder.button(text="🔙 Назад")
    builder.adjust(1)
    
    await message.answer(
        f"👤 Имя: <b>{name}</b>\n\n"
        "Теперь введите ваш <b>номер телефона</b> или нажмите 'Отправить телефон':",
        parse_mode="HTML",
        reply_markup=builder.as_markup()
    )

@router.message(DeliveryStates.entering_phone, F.contact)
async def enter_phone_from_contact(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Обработка телефона из контакта"""
    phone = message.contact.phone_number
    await process_phone_number(message, state, phone)

@router.message(DeliveryStates.entering_phone, F.text)
async def enter_phone_manual(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Обработка ручного ввода телефона"""
    if message.text == "🔙 Назад":
        await state.set_state(DeliveryStates.viewing_cart)
        await view_cart_from_anywhere(message, state, l10n)
        return
    
    phone = message.text.strip()
    await process_phone_number(message, state, phone)

async def process_phone_number(message: Message, state: FSMContext, phone: str):
    """Общая обработка номера телефона"""
    clean_phone = ''.join(filter(str.isdigit, phone))
    
    if len(clean_phone) < 10:
        await message.answer("❌ Неверный формат телефона. Введите еще раз:")
        return
    
    await state.update_data(customer_phone=clean_phone)
    await state.set_state(DeliveryStates.entering_address)
    
    await message.answer(
        f"📞 Телефон: <b>{clean_phone}</b>\n\n"
        "Теперь введите <b>адрес доставки</b> (улица, дом, квартира):",
        parse_mode="HTML",
        reply_markup=ReplyKeyboardRemove()
    )

@router.message(DeliveryStates.entering_address, F.text)
async def enter_delivery_address_with_referral(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager = None):
    """Ввод адреса доставки с последующим предложением ввести реферальный код"""
    address = message.text.strip()
    
    if len(address) < 10:
        await message.answer("❌ Адрес должен содержать минимум 10 символов. Введите еще раз:")
        return
    
    await state.update_data(delivery_address=address)
    
    # Проверяем, есть ли у пользователя уже реферер
    user = await db_manager.get_user(message.from_user.id)
    has_referrer = user and user.get('referrer_id')
    
    if has_referrer:
        # Если реферер уже есть, переходим к использованию бонусов
        await state.set_state(DeliveryStates.using_bonus)
        await process_bonus_step(message, state, db_manager)
    else:
        # Предлагаем ввести реферальный код
        await state.set_state(DeliveryStates.entering_referral)
        
        text = (
            f"🏠 <b>Адрес доставки сохранен:</b> {address}\n\n"
            f"🎁 <b>Есть реферальный код?</b>\n\n"
            f"Если друг дал вам реферальный код, введите его сейчас и получите <b>10% скидку</b> на первый заказ!\n\n"
            f"💡 <b>Что дает реферальный код:</b>\n"
            f"• <b>10% скидка</b> на ваш первый заказ\n"
            f"• Ваш друг получит <b>200₽</b> на счет\n"
            f"• Вы оба становитесь участниками бонусной программы\n\n"
            f"📝 <b>Введите реферальный код:</b>\n"
            f"(или отправьте <code>0</code> чтобы пропустить)"
        )
        
        builder = ReplyKeyboardBuilder()
        builder.button(text="🚫 Пропустить")
        builder.adjust(1)
        
        await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())



@router.message(DeliveryStates.entering_referral, F.text)
async def enter_referral_code_during_checkout(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager = None):
    """Обработка ввода реферального кода во время оформления заказа"""
    try:
        user_input = message.text.strip()
        
        # Если пользователь хочет пропустить
        if user_input in ["0", "🚫 Пропустить", "пропустить", "skip"]:
            await state.set_state(DeliveryStates.using_bonus)
            await process_bonus_step(message, state, db_manager)
            return
        
        # Обрабатываем реферальный код
        referral_code = user_input.upper()
        
        logger.info(f"🔍 Processing referral code: {referral_code} for user {message.from_user.id}")
        
        # Проверяем, не пытается ли пользователь использовать свой код
        user_referral_code = await db_manager.get_referral_code(message.from_user.id)
        if referral_code == user_referral_code:
            await message.answer("❌ Нельзя использовать свой собственный реферальный код! Введите другой код или отправьте '0' чтобы пропустить:")
            return
        
        # Ищем пользователя по реферальному коду
        referrer = await db_manager.get_user_by_referral_code(referral_code)
        if not referrer:
            await message.answer("❌ Реферальный код не найден. Проверьте правильность кода или отправьте '0' чтобы пропустить:")
            return
        
        # Проверяем, что реферер не является самим пользователем
        if referrer['user_id'] == message.from_user.id:
            await message.answer("❌ Нельзя использовать свой собственный код! Введите другой код или отправьте '0' чтобы пропустить:")
            return
        
        # Устанавливаем реферера
        success = await db_manager.set_user_referrer(message.from_user.id, referrer['user_id'])
        if success:
            # Создаем запись о реферальном бонусе
            await db_manager.add_referral_bonus(
                referrer_id=referrer['user_id'],
                referred_id=message.from_user.id,
                bonus_amount=200.00
            )
            
            # ПЕРЕСЧИТЫВАЕМ ЗАКАЗ С УЧЕТОМ СКИДКИ
            logger.info(f"🔍 Before recalculation for user {message.from_user.id}")
            new_totals = await recalculate_order_after_referral(state, db_manager, message.from_user.id)
            logger.info(f"🔍 After recalculation: discount={new_totals['discount']}, total_after_discount={new_totals['total_after_discount']}")
            
            # Уведомляем реферера
            try:
                referrer_notification = (
                    f"🎉 <b>У вас новый реферал!</b>\n\n"
                    f"👤 Пользователь: {message.from_user.full_name}\n"
                    f"💎 Использовал ваш код: {referral_code}\n\n"
                    f"💰 Вы получите <b>200₽</b> после его первого заказа!\n"
                    f"💳 Следите за статусом в разделе '💳 Карта лояльности'"
                )
                await message.bot.send_message(
                    chat_id=referrer['user_id'],
                    text=referrer_notification,
                    parse_mode="HTML"
                )
            except Exception as notify_error:
                logger.error(f"❌ Failed to notify referrer: {notify_error}")
            
            # Сообщение пользователю с НОВОЙ СУММОЙ
            success_text = (
                f"✅ <b>Реферальный код активирован!</b>\n\n"
                f"🎁 Вы получили <b>10% скидку</b> на этот заказ!\n"
            )
            
            if new_totals['discount'] > 0:
                success_text += f"💰 Скидка составила: <b>-{new_totals['discount']:.0f}₽</b>\n\n"
                success_text += f"💡 Скидка применена к вашему заказу.\n"
                success_text += f"💰 <b>Новая сумма к оплате:</b> {new_totals['total_after_discount']}₽\n\n"
            else:
                success_text += f"⚠️ <b>Но скидка не была применена!</b>\n"
                success_text += f"💰 Сумма к оплате: {new_totals['total_after_discount']}₽\n\n"
                success_text += f"ℹ️ Скидка применяется только к первому заказу.\n\n"
            
            success_text += f"🎉 Ваш реферер получит 200₽ после завершения заказа."
            
            await message.answer(success_text, parse_mode="HTML", reply_markup=ReplyKeyboardRemove())
            
            # Логируем действие
            await db_manager.add_user_action(
                user_id=message.from_user.id,
                action_type='referral_code_activated_during_checkout',
                action_data={'referrer_id': referrer['user_id'], 'referral_code': referral_code, 'discount': new_totals['discount']}
            )
            
            logger.info(f"✅ Referral code activated during checkout: user {message.from_user.id} -> referrer {referrer['user_id']}, discount: {new_totals['discount']}₽")
            
        else:
            await message.answer("❌ Ошибка при активации реферального кода. Введите код еще раз или отправьте '0' чтобы пропустить:")
            return
        
        # Переходим к использованию бонусов
        await state.set_state(DeliveryStates.using_bonus)
        await process_bonus_step(message, state, db_manager)
            
    except Exception as e:
        logger.error(f"❌ Error processing referral code during checkout: {e}")
        await message.answer("❌ Произошла ошибка при обработке реферального кода. Введите код еще раз или отправьте '0' чтобы пропустить:")



async def process_bonus_step(message: Message, state: FSMContext, db_manager: DatabaseManager):
    """Обработка шага использования бонусов после ввода реферального кода"""
    try:
        # Получаем данные для бонусов
        data = await state.get_data()
        total_after_discount = data.get('total_after_discount', 0)
        bonus_balance = await db_manager.get_user_bonus_balance(message.from_user.id)
        max_bonus_usage = total_after_discount * 0.6  # Можно использовать до 60% от суммы
        
        text = f"💰 <b>Сумма к оплате:</b> {total_after_discount}₽\n"
        
        if bonus_balance > 0:
            text += (
                f"\n💳 <b>Ваш бонусный баланс:</b> {bonus_balance}₽\n"
                f"💎 <b>Можно использовать:</b> до {max_bonus_usage:.0f}₽\n\n"
                f"💡 <b>Как использовать бонусы?</b>\n"
                f"• Введите сумму бонусов для списания\n"
                f"• Можно использовать до 60% от суммы заказа\n"
                f"• Или введите 0, если не хотите использовать бонусы\n\n"
                f"<b>Сколько бонусов использовать?</b>"
            )
        else:
            text += "\n💡 У вас пока нет бонусов для использования.\nВведите 0 чтобы продолжить:"
        
        await message.answer(text, parse_mode="HTML")
        
    except Exception as e:
        logger.error(f"❌ Error in process_bonus_step: {e}")
        await message.answer("❌ Ошибка при переходе к использованию бонусов.")


@router.message(DeliveryStates.using_bonus, F.text)
async def enter_bonus_amount(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager = None):
    """Обработка ввода суммы бонусов для списания"""
    try:
        bonus_used = float(message.text.strip())
        
        if bonus_used < 0:
            await message.answer("❌ Сумма бонусов не может быть отрицательной. Введите еще раз:")
            return
        
        data = await state.get_data()
        total_after_discount = data.get('total_after_discount', 0)
        bonus_balance = data.get('bonus_balance', 0)
        max_bonus_usage = data.get('max_bonus_usage', 0)
        discount = data.get('discount', 0)
        
        available_bonus = min(bonus_balance, max_bonus_usage)
        
        if bonus_used > available_bonus:
            await message.answer(
                f"❌ Недостаточно бонусов. Доступно: {available_bonus:.0f}₽\n"
                f"Введите сумму еще раз:"
            )
            return
        
        if bonus_used > max_bonus_usage:
            await message.answer(
                f"❌ Можно использовать не более {max_bonus_usage:.0f}₽ (60% от суммы заказа)\n"
                f"Введите сумму еще раз:"
            )
            return
        
        # Сохраняем сумму использованных бонусов
        await state.update_data(bonus_used=bonus_used)
        await state.set_state(DeliveryStates.confirming_order)
        
        # Считаем итоговую сумму
        final_amount = total_after_discount - bonus_used
        
        # Формируем текст подтверждения
        text = "✅ <b>ПОДТВЕРЖДЕНИЕ ЗАКАЗА</b>\n\n"
        text += f"👤 <b>Имя:</b> {data['customer_name']}\n"
        text += f"📞 <b>Телефон:</b> {data['customer_phone']}\n"
        text += f"🏠 <b>Адрес:</b> {data['delivery_address']}\n\n"
        
        text += "<b>Состав заказа:</b>\n"
        cart = data.get('cart', [])
        for item in cart:
            text += f"• {item['name']} x{item['quantity']} - {item['price'] * item['quantity']}₽\n"
        
        text += f"\n💰 <b>Сумма товаров:</b> {data.get('subtotal', 0)}₽\n"
        
        delivery_cost = data.get('delivery_cost', 0)
        if delivery_cost > 0:
            text += f"🚗 <b>Доставка:</b> {delivery_cost}₽\n"
        else:
            text += f"🎉 <b>Доставка:</b> бесплатно!\n"
        
        # Показываем скидку, если она была применена
        if discount > 0:
            text += f"🎁 <b>Реферальная скидка 10%:</b> -{discount:.0f}₽\n"
        
        if bonus_used > 0:
            text += f"💎 <b>Использовано бонусов:</b> -{bonus_used:.0f}₽\n"
        
        text += f"\n💵 <b>Итого к оплате:</b> {final_amount}₽\n\n"

        text += "Подтвердить заказ?"
        
        builder = ReplyKeyboardBuilder()
        builder.button(text="✅ Подтвердить заказ")
        builder.button(text="❌ Отменить")
        builder.adjust(1)
        
        await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())
        
    except ValueError:
        await message.answer("❌ Пожалуйста, введите корректную сумму:")

# @router.message(DeliveryStates.confirming_order, F.text == "✅ Подтвердить заказ")
# async def confirm_delivery_order(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager = None):
#     """Финальное подтверждение и создание заказа с бонусной системой"""
#     try:
#         data = await state.get_data()
#         cart = data.get('cart', [])
#         customer_name = data.get('customer_name')
#         customer_phone = data.get('customer_phone')
#         delivery_address = data.get('delivery_address')
#         bonus_used = data.get('bonus_used', 0)
#         discount = data.get('discount', 0)
#         subtotal = data.get('subtotal', 0)
#         delivery_cost = data.get('delivery_cost', 0)
#         total_before_discount = data.get('total_before_discount', 0)
        
#         if not cart:
#             await message.answer("❌ Ошибка: корзина пуста")
#             await state.clear()
#             return
        
#         # Финальный расчет
#         total_after_discount = total_before_discount - discount
#         final_amount = total_after_discount - bonus_used
        
#         # Формируем данные заказа
#         order_data = {
#             'items': cart,
#             'subtotal': subtotal,
#             'delivery_cost': delivery_cost,
#             'total': total_before_discount,  # Сумма до применения скидок и бонусов
#             'discount': discount,
#             'bonus_used': bonus_used,
#             'final_amount': final_amount,
#             'delivery_address': delivery_address,
#             'customer_name': customer_name,
#             'customer_phone': customer_phone,
#             'delivery_time': 'Как можно скорее'
#         }
        
#         # Создаем заказ в БД
#         order_id = await db_manager.create_delivery_order(
#             user_id=message.from_user.id,
#             order_data=order_data,
#             discount_amount=discount,
#             bonus_used=bonus_used,
#             final_amount=final_amount
#         )
        
#         if order_id:
#             # 🔥 НАЧИСЛЯЕМ КЕШБЭК 5% ОТ ЗАКАЗА
#             cashback_amount = await db_manager.calculate_order_cashback(final_amount)
#             if cashback_amount > 0:
#                 await db_manager.add_bonus_transaction(
#                     user_id=message.from_user.id,
#                     amount=cashback_amount,
#                     transaction_type='cashback',
#                     description=f'Кешбэк 5% от заказа #{order_id}',
#                     order_id=order_id
#                 )
#                 logger.info(f"💎 Начислен кешбэк {cashback_amount}₽ пользователю {message.from_user.id} за заказ #{order_id}")
            
#             # 🔥 ЗАПИСЫВАЕМ СПИСАНИЕ БОНУСОВ (если использовались)
#             if bonus_used > 0:
#                 await db_manager.add_bonus_transaction(
#                     user_id=message.from_user.id,
#                     amount=-bonus_used,
#                     transaction_type='purchase',
#                     description=f'Оплата заказа #{order_id} бонусами',
#                     order_id=order_id
#                 )
#                 logger.info(f"💳 Списано бонусов {bonus_used}₽ с пользователя {message.from_user.id} за заказ #{order_id}")
            
#             # 🔥 ОБРАБАТЫВАЕМ РЕФЕРАЛЬНЫЕ БОНУСЫ
#             user = await db_manager.get_user(message.from_user.id)
#             if user and user.get('referrer_id') and discount > 0:
#                 success = await db_manager.complete_referral_bonus(message.from_user.id, order_id)
#                 if success:
#                     try:
#                         # Получаем актуальный баланс реферера после начисления
#                         referrer = await db_manager.get_user(user['referrer_id'])
#                         bonus_notification = (
#                             f"💰 <b>Вам начислен реферальный бонус!</b>\n\n"
#                             f"👤 {customer_name} сделал(а) первый заказ.\n"
#                             f"🎁 Вам начислено: <b>200₽</b> на счет\n"
#                             f"💳 Теперь ваш баланс: {referrer.get('bonus_balance', 0)}₽"
#                         )
#                         await message.bot.send_message(
#                             chat_id=user['referrer_id'],
#                             text=bonus_notification,
#                             parse_mode="HTML"
#                         )
#                         logger.info(f"👥 Начислен реферальный бонус 200₽ пользователю {user['referrer_id']}")
#                     except Exception as notify_error:
#                         logger.error(f"❌ Failed to notify referrer about bonus: {notify_error}")
            
#             # 🔥 ФОРМИРУЕМ СООБЩЕНИЕ ОБ УСПЕХЕ
#             success_text = (
#                 f"🎉 <b>ЗАКАЗ ПРИНЯТ!</b>\n\n"
#                 f"🛵 <b>Номер заказа:</b> #{order_id}\n"
#             )
            
#             # Показываем скидку, если она была применена
#             if discount > 0:
#                 success_text += f"🎁 <b>Реферальная скидка 10%:</b> -{discount:.0f}₽\n"
            
#             # Показываем использованные бонусы
#             if bonus_used > 0:
#                 success_text += f"💎 <b>Использовано бонусов:</b> -{bonus_used:.0f}₽\n"
            
#             # 🔥 ПОКАЗЫВАЕМ НАЧИСЛЕННЫЙ КЕШБЭК
#             if cashback_amount > 0:
#                 success_text += f"💳 <b>Начислено кешбэка:</b> +{cashback_amount:.0f}₽\n"
            
#             success_text += (
#                 f"💰 <b>Итоговая сумма:</b> {final_amount}₽\n"
#                 f"⏰ <b>Время доставки:</b> 30-45 минут\n"
#                 f"🏠 <b>Адрес:</b> {delivery_address}\n\n"
#                 f"📞 Мы свяжемся с вами для подтверждения: {customer_phone}\n\n"
#                 f"<i>Спасибо за заказ! Приятного аппетита! 🍕</i>"
#             )
            
#             await message.answer(success_text, parse_mode="HTML", reply_markup=ReplyKeyboardRemove())
            
#             # 🔥 УВЕДОМЛЕНИЕ АДМИНИСТРАТОРОВ
#             await notify_admins_about_delivery_order(
#                 bot=message.bot,
#                 order_id=order_id,
#                 order_data=order_data,
#                 customer_name=customer_name,
#                 customer_phone=customer_phone,
#                 total=final_amount,
#                 delivery_address=delivery_address,
#                 db_manager=db_manager
#             )
            
#             # 🔥 ЛОГИРУЕМ ДЕЙСТВИЕ
#             await db_manager.add_user_action(
#                 user_id=message.from_user.id,
#                 action_type='delivery_order_created',
#                 action_data={
#                     'order_id': order_id, 
#                     'total': final_amount, 
#                     'discount': discount, 
#                     'bonus_used': bonus_used,
#                     'cashback_earned': cashback_amount
#                 }
#             )
            
#             logger.info(f"✅ Delivery order #{order_id} created by user {message.from_user.id}, cashback: {cashback_amount}₽")
            
#             # 🔥 ОЧИЩАЕМ СОСТОЯНИЕ И ПОКАЗЫВАЕМ ГЛАВНОЕ МЕНЮ
#             await state.clear()
#             await show_main_menu(message, l10n, db_manager)
            
#         else:
#             await message.answer("❌ Ошибка при создании заказа. Попробуйте позже.")
#             await state.clear()
            
#     except Exception as e:
#         logger.error(f"❌ Error confirming delivery order: {e}", exc_info=True)
#         await message.answer("❌ Произошла ошибка при оформлении заказа")
#         await state.clear()


@router.message(DeliveryStates.confirming_order, F.text == "✅ Подтвердить заказ")
async def confirm_delivery_ask_payment(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Перед созданием заказа спрашиваем способ оплаты"""
    try:
        data = await state.get_data()
        # если вдруг корзина пуста — стандартная защита
        if not data.get('cart'):
            await message.answer("❌ Корзина пуста. Вернитесь в меню и добавьте блюда.")
            await state.clear()
            return

        text = "Выберите способ оплаты:\n\n"
        text += "💵 — Оплата курьеру при получении\n"
        text += "💳 — Оплата по реквизитам (перевод / карта). После перевода отправьте скрин.\n\n"
        text += "Выберите вариант:"

        builder = ReplyKeyboardBuilder()
        builder.button(text="💵 Курьеру наличными")
        builder.button(text="💳 По реквизитам (отправить скрин)")
        builder.button(text="❌ Отменить")
        builder.adjust(1)

        await state.set_state(PaymentStates.choosing_payment_method)
        await message.answer(text, reply_markup=builder.as_markup(), parse_mode="HTML")

    except Exception as e:
        logger.error(f"❌ Error asking payment method: {e}", exc_info=True)
        await message.answer("❌ Произошла ошибка. Попробуйте ещё раз.")
        await state.clear()


@router.message(PaymentStates.choosing_payment_method, F.text == "💵 Курьеру наличными")
async def payment_cash_on_delivery(
    message: Message,
    state: FSMContext,
    l10n: FluentLocalization,
    db_manager: DatabaseManager = None
):
    """Пользователь выбрал оплату курьеру — создаём заказ, фиксируем способ оплаты и уведомляем админов."""
    try:
        data = await state.get_data()
        # Защита: если корзина вдруг пустая
        if not data.get('cart'):
            await message.answer("❌ Корзина пуста. Пожалуйста, добавьте блюда в корзину.")
            await state.clear()
            return

        # --- Формируем order_data и явно указываем способ оплаты ---
        order_data = {
            'items': data.get('cart', []),
            'subtotal': data.get('subtotal', 0),
            'delivery_cost': data.get('delivery_cost', 0),
            'total': data.get('total_before_discount', 0),
            'discount': data.get('discount', 0),
            'bonus_used': data.get('bonus_used', 0),
            'final_amount': (data.get('total_after_discount', 0) - data.get('bonus_used', 0)),
            'delivery_address': data.get('delivery_address'),
            'customer_name': data.get('customer_name'),
            'customer_phone': data.get('customer_phone'),
            'delivery_time': data.get('delivery_time', 'Как можно скорее'),
            # ВАЖНО: сохраняем способ оплаты прямо в order_data
            'payment_method': 'cash'
        }

        # Создаём заказ в БД
        order_id = await db_manager.create_delivery_order(
            user_id=message.from_user.id,
            order_data=order_data,
            discount_amount=data.get('discount', 0),
            bonus_used=data.get('bonus_used', 0),
            final_amount=order_data['final_amount']
        )

        if not order_id:
            await message.answer("❌ Ошибка при создании заказа. Попробуйте позже.", reply_markup=ReplyKeyboardRemove())
            await state.clear()
            return

        # Явно задать способ оплаты в отдельном поле таблицы (на случай, если create_delivery_order не делает этого)
        await db_manager.update_order_payment_method(order_id, 'cash')

        # (Опционально) сразу перевести в preparing — оставляю логику как ранее
        await db_manager.update_delivery_order_status(order_id, 'preparing')

        # --- Ответ пользователю: указываем способ оплаты ---
        success_text = (
            f"✅ <b>Заказ оформлен #{order_id}</b>\n\n"
            f"💰 Итоговая сумма: {order_data['final_amount']}₽\n"
            f"⏰ Время доставки: 30-45 минут\n"
            f"🏠 Адрес: {order_data['delivery_address']}\n\n"
            f"📞 Мы свяжемся с вами: {order_data['customer_phone']}\n\n"
            f"<i>Оплата: наличными курьеру при получении</i>"
        )
        await message.answer(success_text, parse_mode="HTML", reply_markup=ReplyKeyboardRemove())

        # --- Оповещение админам: передаём полный order_data с payment_method и формируем понятный текст ---
        admin_text = (
            f"🆕 <b>Новый заказ #{order_id}</b>\n\n"
            f"Клиент: {order_data['customer_name']} (ID {message.from_user.id})\n"
            f"Телефон: {order_data['customer_phone']}\n"
            f"Адрес: {order_data['delivery_address']}\n\n"
            f"Сумма: {order_data['final_amount']}₽\n"
            f"Оплата: <b>Наличными курьеру</b>\n\n"
            f"Нажмите кнопку, чтобы принять заказ в работу."
        )

        # Используем функцию уведомления админов — передаём order_id и order_data
        # Если notify_admins_about_delivery_order умеет принимать текст — можно подставить admin_text.
        await notify_admins_about_delivery_order(
            bot=message.bot,
            order_id=order_id,
            order_data=order_data,
            customer_name=order_data['customer_name'],
            customer_phone=order_data['customer_phone'],
            total=order_data['final_amount'],
            delivery_address=order_data['delivery_address'],
            db_manager=db_manager,
            custom_admin_message=admin_text  # <-- если функция поддерживает кастомный текст
        )

        # Лог действия и очистка состояния
        await db_manager.add_user_action(
            user_id=message.from_user.id,
            action_type='delivery_order_created',
            action_data={'order_id': order_id, 'payment_method': 'cash'}
        )

        await state.clear()
        await show_main_menu(message, l10n, db_manager)

    except Exception as e:
        logger.error(f"❌ Error creating cash-on-delivery order: {e}", exc_info=True)
        await message.answer("❌ Произошла ошибка при оформлении заказа.")
        await state.clear()


@router.message(PaymentStates.choosing_payment_method, F.text == "💳 По реквизитам (отправить скрин)")
async def payment_by_requisites(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager = None):
    """Пользователь выбрал оплату по реквизитам — создаём заказ и просим прислать скрин"""
    try:
        data = await state.get_data()

        order_data = {
            'items': data.get('cart', []),
            'subtotal': data.get('subtotal', 0),
            'delivery_cost': data.get('delivery_cost', 0),
            'total': data.get('total_before_discount', 0),
            'discount': data.get('discount', 0),
            'bonus_used': data.get('bonus_used', 0),
            'final_amount': data.get('total_after_discount', 0) - data.get('bonus_used', 0),
            'delivery_address': data.get('delivery_address'),
            'customer_name': data.get('customer_name'),
            'customer_phone': data.get('customer_phone'),
            'delivery_time': data.get('delivery_time', 'Как можно скорее')
        }

        order_id = await db_manager.create_delivery_order(
            user_id=message.from_user.id,
            order_data=order_data,
            discount_amount=data.get('discount', 0),
            bonus_used=data.get('bonus_used', 0),
            final_amount=order_data['final_amount']
        )

        if not order_id:
            await message.answer("❌ Ошибка при создании заказа. Попробуйте позже.", reply_markup=ReplyKeyboardRemove())
            await state.clear()
            return

        # Сохраняем способ оплаты 'card' (или 'bank_transfer')
        await db_manager.update_order_payment_method(order_id, 'card')
        # Оставляем payment_status = 'pending' (админ подтвердит после проверки скрина)

        # Сохраняем order_id в состоянии, чтобы потом принять скрин
        await state.update_data(pending_payment_order_id=order_id)

        # Отправляем инструкцию пользователю (вставьте свои реквизиты вручную или подставьте из settings)
        payment_info = (
            "Пожалуйста, оплатите переводом на следующие реквизиты и пришлите скрин оплаты:\n\n"
            "• Номер карты: <b>0000 0000 0000 0000</b>\n"
            "• Получатель: ООО «Ресторан»\n"
            "• Назначение: оплата заказа #{order_id}\n\n"
            "После перевода отправьте сюда скрин (фото) или нажмите «Я оплатил» и прикрепите скрин."
        ).format(order_id=order_id)

        await message.answer(payment_info, parse_mode="HTML")
        await message.answer("📎 Отправьте скрин оплаты (фото) прямо в чат.", reply_markup=ReplyKeyboardBuilder().button(text="❌ Отменить").adjust(1).as_markup())

        await state.set_state(PaymentStates.waiting_payment_confirmation)

    except Exception as e:
        logger.error(f"❌ Error creating card-transfer order: {e}", exc_info=True)
        await message.answer("❌ Произошла ошибка при оформлении заказа.")
        await state.clear()

@router.message(PaymentStates.waiting_payment_confirmation, F.content_type.in_({ContentType.PHOTO, ContentType.TEXT}))
async def handle_payment_proof(message: Message, state: FSMContext, db_manager: DatabaseManager = None):
    """Приём скрина оплаты (фото) или текстового уведомления"""
    try:
        data = await state.get_data()
        order_id = data.get('pending_payment_order_id')
        if not order_id:
            await message.answer("❌ Не найден связанный заказ. Пожалуйста, начните оформление заново.")
            await state.clear()
            return

        # Если пользователь прислал фото
        if message.photo:
            # Берём самый большой вариант
            file_id = message.photo[-1].file_id
            note = "screenshot"

            # Сохраняем receipt в БД (нужно реализовать save_payment_receipt в db_manager)
            await db_manager.save_payment_receipt(order_id=order_id, user_id=message.from_user.id, file_id=file_id, note=note)

            # Пересылаем скрин админам с кнопками подтверждения
            builder = InlineKeyboardBuilder()
            builder.button(text="✅ Подтвердить оплату", callback_data=f"payment_confirm_{order_id}")
            builder.button(text="❌ Отклонить оплату", callback_data=f"payment_reject_{order_id}")
            builder.adjust(1)

            # Попробуем получить заказ и собрать детальную карточку
            try:
                order = await db_manager.get_delivery_order_by_id(order_id)
            except Exception as e:
                logger.debug(f"Failed to fetch order #{order_id}: {e}")
                order = None

            # helpers (локальные, чтобы не требовать внешних импортов)
            import json
            import html
            import re

            def _strip_html_tags(text: str) -> str:
                return re.sub(r'<[^>]+>', '', text) if text else ""

            def _make_short(text: str, plain_limit: int = 1000, cut_chars: int = 900) -> str:
                """Если plain-текст длинный — обрезаем безопасно по символам (до cut_chars)."""
                if len(_strip_html_tags(text)) <= plain_limit:
                    return text
                # обрежем по видимым символам (без HTML-тегов) — простая обрезка
                plain = _strip_html_tags(text)
                cut = plain[:cut_chars].rstrip()
                return html.escape(cut) + "..."

            # Стартуем с базового блока (в любом случае)
            basic_info = (
                f"💳 <b>ПРИНЯТ СКРИН ОПЛАТЫ</b>\n\n"
                f"Номер заказа: #{order_id}\n"
                f"Клиент: {html.escape(message.from_user.full_name or '')} (ID {message.from_user.id})\n"
            )

            # Если есть заказ — дополняем деталями
            if order:
                # Разбираем order_data (поддержка JSON-строки или dict)
                order_data = order.get('order_data') or {}
                if isinstance(order_data, str):
                    try:
                        order_data = json.loads(order_data)
                    except Exception:
                        order_data = {}

                items = []
                if isinstance(order_data, dict):
                    items = order_data.get('items', []) or []

                # Формируем строки по позициям: "Пицца x2 — 500₽"
                item_lines = []
                for it in items:
                    try:
                        name = html.escape(str(it.get('name', '—')))
                        qty = int(it.get('quantity', 1)) if it.get('quantity') is not None else 1
                        price = float(it.get('price', 0) or 0)
                        line_total = int(price * qty)
                        item_lines.append(f"• {name} x{qty} — {line_total}₽")
                    except Exception:
                        # при проблемах с конкретной позицией просто пропускаем
                        continue

                items_text = "\n".join(item_lines) if item_lines else "• (состав не указан)"

                # Суммы и скидки
                total_amount = int(order.get('total_amount') or 0)
                final_amount = int(order.get('final_amount') or total_amount)
                discount_amount = int(order.get('discount_amount') or 0)
                bonus_used = int(order.get('bonus_used') or 0)

                # Оплата
                payment_method = order.get('payment_method') or (order_data.get('payment_method') if isinstance(order_data, dict) else None) or "—"
                payment_status = order.get('payment_status') or "—"

                # Контакт / адрес
                customer_phone = html.escape(str(order.get('customer_phone') or "—"))
                delivery_addr = html.escape(str(order.get('delivery_address') or "—"))

                details = (
                    f"Телефон: {customer_phone}\n"
                    f"Адрес: {delivery_addr}\n\n"
                    f"<b>Состав заказа:</b>\n{items_text}\n\n"
                    f"💰 Сумма: {total_amount}₽\n"
                    f"💸 Итог (после скидок/бонусов): {final_amount}₽\n"
                    f"🔖 Скидки: -{discount_amount}₽  💎 Бонусы: -{bonus_used}₽\n"
                    f"💳 Оплата: {html.escape(str(payment_method))} ({html.escape(str(payment_status))})\n\n"
                )

                admin_text = basic_info + details + "Нажмите кнопку для подтверждения/отклонения."
            else:
                # нет заказа в БД — оставляем базовую информацию
                admin_text = basic_info + "\nНажмите кнопку для подтверждения/отклонения."

            # Дополнительно: подготовим короткую подпись (caption) на случай, если admin_text слишком длинный.
            # Это полезно, если вы отправляете фото с caption (ограничение ~1024 символа в caption по-простому).
            short_caption = None
            try:
                # Попробуем сделать компактную карточку из первых двух позиций
                if order:
                    short_items = item_lines[:2] if item_lines else []
                    short_items_preview = "\n".join(short_items) if short_items else "• состав не указан"
                    short_caption = (
                        f"💳 <b>ПРИНЯТ СКРИН ОПЛАТЫ</b>\n\n"
                        f"#{order_id} — {html.escape(order.get('customer_name') or message.from_user.full_name)}\n"
                        f"{short_items_preview}\n\n"
                        f"Итог: {final_amount}₽ | {html.escape(str(payment_method))} ({html.escape(str(payment_status))})"
                    )
                    # если и это слишком длинно — обрежем
                    if len(_strip_html_tags(short_caption)) > 1000:
                        short_caption = _make_short(short_caption, plain_limit=1000, cut_chars=700)
            except Exception:
                short_caption = None

            # Отправляем админам: используйте ту же функцию notify_admins_about_delivery_order
            # или напишите отдельный цикл получения админов и отправки сообщения
            from src.utils.config import settings
            admin_ids = [int(a.strip()) for a in settings.ADMIN_IDS.split(",")]
            for admin_id in admin_ids:
                try:
                    # отправляем фото + подпись + кнопки
                    await message.bot.send_photo(chat_id=admin_id, photo=file_id, caption=admin_text, parse_mode="HTML", reply_markup=builder.as_markup())
                except Exception as e:
                    logger.error(f"❌ Failed to forward payment proof to admin {admin_id}: {e}")

            await message.answer("✅ Скрин отправлен администратору. Ожидайте подтверждения.", reply_markup=ReplyKeyboardRemove())
            await state.clear()
            return

        # Если пришёл текст (например «Я оплатил») — напомним прислать скрин
        if message.text:
            await message.answer("Пожалуйста, пришлите скрин оплаты (фото). Без скрина админ не сможет подтвердить оплату.")
            return

    except Exception as e:
        logger.error(f"❌ Error handling payment proof: {e}", exc_info=True)
        await message.answer("❌ Произошла ошибка при отправке скрина.")
        await state.clear()





@router.message(DeliveryStates.confirming_order, F.text == "❌ Отменить")
async def cancel_delivery_order(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Отмена заказа доставки"""
    await message.answer(
        "❌ Заказ отменен",
        reply_markup=ReplyKeyboardRemove()
    )
    await state.clear()
    await show_main_menu(message, l10n)

@router.message(DeliveryStates.viewing_cart, F.text == "🗑️ Очистить корзину")
async def clear_cart(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Очистка корзины"""
    await state.update_data(cart=[])
    await message.answer("🗑️ Корзина очищена")
    await state.set_state(DeliveryStates.choosing_category)
    await message.answer("Выберите категорию:", reply_markup=await kb.get_delivery_categories_kb(l10n))

@router.message(DeliveryStates.viewing_cart, F.text == "📋 Продолжить покупки")
async def continue_shopping(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Продолжить покупки"""
    await state.set_state(DeliveryStates.choosing_category)
    await message.answer("Выберите категорию:", reply_markup=await kb.get_delivery_categories_kb(l10n))

# Вспомогательные функции
async def view_cart_from_anywhere(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Показать корзину из любого состояния"""
    data = await state.get_data()
    cart = data.get('cart', [])
    
    if not cart:
        await message.answer("🛒 Корзина пуста")
        return
    
    text = "🛒 <b>ВАША КОРЗИНА</b>\n\n"
    subtotal = 0
    
    for item in cart:
        item_total = item['price'] * item['quantity']
        subtotal += item_total
        text += f"• {item['name']} x{item['quantity']} - {item_total}₽\n"
    
    delivery_cost = 0 if subtotal >= 1500 else 200
    total = subtotal + delivery_cost
    
    text += f"\n💰 <b>Сумма товаров:</b> {subtotal}₽\n"
    
    if delivery_cost > 0:
        text += f"🚗 <b>Доставка:</b> {delivery_cost}₽\n"
    else:
        text += f"🎉 <b>Доставка:</b> бесплатно!\n"
    
    text += f"💵 <b>Итого:</b> {total}₽\n"
    
    if subtotal < 500:
        text += f"\n⚠️ <i>Минимальная сумма заказа 500₽</i>\n"
    
    builder = ReplyKeyboardBuilder()
    if cart:
        builder.button(text="✅ Оформить заказ")
        builder.button(text="📋 Продолжить покупки")
        builder.button(text="🗑️ Очистить корзину")
    builder.button(text="🔙 Главное меню")
    builder.adjust(1)
    
    await state.set_state(DeliveryStates.viewing_cart)
    await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())



async def notify_admins_about_delivery_order(
    bot,
    order_id: int,
    order_data: dict,
    customer_name: str,
    customer_phone: str,
    total: float,
    delivery_address: str,
    db_manager=None,
    custom_admin_message: str = None
):
    """Уведомление администраторов о новом заказе доставки.

    Улучшения:
    - Явно указывает способ оплаты (payment_method) и статус оплаты, если они есть.
    - При оплате по реквизитам (card/bank_transfer) добавляет кнопки подтверждения/отклонения оплаты.
    - При наличии db_manager пытается получить и переслать админам последние присланные квитанции (payment_receipts).
    - Принимает optional custom_admin_message — если передан, используется вместо стандартного.
    """
    try:
        from src.utils.config import settings
        from aiogram.utils.keyboard import InlineKeyboardBuilder

        # Получаем список админов (защита от пустой строки)
        admin_ids = [int(a.strip()) for a in settings.ADMIN_IDS.split(",") if a.strip()]
        if not admin_ids:
            logger.warning("notify_admins_about_delivery_order: ADMIN_IDS пустой")
            return

        # Состав заказа
        items_text = ""
        items = order_data.get('items', []) if order_data else []
        if items:
            items_text = "<b>Состав заказа:</b>\n"
            for item in items:
                name = item.get('name', '—')
                qty = item.get('quantity', 1)
                price = item.get('price', 0)
                try:
                    line_sum = int(price) * int(qty)
                except Exception:
                    # на случай строк/None
                    try:
                        line_sum = float(price) * float(qty)
                    except Exception:
                        line_sum = 0
                items_text += f"• {name} x{qty} — {line_sum}₽\n"
            items_text += "\n"

        # Определяем способ оплаты и статус
        payment_method_raw = order_data.get('payment_method') if order_data else None
        payment_status = order_data.get('payment_status') if order_data else None

        # Читаем удобочитаемую подпись способа оплаты
        pm_map = {
            'cash': "Наличными курьеру",
            'card': "Оплата по реквизитам / картой (ожидает подтверждения)",
            'bank_transfer': "Перевод на реквизиты / банк (ожидает подтверждения)",
            None: "Не указан"
        }
        payment_method_readable = pm_map.get(payment_method_raw, str(payment_method_raw))

        # Если передан кастомный текст — используем его, иначе формируем стандартный
        if custom_admin_message:
            message_text = custom_admin_message
        else:
            message_text = (
                "🛵 <b>НОВЫЙ ЗАКАЗ ДОСТАВКИ</b>\n\n"
                f"🆔 <b>Номер заказа:</b> #{order_id}\n"
                f"👤 <b>Клиент:</b> {customer_name}\n"
                f"📞 <b>Телефон:</b> {customer_phone}\n"
                f"🏠 <b>Адрес:</b> {delivery_address}\n"
                f"💰 <b>Сумма:</b> {total}₽\n"
                f"💳 <b>Оплата:</b> {payment_method_readable}\n"
            )
            if payment_status:
                message_text += f"📌 <b>Статус оплаты:</b> {payment_status}\n"
            message_text += "\n" + items_text
            message_text += f"⏰ <b>Время доставки:</b> {order_data.get('delivery_time', 'Как можно скорее')}\n\n"
            message_text += "<i>Заказ ожидает обработки</i>"

        # Формируем клавиатуру: базовые кнопки + доп. кнопки для card/bank_transfer (подтвердить/отклонить оплату)
        kb = InlineKeyboardBuilder()

        # Кнопки для подтверждения/отклонения оплаты (только если оплата по реквизитам/карте)
        if payment_method_raw in ('card', 'bank_transfer'):
            kb.button(text="✅ Подтвердить оплату", callback_data=f"payment_confirm_{order_id}")
            kb.button(text="❌ Отклонить оплату", callback_data=f"payment_reject_{order_id}")

        # Стандартные кнопки управления заказом
        kb.button(text="👨‍🍳 В приготовление", callback_data=f"dashboard_start_{order_id}")
        kb.button(text="📞 Позвонить", callback_data=f"dashboard_call_{order_id}")

        # Размещение кнопок: если есть кнопки подтверждения — оставляем по 2 в строке, иначе 1 в строке
        if payment_method_raw in ('card', 'bank_transfer'):
            kb.adjust(2)  # две колонки рекомендованы, т.к. много кнопок
        else:
            kb.adjust(1)

        # Перед отправкой основного сообщения: если есть квитанции в БД — пересылаем их первым (опционально)
        receipts = []
        if db_manager:
            try:
                # Ожидаем, что db_manager реализует get_payment_receipts_for_order(order_id)
                receipts = await db_manager.get_payment_receipts_for_order(order_id)
            except Exception as e:
                logger.debug(f"notify_admins_about_delivery_order: не удалось получить receipts для {order_id}: {e}")

        # Отправляем admin notification (и при наличии — пересылаем фото-квитанции)
        for admin_id in admin_ids:
            try:
                # Если есть receipts — отдельно отправляем их (последние сверху). Отправка фото перед основным текстом
                if receipts:
                    for r in receipts:
                        try:
                            file_id = r.get('file_id') or r.get('fileid') or r.get('file')
                            if file_id:
                                caption = f"💳 Квитанция для заказа #{order_id}\n"
                                # Добавим короткие метаданные, если есть
                                if r.get('note'):
                                    caption += f"{r.get('note')}\n"
                                await bot.send_photo(chat_id=admin_id, photo=file_id, caption=caption)
                        except Exception as e:
                            logger.debug(f"notify_admins_about_delivery_order: failed to send receipt to admin {admin_id}: {e}")

                # Основное сообщение с кнопками
                await bot.send_message(
                    chat_id=admin_id,
                    text=message_text,
                    reply_markup=kb.as_markup(),
                    parse_mode="HTML"
                )

                logger.info(f"✅ Delivery order notification sent to admin {admin_id}")

                if db_manager:
                    # Логируем уведомление админа в user_action (если есть метод add_user_action)
                    try:
                        await db_manager.add_user_action(
                            user_id=admin_id,
                            action_type='delivery_order_notified',
                            action_data={'order_id': order_id, 'payment_method': payment_method_raw}
                        )
                    except Exception:
                        logger.debug("notify_admins_about_delivery_order: add_user_action failed (non-critical)")

            except Exception as e:
                logger.error(f"❌ Failed to notify admin {admin_id} about delivery order {order_id}: {e}")

    except Exception as e:
        logger.error(f"❌ Error in notify_admins_about_delivery_order: {e}", exc_info=True)

async def is_first_order(user_id: int, db_manager) -> bool:
    """Проверяет, является ли заказ первым для пользователя"""
    try:
        # Проверяем заказы доставки
        delivery_orders = await db_manager.get_delivery_orders_by_user(user_id)
        
        # Логируем для отладки
        logger.info(f"🔍 Checking first order for user {user_id}: found {len(delivery_orders)} delivery orders")
        
        # Считаем только завершенные/доставленные заказы как "реальные" заказы
        completed_orders = [order for order in delivery_orders if order['status'] in ['delivered', 'completed']]
        
        logger.info(f"🔍 Completed orders for user {user_id}: {len(completed_orders)}")
        
        return len(completed_orders) == 0  # Если завершенных заказов нет, то это первый
        
    except Exception as e:
        logger.error(f"❌ Error checking first order: {e}")
        return True  # В случае ошибки считаем что это первый заказ
    


async def recalculate_order_after_referral(state: FSMContext, db_manager: DatabaseManager, user_id: int):
    """Пересчет заказа после активации реферального кода"""
    try:
        data = await state.get_data()
        cart = data.get('cart', [])
        
        if not cart:
            return data
            
        # Базовая сумма товаров
        subtotal = sum(item['price'] * item['quantity'] for item in cart)
        
        # Расчет доставки
        delivery_cost = 0 if subtotal >= 1500 else 200
        total_before_discount = subtotal + delivery_cost
        
        # Проверяем, есть ли у пользователя реферер и является ли это первый заказ
        user = await db_manager.get_user(user_id)
        discount = 0
        
        logger.info(f"🔍 Recalculating order: user_id={user_id}, has_referrer={user and user.get('referrer_id')}")
        
        if user and user.get('referrer_id'):
            is_first = await is_first_order(user_id, db_manager)
            logger.info(f"🔍 First order check: {is_first}")
            if is_first:
                discount = total_before_discount * 0.10
                logger.info(f"🔍 Applying 10% discount: {discount}₽")
        
        total_after_discount = total_before_discount - discount
        
        # Получаем бонусный баланс
        bonus_balance = await db_manager.get_user_bonus_balance(user_id)
        max_bonus_usage = total_after_discount * 0.6  # Можно использовать до 60% от суммы
        
        # Обновляем данные в состоянии
        await state.update_data(
            subtotal=subtotal,
            delivery_cost=delivery_cost,
            total_before_discount=total_before_discount,
            discount=discount,
            total_after_discount=total_after_discount,
            bonus_balance=bonus_balance,
            max_bonus_usage=max_bonus_usage
        )
        
        logger.info(f"🔢 Recalculated order: subtotal={subtotal}, delivery={delivery_cost}, discount={discount}, total_after_discount={total_after_discount}")
        
        return {
            'subtotal': subtotal,
            'delivery_cost': delivery_cost,
            'total_before_discount': total_before_discount,
            'discount': discount,
            'total_after_discount': total_after_discount,
            'bonus_balance': bonus_balance,
            'max_bonus_usage': max_bonus_usage
        }
        
    except Exception as e:
        logger.error(f"❌ Error recalculating order after referral: {e}")
        return data

=== src/handlers/user/directions.py ===
from aiogram import Router, F
from aiogram.types import Message, InlineKeyboardButton, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from fluent.runtime import FluentLocalization
import logging

from src.utils.config import settings
from src.utils.logger import get_logger

router = Router()
logger = get_logger(__name__)

@router.message(F.text == "🗺️ Проложить маршрут")
async def get_directions_handler(message: Message, l10n: FluentLocalization, db_manager=None):
    """Расширенный обработчик для построения маршрута"""
    try:
        user = message.from_user
        
        # Логируем действие
        if db_manager:
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='get_directions_click'
            )

        restaurant_address = settings.RESTAURANT_ADDRESS
        latitude = settings.RESTAURANT_LATITUDE
        longitude = settings.RESTAURANT_LONGITUDE

        # Создаем расширенную клавиатуру
        builder = InlineKeyboardBuilder()
        
        # Ссылки для различных карт
        google_maps_url = f"https://www.google.com/maps/dir/?api=1&destination={latitude},{longitude}"
        yandex_maps_url = f"https://yandex.ru/maps/?rtext=~{latitude},{longitude}"
        apple_maps_url = f"http://maps.apple.com/?daddr={latitude},{longitude}"
        waze_url = f"https://waze.com/ul?ll={latitude},{longitude}&navigate=yes"
        
        builder.button(text="🗺️ Google Maps", url=google_maps_url)
        builder.button(text="📍 Яндекс.Карты", url=yandex_maps_url)
        builder.button(text="🍎 Apple Maps", url=apple_maps_url)
        builder.button(text="🚗 Waze", url=waze_url)
        # builder.button(text="📞 Позвонить", callback_data="call_restaurant")
        builder.adjust(1)

        # Подробное сообщение с информацией о ресторане
        text = (
            f"🍽️ <b>Добро пожаловать в наш ресторан!</b>\n\n"
            f"📍 <b>Адрес:</b>\n{restaurant_address}\n\n"
            f"🕒 <b>Часы работы:</b>\n"
            f"• Пн-Чт: 10:00 - 23:00\n"
            f"• Пт-Сб: 10:00 - 00:00\n"
            f"• Вс: 10:00 - 22:00\n\n"
            f"📞 <b>Телефон:</b> +7 (495) 123-45-67\n\n"
            f"🚗 <b>Парковка:</b> Есть бесплатная парковка\n"
            f"♿ <b>Доступность:</b> Полностью доступно для маломобильных гостей\n\n"
            f"<b>Выберите способ построения маршрута:</b>"
        )

        await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())
        
        # Дополнительно отправляем локацию
        try:
            await message.answer_location(
                latitude=latitude,
                longitude=longitude,
                title="Наш ресторан",
                address=restaurant_address
            )
        except Exception as location_error:
            logger.warning(f"⚠️ Could not send location: {location_error}")

        logger.info(f"🗺️ Detailed directions requested by user {user.id}")

    except Exception as e:
        logger.error(f"❌ Error in get_directions_handler: {e}")
        await message.answer(
            "❌ Не удалось загрузить информацию о местоположении. "
            "Пожалуйста, свяжитесь с нами по телефону."
        )

@router.callback_query(F.data == "call_restaurant")
async def call_restaurant_handler(callback: CallbackQuery, l10n: FluentLocalization):
    """Обработчик кнопки 'Позвонить'"""
    try:
        await callback.answer("📞 Телефон ресторана: +7 (495) 123-45-67", show_alert=True)
    except Exception as e:
        logger.error(f"❌ Error in call_restaurant_handler: {e}")
        await callback.answer("❌ Ошибка при получении номера телефона")

=== src/handlers/user/keyboards.py ===
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from fluent.runtime import FluentLocalization
from src.utils.config import settings
import logging

logger = logging.getLogger(__name__)

async def get_sex_of_user_kb(l10n: FluentLocalization):
    """Инлайн клавиатура для получения пола пользователя"""
    kb = InlineKeyboardBuilder()
    kb.button(
        text=l10n.format_value("male-user"),
        callback_data="user_sex_male"
    )
    kb.button(
        text=l10n.format_value("female-user"),
        callback_data="user_sex_female"
    )
    kb.adjust(1)

    return kb.as_markup()

async def get_user_major_kb(l10n: FluentLocalization):
    """Инлайн клавиатура для получения профессии пользователя"""
    kb = InlineKeyboardBuilder()
    kb.button(
        text=l10n.format_value("major-student"),
        callback_data="user_major_student"
    )
    kb.button(
        text=l10n.format_value("major-entrepreneur"),
        callback_data="user_major_entrepreneur"
    )
    kb.button(
        text=l10n.format_value("major-hire"),
        callback_data="user_major_hire"
    )
    kb.button(
        text=l10n.format_value("major-frilans"),
        callback_data="user_major_frilans"
    )
    kb.adjust(1)

    return kb.as_markup()

async def get_main_menu_keyboard(l10n: FluentLocalization, user_id: int, db_manager=None):
    """Главное меню с кнопками (с проверкой прав через базу данных)"""
    builder = ReplyKeyboardBuilder()
    
    # Проверяем права пользователя через базу данных
    is_admin = False
    is_staff = False
    
    if db_manager:
        try:
            is_admin = await db_manager.is_admin(user_id)
            is_staff = await db_manager.is_staff(user_id)
        except Exception as e:
            # Fallback: если база недоступна, используем статическую проверку
            from src.utils.config import settings
            is_admin = await settings.is_admin(user_id)
            is_staff = await settings.is_staff(user_id)
            logger.error(f"❌ Database error in menu keyboard: {e}")
    else:
        # Fallback: если db_manager не передан
        from src.utils.config import settings
        is_admin = await settings.is_admin(user_id)
        is_staff = await settings.is_staff(user_id)
    
    # Первый ряд - для всех пользователей
    builder.button(text=l10n.format_value("menu-btn"))

    # Второй ряд - для всех пользователей
    builder.button(text=l10n.format_value("call-staff-btn"))
    builder.button(text=l10n.format_value("make-reservation-btn"))
    
    # Третий ряд - для всех пользователей
    builder.button(text=l10n.format_value("delivery-btn"))
    
    # Четвертый ряд - для всех пользователей
    builder.button(text=l10n.format_value("invite-friend-btn"))
    builder.button(text=l10n.format_value("loyalty-program-btn"))
    
    # Пятый ряд - для всех пользователей
    builder.button(text=l10n.format_value("get-directions-btn"))
    
    # Шестой ряд - ТОЛЬКО ДЛЯ АДМИНИСТРАТОРОВ
    if is_admin:
        builder.button(text=l10n.format_value("broadcast-btn"))
        builder.button(text=l10n.format_value("analytics-btn"))
        builder.button(text=l10n.format_value("settings-btn"))
    
    # Настройка расположения кнопок в зависимости от прав
    if is_admin:
        # Администратор видит все кнопки
        builder.adjust(1, 2, 1, 2, 1, 1, 2)
    elif is_staff:
        # Официант видит основные кнопки + кнопки персонала
        builder.adjust(1, 2, 1, 2, 1, 1)
    else:
        # Обычный пользователь видит только основные кнопки
        builder.adjust(1, 2, 1, 2, 1, 1)
        
    return builder.as_markup(resize_keyboard=True)

async def confirm_staff_message(l10n: FluentLocalization):
    # Клавиатура с подтверждением
    builder = InlineKeyboardBuilder()
    builder.button(
        text=l10n.format_value("confirm-btn"), 
        callback_data="confirm_staff_call"
    )
    builder.button(
        text=l10n.format_value("cancel-btn"), 
        callback_data="cancel_staff_call"
    )
    builder.adjust(2)
    return builder.as_markup()

async def menu_food_types(l10n: FluentLocalization):
    """Клавиатура с типами блюд"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text=l10n.format_value("menu-breakfasts"))
    builder.button(text=l10n.format_value("menu-hot-foods"))
    builder.button(text=l10n.format_value("menu-hot-drinks"))
    builder.button(text=l10n.format_value("menu-cold-drinks"))
    builder.button(text=l10n.format_value("menu-deserts"))
    builder.button(text=l10n.format_value("menu-go-back"))

    builder.adjust(2, 2, 1, 1)
    return builder.as_markup()

# 🔥 НОВЫЕ КЛАВИАТУРЫ ДЛЯ ДОСТАВКИ

async def get_delivery_categories_kb(l10n: FluentLocalization):
    """Клавиатура категорий доставки"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="🍳 ЗАВТРАКИ")
    builder.button(text="🍲 ГОРЯЧЕЕ")
    builder.button(text="☕️ ГОРЯЧИЕ НАПИТКИ")
    builder.button(text="🍸 ХОЛОДНЫЕ НАПИТКИ")
    builder.button(text="🍰 ДЕСЕРТЫ")
    builder.button(text="🛒 Корзина")
    builder.button(text="🔙 Назад")
    
    builder.adjust(2, 2, 2, 2)
    return builder.as_markup(resize_keyboard=True)

async def get_delivery_menu_kb(l10n: FluentLocalization):
    """Клавиатура действий в меню доставки"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="🛒 Корзина")
    builder.button(text="📋 Категории")
    builder.button(text="🔙 Назад")
    
    builder.adjust(2, 1)
    return builder.as_markup(resize_keyboard=True)

async def get_cart_kb(l10n: FluentLocalization):
    """Клавиатура для корзины"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="✅ Оформить заказ")
    builder.button(text="🗑️ Очистить корзину")
    builder.button(text="📋 Продолжить покупки")
    builder.button(text="🔙 Назад")
    
    builder.adjust(1, 2, 1)
    return builder.as_markup(resize_keyboard=True)

async def get_delivery_time_kb(l10n: FluentLocalization):
    """Клавиатура выбора времени доставки"""
    builder = ReplyKeyboardBuilder()
    
    # Ближайшие временные слоты
    builder.button(text="Как можно скорее")
    builder.button(text="Через 1 час")
    builder.button(text="Через 2 часа")
    builder.button(text="Уточню позже")
    builder.button(text="🔙 Назад")
    
    builder.adjust(1, 2, 1, 1)
    return builder.as_markup(resize_keyboard=True)

async def get_confirmation_kb(l10n: FluentLocalization):
    """Клавиатура подтверждения заказа"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(text="✅ Подтвердить заказ")
    builder.button(text="❌ Отменить")
    
    builder.adjust(2)
    return builder.as_markup(resize_keyboard=True)

async def get_back_kb(l10n: FluentLocalization):
    """Простая клавиатура с кнопкой Назад"""
    builder = ReplyKeyboardBuilder()
    builder.button(text="🔙 Назад")
    return builder.as_markup(resize_keyboard=True)


async def get_phone_keyboard(l10n: FluentLocalization):
    """Клавиатура для запроса телефона"""
    builder = ReplyKeyboardBuilder()
    
    # Кнопка для отправки телефона
    builder.button(
        text="📞 Поделиться телефоном", 
        request_contact=True
    )
    builder.button(text="🔙 Назад")
    
    builder.adjust(1)
    return builder.as_markup(
        resize_keyboard=True,
        one_time_keyboard=True  # Скрыть клавиатуру после использования
    )

async def get_phone_keyboard_with_cancel(l10n: FluentLocalization):
    """Клавиатура для запроса телефона с отменой"""
    builder = ReplyKeyboardBuilder()
    
    # Кнопка для отправки телефона
    builder.button(
        text="📞 Поделиться телефоном", 
        request_contact=True
    )
    builder.button(text="❌ Отмена")
    
    builder.adjust(1)
    return builder.as_markup(
        resize_keyboard=True,
        one_time_keyboard=True
    )

async def get_phone_input_kb(l10n: FluentLocalization):
    """Клавиатура для ввода телефона в доставке"""
    builder = ReplyKeyboardBuilder()
    
    builder.button(
        text="📞 Поделиться телефоном", 
        request_contact=True
    )
    builder.button(text="🔙 Назад")
    
    builder.adjust(1)
    return builder.as_markup(
        resize_keyboard=True,
        one_time_keyboard=True
    )

=== src/handlers/user/message.py ===
from aiogram import Router, F
from aiogram.types import Message, ReplyKeyboardRemove
from aiogram.filters import Command, StateFilter
from fluent.runtime import FluentLocalization
from aiogram.fsm.context import FSMContext
from src.utils.config import settings
from aiogram.fsm.state import any_state


import src.handlers.user.keyboards as kb
from src.states.call_stuff import CallStaff
from src.states.greetings import Greeting
from src.utils.logger import get_logger
from src.utils.rate_limiter import staff_call_limit, reservation_limit, menu_view_limit

router = Router()
logger = get_logger(__name__)

@router.message(Command("start"))
async def start_handler(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager=None):
    user = message.from_user
    logger.info(
        "👤 /start command from user: %s (id: %s, username: %s)", 
        user.full_name, 
        user.id,
        f"@{user.username}" if user.username else "no username"
    )
    
    try:
        # Обработка реферальных ссылок
        referrer_id = None
        if len(message.text.split()) > 1:
            args = message.text.split()[1]
            if args.startswith('ref_'):
                referral_code = args[4:]  # Убираем 'ref_'
                
                # Находим пользователя по реферальному коду
                referrer = await db_manager.get_user_by_referral_code(referral_code)
                if referrer and referrer['user_id'] != user.id:
                    referrer_id = referrer['user_id']
                    logger.info(f"🎯 Referral detected: {user.id} referred by {referrer_id}")
        
        # Добавляем пользователя в БД
        if db_manager:
            await db_manager.add_user(
                user_id=user.id,
                username=user.username,
                full_name=user.full_name,
                language_code=user.language_code
            )
            
            # Устанавливаем реферера если есть
            if referrer_id:
                success = await db_manager.set_user_referrer(user.id, referrer_id)
                if success:
                    # Добавляем pending бонус (200₽ для реферера после первого заказа)
                    await db_manager.add_referral_bonus(referrer_id, user.id, 200.00)
                    
                    # Уведомляем реферера
                    try:
                        referrer_notification = (
                            f"🎉 <b>У вас новый реферал!</b>\n\n"
                            f"👤 {user.full_name} зарегистрировался по вашей ссылке.\n"
                            f"💰 Вы получите <b>200₽</b> после его первого заказа!"
                        )
                        await message.bot.send_message(
                            chat_id=referrer_id,
                            text=referrer_notification,
                            parse_mode="HTML"
                        )
                    except Exception as notify_error:
                        logger.error(f"❌ Failed to notify referrer: {notify_error}")
            
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='start',
                action_data={'has_referrer': bool(referrer_id), 'referrer_id': referrer_id}
            )

        welcome_text = l10n.format_value("welcome-message")
        who_are_you_text = l10n.format_value("who-are-you")
        keyboard = await kb.get_sex_of_user_kb(l10n)

        # Если это реферал, добавляем специальное сообщение
        if referrer_id:
            welcome_text += "\n\n🎁 <b>Специально для вас: 10% скидка на первый заказ!</b>"

        await message.answer(welcome_text, parse_mode="HTML")
        await message.answer(who_are_you_text, reply_markup=keyboard)
        await state.set_state(Greeting.get_sex)
        logger.info("👤 /start command text shown to user %s", message.from_user.id)
    except Exception as e:
        logger.error(
            "❌ Failed to send /start command message to user %s: %s",
            user.id, e, exc_info=True
        )
        raise

@router.message(Command("menu"))
async def open_main_menu_from_command(message: Message, l10n: FluentLocalization, db_manager = None):
    await show_main_menu(message, l10n, db_manager)

# Общая функция для показа главного меню
async def show_main_menu(message: Message, l10n: FluentLocalization, db_manager=None):
    user = message.from_user
    
    try:
        # Инициализируем переменные прав
        is_admin = False
        is_staff = False
        user_rights = []

        # Проверяем права через базу данных, если db_manager доступен
        if db_manager:
            # Гарантируем существование пользователя в базе
            await db_manager.ensure_user_exists(
                user_id=user.id,
                username=user.username,
                full_name=user.full_name
            )
            
            # Получаем права из базы данных
            is_admin = await db_manager.is_admin(user.id)
            is_staff = await db_manager.is_staff(user.id)
            
            # Логируем действие
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='main_menu_view'
            )
        else:
            # Fallback: используем статическую проверку из settings
            from src.utils.config import settings
            is_admin = settings.is_admin(user.id)
            is_staff = settings.is_staff(user.id)
        
        # Формируем список прав для логирования
        if is_admin:
            user_rights.append("ADMIN")
        if is_staff:
            user_rights.append("STAFF")
        
        logger.info(
            "👤 Open main menu for user: %s (id: %s, rights: %s)", 
            user.full_name, 
            user.id,
            user_rights or "USER"
        )

        # Получаем клавиатуру с проверкой прав
        keyboard = await kb.get_main_menu_keyboard(
            l10n=l10n,
            user_id=user.id,
            db_manager=db_manager
        )
        
        welcome_text = l10n.format_value("main-menu-text")
        
        await message.answer(welcome_text, reply_markup=keyboard)
        logger.info("👤 Main menu shown to user %s", user.id)
        
    except Exception as e:
        logger.error(
            "❌ Failed to send welcome message to user %s: %s",
            user.id, e, exc_info=True
        )
        
        # Fallback: создаем базовую клавиатуру без проверки прав
        try:
            from src.utils.config import settings
            keyboard = await kb.get_main_menu_keyboard(l10n, user.id)
        except Exception:
            # Минимальная клавиатура на случай полного сбоя
            from aiogram.utils.keyboard import ReplyKeyboardBuilder
            builder = ReplyKeyboardBuilder()
            builder.button(text="🍽️ Меню ресторана")
            builder.button(text="💺 Забронировать стол")
            builder.adjust(1, 1)
            keyboard = builder.as_markup(resize_keyboard=True)
        
        await message.answer(
            "Добро пожаловать! Используйте меню ниже:",
            reply_markup=keyboard
        )

############################################################################# - Меню (начало)
@router.message(F.text == "📃 Меню")
async def get_menu(message: Message, l10n: FluentLocalization, db_manager = None):
    user = message.from_user
    logger.info(
        "👤 Food menu button from user: %s (id: %s, username: %s)", 
        user.full_name, 
        user.id,
        f"@{user.username}" if user.username else "no username"
    )
    
    try:
        # Логируем действие
        if db_manager:
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='menu_open'
            )

        menu_text = l10n.format_value("menu-title")
        await message.answer(text=menu_text, reply_markup=await kb.menu_food_types(l10n))
        logger.info("👤 Food menu shown to user %s", message.from_user.id)
    except Exception as e:
        logger.error(
            "❌ Failed to send food menu to user %s: %s",
            user.id, e, exc_info=True
        )
        raise

#-----------------------------[Типы блюд]-----------------------------#
#-----------Завтраки
@router.message(F.text == "🍳 Завтраки")
async def breakfasts(message: Message, l10n: FluentLocalization, db_manager = None):
    user = message.from_user
    logger.info(
        "👤 Main_menu->Menu->Breakfasts from user: %s (id: %s, username: %s)", 
        user.full_name, 
        user.id,
        f"@{user.username}" if user.username else "no username"
    )
    
    try:
        # Логируем просмотр категории меню
        if db_manager:
            await db_manager.add_menu_view(
                user_id=user.id,
                category='breakfasts'
            )
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='menu_category_view',
                action_data={'category': 'breakfasts'}
            )

        link_to_breakfasts = "https://telegra.ph/ZAVTRAKI-10-04"
        await message.answer(text=link_to_breakfasts)
        logger.info("👤 Main_menu->Menu->Breakfasts shown to user %s", message.from_user.id)
    except Exception as e:
        logger.error(
            "❌ Failed to send Main_menu->Menu->Breakfasts to user %s: %s",
            user.id, e, exc_info=True
        )
        raise

#-----------Горячие блюда
@router.message(F.text == "🍲 Горячее")
async def hot_dishes(message: Message, l10n: FluentLocalization, db_manager = None):
    user = message.from_user
    logger.info(
        "👤 Main_menu->Menu->Hot dishes from user: %s (id: %s, username: %s)", 
        user.full_name, 
        user.id,
        f"@{user.username}" if user.username else "no username"
    )
    
    try:
        # Логируем просмотр категории меню
        if db_manager:
            await db_manager.add_menu_view(
                user_id=user.id,
                category='hot_dishes'
            )
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='menu_category_view',
                action_data={'category': 'hot_dishes'}
            )

        link_to_hot_dishes = "https://telegra.ph/GORYACHEE-10-04-2"
        await message.answer(text=link_to_hot_dishes)
        logger.info("👤 Main_menu->Menu->Hot dishes shown to user %s", message.from_user.id)
    except Exception as e:
        logger.error(
            "❌ Failed to send Main_menu->Menu->Hot dishes to user %s: %s",
            user.id, e, exc_info=True
        )
        raise

#-----------Горячие напитки
@router.message(F.text == "☕ Горячие напитки")
async def hot_drinks(message: Message, l10n: FluentLocalization, db_manager = None):
    user = message.from_user
    logger.info(
        "👤 Main_menu->Menu->Hot drinks from user: %s (id: %s, username: %s)", 
        user.full_name, 
        user.id,
        f"@{user.username}" if user.username else "no username"
    )
    
    try:
        # Логируем просмотр категории меню
        if db_manager:
            await db_manager.add_menu_view(
                user_id=user.id,
                category='hot_drinks'
            )
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='menu_category_view',
                action_data={'category': 'hot_drinks'}
            )

        link_to_hot_drinks = "https://telegra.ph/GORYACHIE-NAPITKI-10-04"
        await message.answer(text=link_to_hot_drinks)
        logger.info("👤 Main_menu->Menu->Hot drinks shown to user %s", message.from_user.id)
    except Exception as e:
        logger.error(
            "❌ Failed to send Main_menu->Menu->Hot drinks to user %s: %s",
            user.id, e, exc_info=True
        )
        raise

#-----------Холодные напитки
@router.message(F.text == "🍸 Холодные напитки")
async def cold_drinks(message: Message, l10n: FluentLocalization, db_manager = None):
    user = message.from_user
    logger.info(
        "👤 Main_menu->Menu->Cold drinks from user: %s (id: %s, username: %s)", 
        user.full_name, 
        user.id,
        f"@{user.username}" if user.username else "no username"
    )
    
    try:
        # Логируем просмотр категории меню
        if db_manager:
            await db_manager.add_menu_view(
                user_id=user.id,
                category='cold_drinks'
            )
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='menu_category_view',
                action_data={'category': 'cold_drinks'}
            )

        link_to_cold_drinks = "https://telegra.ph/HOLODNYE-NAPITKI-10-04"
        await message.answer(text=link_to_cold_drinks)
        logger.info("👤 Main_menu->Menu->Cold drinks shown to user %s", message.from_user.id)
    except Exception as e:
        logger.error(
            "❌ Failed to send Main_menu->Menu->Cold drinks to user %s: %s",
            user.id, e, exc_info=True
        )
        raise

#-----------Десерты
@router.message(F.text == "🍰 Десерты")
async def desserts(message: Message, l10n: FluentLocalization, db_manager = None):
    user = message.from_user
    logger.info(
        "👤 Main_menu->Menu->Desserts from user: %s (id: %s, username: %s)", 
        user.full_name, 
        user.id,
        f"@{user.username}" if user.username else "no username"
    )
    
    try:
        # Логируем просмотр категории меню
        if db_manager:
            await db_manager.add_menu_view(
                user_id=user.id,
                category='desserts'
            )
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='menu_category_view',
                action_data={'category': 'desserts'}
            )

        link_to_desserts = "https://telegra.ph/DESERTY-10-04"
        await message.answer(text=link_to_desserts)
        logger.info("👤 Main_menu->Menu->Desserts shown to user %s", message.from_user.id)
    except Exception as e:
        logger.error(
            "❌ Failed to send Main_menu->Menu->Desserts to user %s: %s",
            user.id, e, exc_info=True
        )
        raise

#=====Кнопка "Назад" в главное меню
@router.message(F.text == "🔙 Назад")
async def back_to_main_menu(message: Message, l10n: FluentLocalization, db_manager = None):
    await show_main_menu(message, l10n, db_manager)

############################################################################# - Меню (конец)

############################################################################# - Вызвать персонал (начало)
@router.message(F.text == "👨‍💼 Вызвать персонал")
@staff_call_limit(cooldown=30)  # 1 вызов в 30 секунд
async def call_staff_handler(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager = None):
    user = message.from_user
    
    # Логируем действие
    if db_manager:
        await db_manager.add_user_action(
            user_id=user.id,
            action_type='staff_call_start'
        )

    staff_text = l10n.format_value("call-staff-message")
    await state.set_state(CallStaff.table_number)
    await message.answer(text=staff_text)
    logger.info("👨‍💼 Staff call initiated by user %s", message.from_user.id)

@router.message(CallStaff.table_number)
async def confirm_staff_handler(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager = None, settings = None):
    user = message.from_user
    user_text = message.text.strip()
    
    # Проверяем номер стола
    if not user_text.isdigit():
        text = l10n.format_value("error-enter-table-number")
        await message.answer(text=text)
        return
        
    table_number = int(user_text)
    if table_number < 1 or table_number > 99:
        text = l10n.format_value("error-enter-table-number")
        await message.answer(text=text)
        return

    # Сохраняем вызов персонала в БД со статусом 'pending'
    call_id = None
    if db_manager:
        call_id = await db_manager.add_staff_call(
            user_id=user.id,
            table_number=table_number
        )
        await db_manager.add_user_action(
            user_id=user.id,
            action_type='staff_call_created',
            action_data={'table_number': table_number, 'call_id': call_id}
        )

    if not call_id:
        await message.answer("❌ Ошибка при создании вызова")
        await state.clear()
        return

    # Сохраняем call_id в состоянии для использования в callback
    await state.update_data(call_id=call_id, table_number=table_number)

    staff_text = l10n.format_value(
        "confirm-staff-message",
        {"table-number": message.text}
    )
    await message.answer(text=staff_text, reply_markup=await kb.confirm_staff_message(l10n))
    logger.info("👨‍💼 Staff call created for user %s at table %s", user.id, table_number)
    
    # ✅ НЕ очищаем состояние - ждем callback

############################################################################# - Вызвать персонал (конец)


@router.message(F.text == "🗺️ Проложить маршрут__")
async def get_directions(message: Message, l10n: FluentLocalization, db_manager=None):
    """Обработка кнопки 'Проложить маршрут'"""
    try:
        user = message.from_user
        
        # Логируем действие
        if db_manager:
            await db_manager.add_user_action(
                user_id=user.id,
                action_type='get_directions_click'
            )

        # Получаем настройки ресторана
        restaurant_address = settings.RESTAURANT_ADDRESS
        latitude = settings.RESTAURANT_LATITUDE
        longitude = settings.RESTAURANT_LONGITUDE

        # Создаем инлайн-клавиатуру с кнопками для карт
        from aiogram.utils.keyboard import InlineKeyboardBuilder
        
        builder = InlineKeyboardBuilder()
        
        # Ссылки для различных карт
        google_maps_url = f"https://www.google.com/maps/dir/?api=1&destination={latitude},{longitude}"
        yandex_maps_url = f"https://yandex.ru/maps/?rtext=~{latitude},{longitude}"
        apple_maps_url = f"http://maps.apple.com/?daddr={latitude},{longitude}"
        
        builder.button(text="🗺️ Google Maps", url=google_maps_url)
        builder.button(text="📍 Яндекс.Карты", url=yandex_maps_url)
        builder.button(text="🍎 Apple Maps", url=apple_maps_url)
        builder.adjust(1)

        # Формируем сообщение
        text = (
            f"📍 <b>Наш ресторан</b>\n\n"
            f"🏠 <b>Адрес:</b> {restaurant_address}\n"
            f"🌐 <b>Координаты:</b> {latitude:.5f}, {longitude:.5f}\n\n"
            f"📱 <b>Выберите приложение для построения маршрута:</b>"
        )

        await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())
        
        logger.info(f"🗺️ Directions requested by user {user.id}")

    except Exception as e:
        logger.error(f"❌ Error in get_directions: {e}")
        await message.answer("❌ Произошла ошибка при получении информации о местоположении.")










# # Добавляем хендлеры для других кнопок главного меню
# @router.message(F.text == "💺 Забронировать стол")
# async def make_reservation(message: Message, l10n: FluentLocalization, db_manager = None):
#     # Логируем действие
#     if db_manager:
#         await db_manager.add_user_action(
#             user_id=message.from_user.id,
#             action_type='reservation_start'
#         )
#     await message.answer("Функция бронирования стола в разработке")

# @router.message(F.text == "🛵 Доставка")
# async def delivery(message: Message, l10n: FluentLocalization, db_manager = None):
#     # Логируем действие
#     if db_manager:
#         await db_manager.add_user_action(
#             user_id=message.from_user.id,
#             action_type='delivery_click'
#         )
#     await message.answer("Функция доставки в разработке")

# @router.message(F.text == "👥 Пригласи друга")
# async def invite_friend(message: Message, l10n: FluentLocalization, db_manager = None):
#     # Логируем действие
#     if db_manager:
#         await db_manager.add_user_action(
#             user_id=message.from_user.id,
#             action_type='invite_friend_click'
#         )
#     await message.answer("Функция приглашения друга в разработке")

# @router.message(F.text == "💳 Карта лояльности")
# async def loyalty_program(message: Message, l10n: FluentLocalization, db_manager = None):
#     # Логируем действие
#     if db_manager:
#         await db_manager.add_user_action(
#             user_id=message.from_user.id,
#             action_type='loyalty_program_click'
#         )
#     await message.answer("Функция карты лояльности в разработке")

# @router.message(F.text == "🗺️ Проложить маршрут")
# async def get_directions(message: Message, l10n: FluentLocalization, db_manager = None):
#     # Логируем действие
#     if db_manager:
#         await db_manager.add_user_action(
#             user_id=message.from_user.id,
#             action_type='get_directions_click'
#         )
#     await message.answer("Функция прокладки маршрута в разработке")

# @router.message(Command("help"))
# async def help_handler(message: Message, l10n: FluentLocalization, db_manager = None):
#     user = message.from_user
#     logger.info(
#         "👤 /help command from user: %s (id: %s, username: %s)", 
#         user.full_name, 
#         user.id,
#         f"@{user.username}" if user.username else "no username"
#     )

#     try:
#         # Логируем действие
#         if db_manager:
#             await db_manager.add_user_action(
#                 user_id=user.id,
#                 action_type='help_command'
#             )

#         help_text = l10n.format_value("help-message")
#         await message.answer(help_text)
#         logger.info("✅ /help message sent to user %s", user.id)
#     except Exception as e:
#         logger.error(
#             "❌ Failed to send welcome message to user %s: %s",
#             user.id, e, exc_info=True
#         )
#         raise




@router.message(Command("cancel"), any_state)
async def cancel_any_state(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Отмена любого активного состояния"""
    current_state = await state.get_state()
    if current_state is None:
        await message.answer("❌ Нет активных операций для отмены.")
        return
    
    await state.clear()
    
    # Логируем отмену
    logger.info(f"User {message.from_user.id} cancelled operation from state: {current_state}")
    
    # Возвращаем в главное меню
    await show_main_menu(message, l10n)
    
    await message.answer("✅ Операция отменена. Возврат в главное меню.")



@router.message(Command("help"))
async def help_command(message: Message, l10n: FluentLocalization, db_manager=None):
    """Обработчик команды /help с локализацией и разными правами"""
    try:
        user = message.from_user
        user_id = user.id
        
        # Логируем действие
        if db_manager:
            await db_manager.add_user_action(
                user_id=user_id,
                action_type='help_command'
            )

        # Базовый текст для всех пользователей
        help_text = (
            f"{l10n.format_value('help-title')}\n\n"
            f"{l10n.format_value('help-main-commands')}\n\n"
            f"{l10n.format_value('help-additional')}\n\n"
            f"{l10n.format_value('help-commands')}"
        )

        # Добавляем раздел для администраторов
        if settings.is_admin(user_id):
            help_text += f"\n\n{l10n.format_value('help-admin')}"

        # Общая информация для всех
        help_text += (
            f"\n\n{l10n.format_value('help-support')}\n\n"
            f"{l10n.format_value('help-contacts')}"
        )

        await message.answer(help_text, parse_mode="HTML")
        
        logger.info(f"👤 Help command used by user: {user.full_name} (id: {user.id}, admin: {settings.is_admin(user_id)})")
        
    except Exception as e:
        logger.error(f"❌ Error in help command: {e}")
        await message.answer("❌ Произошла ошибка при отображении справки. Попробуйте позже.")


# # Fallback хендлер для неизвестных сообщений
# @router.message()
# async def unknown_message(message: Message, l10n: FluentLocalization, db_manager = None):
#     """Обрабатывает все сообщения, которые не попали в другие хендлеры"""
#     if message.text:
#         logger.info("❓ Unknown message from user %s: %s", message.from_user.id, message.text)
        
#         # Логируем неизвестное действие
#         if db_manager:
#             await db_manager.add_user_action(
#                 user_id=message.from_user.id,
#                 action_type='unknown_message',
#                 action_data={'text': message.text}
#             )
            
#         help_text = "Неизвестная команда. Используйте кнопки меню."
#         await message.answer(help_text)

=== src/handlers/user/referral.py ===
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from fluent.runtime import FluentLocalization
import logging

from src.database.db_manager import DatabaseManager
from src.utils.logger import get_logger
from src.utils.config import settings

router = Router()
logger = get_logger(__name__)

async def process_referral_activation(user_id: int, referral_code: str, db_manager: DatabaseManager, bot, source: str) -> bool:
    """УНИФИЦИРОВАННАЯ функция активации реферального кода"""
    try:
        # Нормализуем код
        referral_code = referral_code.upper().strip()
        
        logger.info(f"🔍 Processing referral activation: user {user_id}, code {referral_code}, source {source}")
        
        # Проверяем свой ли код
        user_referral_code = await db_manager.get_referral_code(user_id)
        if referral_code == user_referral_code:
            logger.warning(f"⚠️ User {user_id} tried to use own referral code")
            return False
        
        # Получаем информацию о пользователе с проверкой реферера
        current_user = await db_manager.get_user(user_id)
        if current_user and current_user.get('referrer_id'):
            logger.warning(f"⚠️ User {user_id} already has referrer: {current_user.get('referrer_id')}")
            return False
        
        # Ищем реферера
        referrer = await db_manager.get_user_by_referral_code(referral_code)
        if not referrer:
            logger.warning(f"⚠️ Referral code not found: {referral_code}")
            return False
        
        # Проверяем самоссылку
        if referrer['user_id'] == user_id:
            logger.warning(f"⚠️ Self-referral attempt: {user_id}")
            return False
        
        # АТОМАРНАЯ установка реферера
        success = await db_manager.set_user_referrer(user_id, referrer['user_id'])
        if not success:
            logger.error(f"❌ Failed to set referrer for user {user_id}")
            return False
        
        # Создаем бонус ТОЛЬКО если реферер успешно установлен
        bonus_created = await db_manager.add_referral_bonus(
            referrer_id=referrer['user_id'],
            referred_id=user_id,
            bonus_amount=200.00
        )
        
        if not bonus_created:
            logger.error(f"❌ Failed to create referral bonus for {user_id}")
            # В этом случае реферер установлен, но бонус не создан - это нормально, он создастся позже
        
        # Уведомляем реферера
        try:
            user_info = await bot.get_chat(user_id)
            user_name = user_info.full_name
            username = f"@{user_info.username}" if user_info.username else "не указан"
            
            referrer_notification = (
                f"🎉 <b>У вас новый реферал!</b>\n\n"
                f"👤 Пользователь: {user_name}\n"
                f"📞 Username: {username}\n"
                f"📱 Источник: {source}\n\n"
                f"💰 Вы получите <b>200₽</b> после его первого заказа!\n"
                f"💳 Следите за статусом в разделе '💳 Карта лояльности'"
            )
            await bot.send_message(
                chat_id=referrer['user_id'],
                text=referrer_notification,
                parse_mode="HTML"
            )
            logger.info(f"✅ Notified referrer {referrer['user_id']} about new referral")
        except Exception as notify_error:
            logger.error(f"❌ Failed to notify referrer: {notify_error}")
        
        logger.info(f"✅ Referral activated: user {user_id} -> referrer {referrer['user_id']} (source: {source})")
        return True
        
    except Exception as e:
        logger.error(f"❌ Error in process_referral_activation: {e}", exc_info=True)
        return False

@router.message(F.text == "👥 Пригласи друга")
async def invite_friend_handler(message: Message, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Главное меню реферальной программы"""
    try:
        user_id = message.from_user.id
        
        # Получаем реферальный код пользователя
        referral_code = await db_manager.get_referral_code(user_id)
        
        # Получаем статистику рефералов
        referral_stats = await db_manager.get_referral_stats(user_id)
        
        text = (
            f"👥 <b>ПРИГЛАСИ ДРУГА - ПОЛУЧИ 200₽</b>\n\n"
            
            f"💎 <b>Как это работает:</b>\n"
            f"• Даешь другу свой код\n"
            f"• Друг делает первый заказ от 500₽\n"
            f"• Ты получаешь <b>200₽</b> на счет\n"
            f"• Друг получает <b>10% скидку</b> на первый заказ\n\n"
            
            f"📊 <b>Твоя статистика:</b>\n"
            f"• Приглашено друзей: {referral_stats['total_referrals']}\n"
            f"• Успешных приглашений: {referral_stats['completed_referrals']}\n"
            f"• Заработано бонусов: {referral_stats['total_referral_bonus']}₽\n"
            f"• Ожидают заказа: {referral_stats['pending_referrals']}\n\n"
            
            f"🎯 <b>Твой реферальный код:</b>\n"
            f"<code>{referral_code}</code>\n\n"
            
            f"💡 <b>Как делиться кодом:</b>\n"
            f"1. Отправь другу свой код\n"
            f"2. Друг должен ввести его при первом заказе\n"
            f"3. Или перешли готовое сообщение ниже\n"
        )
        
        # Создаем инлайн-клавиатуру
        builder = InlineKeyboardBuilder()
        
        builder.button(
            text="📤 Поделиться кодом", 
            callback_data="share_referral"
        )
        
        builder.button(
            text="📋 Правила программы", 
            callback_data="referral_rules"
        )
        
        builder.button(
            text="🔄 Обновить статистику", 
            callback_data="refresh_referral_stats"
        )
        
        builder.adjust(1)
        
        await message.answer(text, parse_mode="HTML", reply_markup=builder.as_markup())
        
        # Отправляем готовое сообщение для пересылки
        share_text = (
            f"🍽️ <b>Привет! У меня есть для тебя подарок!</b>\n\n"
            f"Дарим тебе <b>10% скидку</b> на первый заказ в нашем ресторане! 🎁\n\n"
            f"💎 Просто используй мой реферальный код при заказе:\n"
            f"<code>{referral_code}</code>\n\n"
            f"🛵 Заказывай доставку или бронируй стол - скидка действует везде!\n"
            f"А я получу бонус за твой первый заказ 😊\n\n"
            f"📍 Наш ресторан: {settings.RESTAURANT_ADDRESS}"
        )
        
        await message.answer(
            "📤 <b>Готовое сообщение для пересылки:</b>\n\n"
            "Просто скопируй и отправь другу 👇",
            parse_mode="HTML"
        )
        
        await message.answer(share_text, parse_mode="HTML")
        
        # Логируем действие
        await db_manager.add_user_action(
            user_id=user_id,
            action_type='referral_program_click'
        )
        
        logger.info(f"👥 Referral program shown to user {user_id}")
        
    except Exception as e:
        logger.error(f"❌ Error in invite_friend_handler: {e}", exc_info=True)
        await message.answer("❌ Произошла ошибка при загрузке реферальной программы.")

@router.callback_query(F.data == "share_referral")
async def share_referral_code(callback: CallbackQuery, db_manager: DatabaseManager):
    """Поделиться реферальным кодом"""
    try:
        user_id = callback.from_user.id
        referral_code = await db_manager.get_referral_code(user_id)
        
        share_text = (
            f"🍽️ <b>Дарим тебе 10% скидку на первый заказ!</b>\n\n"
            f"Используй мой реферальный код:\n"
            f"<code>{referral_code}</code>\n\n"
            f"🎁 <b>Что ты получаешь:</b>\n"
            f"• 10% скидку на первый заказ\n"
            f"• Доступ к бонусной программе\n"
            f"• Лучшие блюда города\n\n"
            f"🎁 <b>Что получаю я:</b>\n"
            f"• 200₽ на счет после твоего заказа\n\n"
            f"📍 Наш ресторан: {settings.RESTAURANT_ADDRESS}"
        )
        
        bot_username = (await callback.bot.get_me()).username
        
        # Создаем клавиатуру для быстрого использования кода
        builder = InlineKeyboardBuilder()
        builder.button(
            text="🛵 Сделать заказ", 
            url=f"https://t.me/{bot_username}?start=ref_{referral_code}"
        )
        
        await callback.message.answer(
            "📤 <b>Сообщение для отправки другу:</b>\n\n"
            "Скопируй или перешли это сообщение 👇",
            parse_mode="HTML"
        )
        
        await callback.message.answer(share_text, parse_mode="HTML", reply_markup=builder.as_markup())
        await callback.answer("✅ Сообщение подготовлено для отправки")
        
    except Exception as e:
        logger.error(f"❌ Error in share_referral_code: {e}", exc_info=True)
        await callback.answer("❌ Ошибка при создании сообщения")

@router.callback_query(F.data == "referral_rules")
async def show_referral_rules(callback: CallbackQuery, l10n: FluentLocalization):
    """Показать правила реферальной программы"""
    try:
        text = (
            "📋 <b>ПРАВИЛА РЕФЕРАЛЬНОЙ ПРОГРАММЫ</b>\n\n"
            
            "💎 <b>Для приглашающего:</b>\n"
            "• Получаешь <b>200₽</b> за каждого друга\n"
            "• Друг должен сделать заказ от <b>500₽</b>\n"
            "• Бонусы начисляются после доставки заказа\n"
            "• Можно использовать для оплаты следующих заказов\n"
            "• Нет ограничений по количеству приглашенных\n\n"
            
            "🎁 <b>Для приглашенного:</b>\n"
            "• Получаешь <b>10% скидку</b> на первый заказ\n"
            "• Скидка действует на заказы от <b>500₽</b>\n"
            "• Можно комбинировать с бонусами\n"
            "• Автоматическая регистрация в бонусной программе\n\n"
            
            "⚡ <b>Как работает:</b>\n"
            "1. Делишься своим реферальным кодом\n"
            "2. Друг вводит код при первом заказе\n"
            "3. Система автоматически начисляет скидку другу\n"
            "4. После доставки заказа ты получаешь 200₽\n\n"
            
            "❓ <b>Частые вопросы:</b>\n"
            "• <i>Можно ли использовать свой код?</i>\n"
            "  Нет, это запрещено правилами\n"
            "• <i>Когда начисляются бонусы?</i>\n"
            "  После успешной доставки первого заказа друга\n"
            "• <i>Сколько друзей можно пригласить?</i>\n"
            "  Неограниченное количество\n"
            "• <i>Куда придут бонусы?</i>\n"
            "  На ваш бонусный счет в карте лояльности\n\n"
            
            "📞 <b>Поддержка:</b>\n"
            "По всем вопросам обращайтесь к администратору"
        )
        
        await callback.message.edit_text(text, parse_mode="HTML")
        await callback.answer()
        
    except Exception as e:
        logger.error(f"❌ Error in show_referral_rules: {e}", exc_info=True)
        await callback.answer("❌ Ошибка при загрузке правил")

@router.callback_query(F.data == "refresh_referral_stats")
async def refresh_referral_stats(callback: CallbackQuery, db_manager: DatabaseManager):
    """Обновление статистики рефералов"""
    try:
        user_id = callback.from_user.id
        
        # Получаем обновленную статистику
        referral_stats = await db_manager.get_referral_stats(user_id)
        referral_code = await db_manager.get_referral_code(user_id)
        
        # Обновляем сообщение
        updated_text = (
            f"👥 <b>ПРИГЛАСИ ДРУГА - ПОЛУЧИ 200₽</b>\n\n"
            
            f"💎 <b>Как это работает:</b>\n"
            f"• Даешь другу свой код\n"
            f"• Друг делает первый заказ от 500₽\n"
            f"• Ты получаешь <b>200₽</b> на счет\n"
            f"• Друг получает <b>10% скидку</b> на первый заказ\n\n"
            
            f"📊 <b>Твоя статистика (обновлено):</b>\n"
            f"• Приглашено друзей: {referral_stats['total_referrals']}\n"
            f"• Успешных приглашений: {referral_stats['completed_referrals']}\n"
            f"• Заработано бонусов: {referral_stats['total_referral_bonus']}₽\n"
            f"• Ожидают заказа: {referral_stats['pending_referrals']}\n\n"
            
            f"🎯 <b>Твой реферальный код:</b>\n"
            f"<code>{referral_code}</code>\n\n"
            
            f"💡 <b>Как делиться кодом:</b>\n"
            f"1. Отправь другу свой код\n"
            f"2. Друг должен ввести его при первом заказе\n"
            f"3. Или перешли готовое сообщение ниже\n"
        )
        
        await callback.message.edit_text(updated_text, parse_mode="HTML")
        await callback.answer("✅ Статистика обновлена")
        
    except Exception as e:
        logger.error(f"❌ Error in refresh_referral_stats: {e}", exc_info=True)
        await callback.answer("❌ Ошибка при обновлении статистики")

@router.message(F.text.regexp(r'^[A-Za-z0-9]{4,20}$'))
async def process_referral_code_input(message: Message, db_manager: DatabaseManager, l10n: FluentLocalization):
    """Обработка ввода реферального кода (формат: ABC123)"""
    try:
        user_id = message.from_user.id
        referral_code = message.text
        
        success = await process_referral_activation(
            user_id=user_id,
            referral_code=referral_code,
            db_manager=db_manager,
            bot=message.bot,
            source="manual_input"
        )
        
        if success:
            success_text = (
                f"✅ <b>Реферальный код активирован!</b>\n\n"
                f"🎁 Теперь вы получите <b>10% скидку</b> на ваш первый заказ!\n\n"
                f"💡 Скидка применится автоматически при оформлении заказа.\n"
                f"💰 Ваш реферер получит 200₽ после вашего первого заказа.\n\n"
                f"🛵 <b>Что дальше?</b>\n"
                f"• Сделайте заказ в разделе '🛵 Доставка'\n"
                f"• Или забронируйте стол в '💺 Бронь стола'\n"
                f"• Скидка применится автоматически!"
            )
            await message.answer(success_text, parse_mode="HTML")
            
            await db_manager.add_user_action(
                user_id=user_id,
                action_type='referral_code_activated',
                action_data={'referral_code': referral_code, 'source': 'manual_input'}
            )
        else:
            await message.answer("❌ Не удалось активировать реферальный код. Возможно:\n• Код неверен\n• У вас уже установлен реферер\n• Вы пытаетесь использовать свой код")
            
    except Exception as e:
        logger.error(f"❌ Error processing referral code: {e}", exc_info=True)
        await message.answer("❌ Произошла ошибка при обработке реферального кода.")

@router.message(F.text.startswith("ref_"))
async def handle_referral_code_direct(message: Message, db_manager: DatabaseManager, l10n: FluentLocalization):
    """Обработка прямого ввода реферального кода с префиксом ref_"""
    try:
        user_id = message.from_user.id
        referral_code = message.text[4:]  # Убираем "ref_" префикс
        
        if not referral_code:
            await message.answer("❌ Неверный формат реферального кода.")
            return
        
        success = await process_referral_activation(
            user_id=user_id,
            referral_code=referral_code,
            db_manager=db_manager,
            bot=message.bot,
            source="direct_ref"
        )
        
        if success:
            success_text = (
                f"✅ <b>Реферальный код активирован!</b>\n\n"
                f"🎁 Теперь вы получите <b>10% скидку</b> на ваш первый заказ!\n\n"
                f"💡 Скидка применится автоматически при оформлении заказа.\n"
                f"💰 Ваш реферер получит 200₽ после вашего первого заказа.\n\n"
                f"🛵 <b>Что дальше?</b>\n"
                f"• Сделайте заказ в разделе '🛵 Доставка'\n"
                f"• Или забронируйте стол в '💺 Бронь стола'\n"
                f"• Скидка применится автоматически!"
            )
            
            await message.answer(success_text, parse_mode="HTML")
            
            await db_manager.add_user_action(
                user_id=user_id,
                action_type='referral_code_activated_direct',
                action_data={'referral_code': referral_code, 'source': 'direct_ref'}
            )
        else:
            await message.answer("❌ Не удалось активировать реферальный код. Возможно:\n• Код неверен\n• У вас уже установлен реферер\n• Вы пытаетесь использовать свой код")
            
    except Exception as e:
        logger.error(f"❌ Error in handle_referral_code_direct: {e}", exc_info=True)
        await message.answer("❌ Произошла ошибка при обработке реферального кода.")

async def handle_start_with_referral(user_id: int, referral_code: str, db_manager: DatabaseManager, bot):
    """Обработка реферальной ссылки при команде /start (для использования в main.py)"""
    try:
        success = await process_referral_activation(
            user_id=user_id,
            referral_code=referral_code,
            db_manager=db_manager,
            bot=bot,
            source="start_command"
        )
        
        if success:
            logger.info(f"✅ Referral from start command: user {user_id} -> code {referral_code}")
            return True
        else:
            logger.warning(f"⚠️ Failed to activate referral from start: user {user_id}, code {referral_code}")
            return False
            
    except Exception as e:
        logger.error(f"❌ Error in handle_start_with_referral: {e}", exc_info=True)
        return False

=== src/handlers/user/reservation.py ===
from datetime import date, datetime
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, Contact
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder

from src.handlers.user.message import show_main_menu
from src.states.reservation import ReservationStates
from src.keyboards.calendar import Calendar
from src.utils.config import settings
from src.database.db_manager import DatabaseManager
from fluent.runtime import FluentLocalization
from src.utils.logger import get_logger
from src.utils.rate_limiter import rate_limit, reservation_limit
import src.handlers.user.keyboards as kb
from src.utils.time_utils import format_restaurant_time, parse_reservation_datetime

router = Router()
logger = get_logger(__name__)

# Создаем клавиатуру для отмены
def get_cancel_keyboard(l10n: FluentLocalization):
    """Клавиатура с кнопкой отмены"""
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="❌ Отмена", callback_data="cancel_reservation")
    )
    return builder.as_markup()

# Создаем клавиатуру для выбора количества гостей
def get_guests_keyboard():
    """Клавиатура с цифрами от 1 до 20 для выбора количества гостей"""
    builder = InlineKeyboardBuilder()
    
    # Добавляем кнопки с цифрами от 1 до 20
    for i in range(1, 21):
        builder.add(InlineKeyboardButton(text=str(i), callback_data=f"guests_{i}"))
    
    # Располагаем кнопки в 5 рядов по 4 кнопки
    builder.adjust(4, 4, 4, 4, 4)
    
    # Добавляем кнопку отмены
    builder.row(InlineKeyboardButton(text="❌ Отмена", callback_data="cancel_reservation"))
    
    return builder.as_markup()

async def notify_admins_about_reservation(bot, reservation_data: dict, l10n: FluentLocalization):
    """Уведомление администраторов о новой брони с правильным временем"""
    from src.utils.config import settings
    
    admin_ids = [int(admin_id.strip()) for admin_id in settings.ADMIN_IDS.split(",")]
    
    user_info = f"{reservation_data['user_full_name']}"
    if reservation_data.get('username'):
        user_info += f" (@{reservation_data['username']})"
    
    try:
        # Используем универсальную функцию парсинга
        reservation_datetime = parse_reservation_datetime(
            reservation_data['date'],
            reservation_data['time']
        )
        
        if reservation_datetime:
            formatted_time = format_restaurant_time(reservation_datetime)
            # Форматируем дату
            if isinstance(reservation_data['date'], (datetime, date)):
                formatted_date = reservation_data['date'].strftime("%d.%m.%Y")
            else:
                try:
                    if '-' in str(reservation_data['date']):
                        year, month, day = map(int, str(reservation_data['date']).split('-'))
                        formatted_date = f"{day:02d}.{month:02d}.{year}"
                    else:
                        formatted_date = str(reservation_data['date'])
                except:
                    formatted_date = str(reservation_data['date'])
        else:
            formatted_time = reservation_data['time']
            formatted_date = reservation_data['date']
            
    except Exception as e:
        logger.error(f"❌ Error formatting time in admin notification: {e}")
        formatted_time = reservation_data['time']
        formatted_date = reservation_data['date']
    
    message_text = f"""
🆕 <b>Новая бронь #{reservation_data['id']}</b>

📅 <b>Дата:</b> {formatted_date}
🕐 <b>Время:</b> {formatted_time}
👥 <b>Гости:</b> {reservation_data['guests']}
👤 <b>Имя:</b> {reservation_data['name']}
📞 <b>Телефон:</b> {reservation_data['phone']}
👤 <b>Пользователь:</b> {user_info}
🆔 <b>ID пользователя:</b> {reservation_data['user_id']}
    """
    
    # Создаем клавиатуру с кнопками управления
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(
            text="✅ Подтвердить", 
            callback_data=f"admin_confirm_{reservation_data['id']}"
        ),
        InlineKeyboardButton(
            text="❌ Отклонить", 
            callback_data=f"admin_reject_{reservation_data['id']}"
        )
    )
    
    keyboard = builder.as_markup()
    
    for admin_id in admin_ids:
        try:
            await bot.send_message(admin_id, message_text, parse_mode="HTML", reply_markup=keyboard)
            logger.info(f"✅ Sent reservation notification to admin {admin_id} with correct timezone")
        except Exception as e:
            logger.error(f"❌ Failed to send notification to admin {admin_id}: {e}")

async def notify_user_about_reservation_status(bot, user_id: int, reservation_data: dict, l10n: FluentLocalization):
    """Уведомление пользователя о статусе брони с правильным временем"""
    
    try:
        # Используем универсальную функцию парсинга
        reservation_datetime = parse_reservation_datetime(
            reservation_data['date'], 
            reservation_data['time']
        )
        
        if reservation_datetime:
            formatted_time = format_restaurant_time(reservation_datetime)
            # Форматируем дату в привычный формат
            if isinstance(reservation_data['date'], (datetime, date)):
                formatted_date = reservation_data['date'].strftime("%d.%m.%Y")
            else:
                # Если дата в строковом формате, пытаемся преобразовать
                try:
                    if '-' in str(reservation_data['date']):
                        # Формат "2025-10-10" -> "10.10.2025"
                        year, month, day = map(int, str(reservation_data['date']).split('-'))
                        formatted_date = f"{day:02d}.{month:02d}.{year}"
                    else:
                        formatted_date = str(reservation_data['date'])
                except:
                    formatted_date = str(reservation_data['date'])
        else:
            # Fallback на оригинальные значения
            formatted_time = str(reservation_data['time'])
            formatted_date = str(reservation_data['date'])
        
        status = reservation_data['status']
        
        # Создаем правильное сообщение с отформатированным временем
        message_text = f"""
📋 Статус вашей брони #{reservation_data['id']}

📅 Дата: {formatted_date}
🕐 Время: {formatted_time}
👥 Гости: {reservation_data['guests']}
👤 Имя: {reservation_data['name']}
📞 Телефон: {reservation_data['phone']}

🗒️ Статус: {f"✅ {status}" if status == "подтверждена" else f"❌ {status}"}
        """
        
        await bot.send_message(user_id, message_text)
        logger.info(f"✅ Sent status notification to user {user_id} with correct timezone")
        
    except Exception as e:
        logger.error(f"❌ Error in notify_user_about_reservation_status: {e}")
        # Fallback сообщение
        fallback_text = f"""
📋 Статус вашей брони #{reservation_data['id']}

Статус: {f"✅ {reservation_data['status']}" if reservation_data['status'] == "подтверждена" else f"❌ {reservation_data['status']}"}

Мы свяжемся с вами для уточнения деталей.
        """
        await bot.send_message(user_id, fallback_text)

async def show_reservation_summary(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Показ сводки бронирования для подтверждения"""
    data = await state.get_data()
    
    summary_text = f"""
📋 Подтвердите данные бронирования:

📅 Дата: {data['selected_date']}
🕐 Время: {data['selected_time']}
👥 Гости: {data['guests_count']}
👤 Имя: {data['customer_name']}
📞 Телефон: {data['customer_phone']}
    """
    
    builder = InlineKeyboardBuilder()
    builder.row(
        InlineKeyboardButton(text="✅ Подтвердить", callback_data="confirm_reservation"),
        InlineKeyboardButton(text="❌ Отмена", callback_data="cancel_reservation")
    )
    
    await message.answer(summary_text, reply_markup=builder.as_markup())
    await state.set_state(ReservationStates.confirmation)

@router.message(F.text == "🍽️ Забронировать стол")
@router.message(Command("reserve"))
@reservation_limit(cooldown=30)
async def start_reservation(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Начало процесса бронирования"""
    await state.set_state(ReservationStates.waiting_for_date)
    await message.answer(
        "📅 Выберите дату бронирования:",
        reply_markup=Calendar.get_calendar_keyboard()
    )

@router.callback_query(F.data.startswith("calendar_"), ReservationStates.waiting_for_date)
async def process_calendar(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization):
    """Обработка взаимодействия с календарем"""
    action = callback.data.split("_")[1]
    
    if action == "select":
        # Пользователь выбрал дату
        _, _, year, month, day = callback.data.split("_")
        # Убираем ведущие нули если есть
        day = str(int(day))
        month = str(int(month))
        selected_date = f"{day}.{month}.{year}"
        
        await state.update_data(selected_date=selected_date)
        await state.set_state(ReservationStates.waiting_for_time)
        
        await callback.message.edit_text(
            f"🕐 Выберите время бронирования на {selected_date}:",
            reply_markup=Calendar.get_time_keyboard()
        )
        
    elif action in ["prev", "next"]:
        # Навигация по месяцам
        _, _, year, month = callback.data.split("_")
        year, month = int(year), int(month)
        
        if action == "prev":
            if month == 1:
                year -= 1
                month = 12
            else:
                month -= 1
        else:
            if month == 12:
                year += 1
                month = 1
            else:
                month += 1
        
        await callback.message.edit_reply_markup(
            reply_markup=Calendar.get_calendar_keyboard(year, month)
        )
    
    await callback.answer()

@router.callback_query(F.data.startswith("time_select_"), ReservationStates.waiting_for_time)
async def process_time_selection(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Обработка выбора времени с проверкой доступности - ОБНОВЛЕННАЯ ВЕРСИЯ"""
    selected_time = callback.data.replace("time_select_", "")
    data = await state.get_data()
    
    # Проверяем доступность через новый менеджер
    availability = await db_manager.check_table_availability(
        data['selected_date'], selected_time, data.get('guests_count', 1)
    )
    
    if not availability["available"]:
        # Используем новую систему ошибок
        from src.utils.reservation_errors import get_reservation_error_message, ReservationError
        
        error_mapping = {
            "restaurant_closed": ReservationError.RESTAURANT_CLOSED,
            "past_date": ReservationError.PAST_DATE,
            "no_tables": ReservationError.NO_TABLES,
            "capacity_exceeded": ReservationError.CAPACITY_EXCEEDED,
            "invalid_guests_count": ReservationError.INVALID_GUESTS,
            "error": ReservationError.SERVICE_UNAVAILABLE
        }
        
        error_type = error_mapping.get(availability['reason'], ReservationError.SERVICE_UNAVAILABLE)
        error_message = get_reservation_error_message(error_type, availability.get('details'))
        
        await callback.message.edit_text(error_message)
        await callback.answer()
        return
    
    # Продолжаем как раньше...
    await state.update_data(selected_time=selected_time)
    
    if data.get('guests_count'):
        await state.set_state(ReservationStates.waiting_for_name)
        await callback.message.edit_text(
            "👤 Введите ваше имя:",
            reply_markup=get_cancel_keyboard(l10n)
        )
    else:
        await state.set_state(ReservationStates.waiting_for_guests)
        await callback.message.edit_text(
            "👥 На сколько гостей бронируем?",
            reply_markup=get_guests_keyboard()
        )
    
    await callback.answer()

@router.callback_query(F.data.startswith("guests_"), ReservationStates.waiting_for_guests)
async def process_guests_count_callback(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Обработка выбора количества гостей - ОБНОВЛЕННАЯ ВЕРСИЯ"""
    try:
        guests = int(callback.data.replace("guests_", ""))
        
        data = await state.get_data()
        
        # Если время уже выбрано, проверяем доступность с новым количеством гостей
        if data.get('selected_time'):
            availability = await db_manager.check_table_availability(
                data['selected_date'], data['selected_time'], guests
            )
            
            if not availability["available"]:
                from src.utils.reservation_errors import get_reservation_error_message, ReservationError
                
                error_mapping = {
                    "restaurant_closed": ReservationError.RESTAURANT_CLOSED,
                    "past_date": ReservationError.PAST_DATE,
                    "no_tables": ReservationError.NO_TABLES,
                    "capacity_exceeded": ReservationError.CAPACITY_EXCEEDED,
                    "invalid_guests_count": ReservationError.INVALID_GUESTS,
                    "error": ReservationError.SERVICE_UNAVAILABLE
                }
                
                error_type = error_mapping.get(availability['reason'], ReservationError.SERVICE_UNAVAILABLE)
                error_message = get_reservation_error_message(error_type, availability.get('details'))
                
                await callback.message.edit_text(error_message)
                await callback.answer()
                return
        
        await state.update_data(guests_count=guests)
        await state.set_state(ReservationStates.waiting_for_name)
        
        await callback.message.edit_text(
            f"👥 Выбрано гостей: {guests}\n\n👤 Теперь введите ваше имя:",
            reply_markup=get_cancel_keyboard(l10n)
        )
        
        await callback.answer(f"✅ Выбрано {guests} гостей")
        
    except ValueError:
        await callback.answer("❌ Ошибка при выборе количества гостей")

@router.message(ReservationStates.waiting_for_guests, F.text)
async def process_guests_count_text(message: Message, state: FSMContext, l10n: FluentLocalization, db_manager: DatabaseManager):
    """Обработка ввода количества гостей текстом - ОБНОВЛЕННАЯ ВЕРСИЯ"""
    try:
        guests = int(message.text)
        if guests <= 0 or guests > 20:
            await message.answer("❌ Количество гостей должно быть от 1 до 20")
            return
        
        data = await state.get_data()
        
        # Если время уже выбрано, проверяем доступность
        if data.get('selected_time'):
            availability = await db_manager.check_table_availability(
                data['selected_date'], data['selected_time'], guests
            )
            
            if not availability["available"]:
                from src.utils.reservation_errors import get_reservation_error_message, ReservationError
                
                error_mapping = {
                    "restaurant_closed": ReservationError.RESTAURANT_CLOSED,
                    "past_date": ReservationError.PAST_DATE,
                    "no_tables": ReservationError.NO_TABLES,
                    "capacity_exceeded": ReservationError.CAPACITY_EXCEEDED,
                    "invalid_guests_count": ReservationError.INVALID_GUESTS,
                    "error": ReservationError.SERVICE_UNAVAILABLE
                }
                
                error_type = error_mapping.get(availability['reason'], ReservationError.SERVICE_UNAVAILABLE)
                error_message = get_reservation_error_message(error_type, availability.get('details'))
                
                await message.answer(error_message)
                return
        
        await state.update_data(guests_count=guests)
        await state.set_state(ReservationStates.waiting_for_name)
        
        await message.answer(
            "👤 Введите ваше имя:",
            reply_markup=get_cancel_keyboard(l10n)
        )
        
    except ValueError:
        await message.answer("❌ Пожалуйста, введите корректное число от 1 до 20 или используйте кнопки")

@router.message(ReservationStates.waiting_for_name, F.text)
async def process_customer_name(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Обработка ввода имени"""
    name = message.text.strip()
    if len(name) < 2:
        await message.answer("❌ Имя должно содержать минимум 2 символа")
        return
        
    await state.update_data(customer_name=name)
    await state.set_state(ReservationStates.waiting_for_phone)
    
    await message.answer(
        "📞 Введите ваш телефон или нажмите кнопку ниже:",
        reply_markup=await kb.get_phone_keyboard_with_cancel(l10n)
    )

@router.message(ReservationStates.waiting_for_phone, F.contact)
async def process_contact(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Обработка отправки контакта"""
    contact = message.contact
    phone = contact.phone_number
    
    # Форматируем номер телефона (убираем + если есть)
    if phone.startswith('+'):
        phone = phone[1:]
    
    await state.update_data(customer_phone=phone)
    await show_reservation_summary(message, state, l10n)

@router.message(ReservationStates.waiting_for_phone, F.text)
async def process_customer_phone_text(message: Message, state: FSMContext, l10n: FluentLocalization):
    """Обработка ввода телефона текстом"""
    # Проверяем, не нажата ли кнопка отмены
    if message.text == "❌ Отмена":
        await cancel_reservation(message, state, l10n)
        return
        
    phone = message.text.strip()
    
    # Простая валидация телефона
    if len(phone) < 5:
        await message.answer("❌ Пожалуйста, введите корректный номер телефона")
        return
        
    await state.update_data(customer_phone=phone)
    await show_reservation_summary(message, state, l10n)

@router.callback_query(F.data == "confirm_reservation", ReservationStates.confirmation)
async def confirm_reservation(callback: CallbackQuery, state: FSMContext, db_manager: DatabaseManager, l10n: FluentLocalization, bot: Bot):
    """Подтверждение и сохранение бронирования - ОБНОВЛЕННАЯ ВЕРСИЯ С ПРАВИЛЬНЫМ ВРЕМЕНЕМ"""
    data = await state.get_data()
    
    try:
        user = callback.from_user
        logger.info(f"🔄 Starting ATOMIC reservation process for user {user.id}")
        
        # Используем новый атомарный метод создания брони
        reservation_id = await db_manager.create_reservation(
            user_id=user.id,
            reservation_date=data['selected_date'],
            reservation_time=data['selected_time'],
            guests_count=data['guests_count'],
            customer_name=data['customer_name'],
            customer_phone=data['customer_phone']
        )
        
        if reservation_id:
            logger.info(f"✅ Reservation #{reservation_id} created successfully for user {user.id}")

            # ФОРМАТИРУЕМ ВРЕМЯ ДЛЯ СООБЩЕНИЯ ПОЛЬЗОВАТЕЛЮ
            from src.utils.time_utils import format_restaurant_time
            try:
                day, month, year = map(int, data['selected_date'].split('.'))
                hour, minute = map(int, data['selected_time'].split(':'))
                reservation_datetime = datetime(year, month, day, hour, minute)
                formatted_time = format_restaurant_time(reservation_datetime)
            except Exception as e:
                logger.error(f"❌ Error formatting time in user confirmation: {e}")
                formatted_time = data['selected_time']  # fallback

            # Логируем успешное создание брони
            if db_manager:
                await db_manager.add_user_action(
                    user_id=user.id,
                    action_type='reservation_created',
                    action_data={
                        'reservation_id': reservation_id,
                        'date': data['selected_date'],
                        'time': data['selected_time'],
                        'guests': data['guests_count']
                    }
                )
            
            # Отправляем подтверждение пользователю с ПРАВИЛЬНЫМ ВРЕМЕНЕМ
            success_text = f"""
✅ <b>Бронирование #{reservation_id} успешно создано!</b>

📅 <b>Дата:</b> {data['selected_date']}
🕐 <b>Время:</b> {formatted_time}
👥 <b>Гости:</b> {data['guests_count']}
👤 <b>Имя:</b> {data['customer_name']}
📞 <b>Телефон:</b> {data['customer_phone']}

Мы свяжемся с вами для подтверждения брони.
            """
            
            await callback.message.edit_text(
                success_text,
                parse_mode="HTML",
                reply_markup=None
            )
            
            # Отправляем главное меню
            keyboard = await kb.get_main_menu_keyboard(l10n, user.id)
            await callback.message.answer(
                "🏠 Возвращаемся в главное меню:",
                reply_markup=keyboard
            )
            
            # Уведомляем администраторов с ПРАВИЛЬНЫМ ВРЕМЕНЕМ
            reservation_data = {
                'id': reservation_id,
                'date': data['selected_date'],
                'time': data['selected_time'],  # Будет отформатировано в notify_admins_about_reservation
                'guests': data['guests_count'],
                'name': data['customer_name'],
                'phone': data['customer_phone'],
                'user_id': user.id,
                'username': user.username,
                'user_full_name': user.full_name
            }
            
            await notify_admins_about_reservation(bot, reservation_data, l10n)
            
        else:
            # Обработка случая, когда бронь не создалась
            logger.warning(f"⚠️ Reservation creation failed for user {user.id} - likely race condition")
            
            from src.utils.reservation_errors import get_reservation_error_message, ReservationError
            error_message = get_reservation_error_message(ReservationError.CONFLICT)
            
            await callback.message.edit_text(
                error_message,
                reply_markup=None
            )
            
            # Предлагаем выбрать другое время
            await callback.message.answer(
                "🕐 Пожалуйста, выберите другое время:",
                reply_markup=Calendar.get_time_keyboard()
            )
            await state.set_state(ReservationStates.waiting_for_time)
            return
            
    except Exception as e:
        logger.error(f"❌ Reservation error for user {callback.from_user.id}: {e}", exc_info=True)
        
        from src.utils.reservation_errors import get_reservation_error_message, ReservationError
        error_message = get_reservation_error_message(ReservationError.SERVICE_UNAVAILABLE)
        
        await callback.message.edit_text(
            error_message,
            reply_markup=None
        )
        
    finally:
        # Очищаем состояние только если бронь создана успешно
        if reservation_id:
            await state.clear()

# Обработчики навигации
@router.callback_query(F.data == "back_to_calendar", ReservationStates.waiting_for_time)
async def back_to_calendar(callback: CallbackQuery, state: FSMContext, l10n: FluentLocalization):
    """Возврат к выбору даты"""
    await state.set_state(ReservationStates.waiting_for_date)
    await callback.message.edit_text(
        "📅 Выберите дату бронирования:",
        reply_markup=Calendar.get_calendar_keyboard()
    )
    await callback.answer()
    

@router.callback_query(F.data == "cancel_reservation")
@router.message(Command("cancel"), StateFilter(ReservationStates))
async def cancel_reservation(message: Message | CallbackQuery, state: FSMContext, l10n: FluentLocalization):
    """Отмена бронирования"""
    await state.clear()
    
    text = "❌ Бронирование отменено."
    if isinstance(message, CallbackQuery):
        await message.message.edit_text(text)
        await message.answer()
    else:
        await message.answer(text)


@router.callback_query(F.data.startswith("cancel_reservation_"))
async def cancel_reservation_callback(callback: CallbackQuery, db_manager=None, bot=None):
    """Обработка отмены брони через кнопку в напоминании"""
    try:
        reservation_id = int(callback.data.split("_")[2])
        user_id = callback.from_user.id
        
        logger.info(f"🔄 User {user_id} cancelling reservation #{reservation_id}")
        
        # Получаем информацию о брони
        reservation = await db_manager.get_reservation_by_id(reservation_id)
        
        if not reservation:
            await callback.answer("❌ Бронь не найдена", show_alert=True)
            return
            
        # Проверяем, что бронь принадлежит пользователю
        if reservation['user_id'] != user_id:
            await callback.answer("❌ Вы не можете отменить чужую бронь", show_alert=True)
            return
            
        # Проверяем, что бронь еще не отменена или завершена
        if reservation['status'] in ['cancelled', 'completed']:
            await callback.answer("ℹ️ Эта бронь уже отменена или завершена", show_alert=True)
            return
            
        # Отменяем бронь
        success = await db_manager.update_reservation_status(reservation_id, "cancelled")
        
        if success:
            # Форматируем дату и время для сообщения
            reservation_date = reservation['reservation_date']
            reservation_time = reservation['reservation_time']
            
            if hasattr(reservation_date, 'strftime'):
                formatted_date = reservation_date.strftime("%d.%m.%Y")
            else:
                formatted_date = str(reservation_date)
                
            if hasattr(reservation_time, 'strftime'):
                formatted_time = reservation_time.strftime("%H:%M")
            else:
                formatted_time = str(reservation_time)
            
            # Обновляем сообщение с напоминанием - убираем кнопку
            try:
                await callback.message.edit_text(
                    f"❌ <b>Бронь отменена</b>\n\n"
                    f"Вы отменили бронь на {formatted_date} "
                    f"в {formatted_time}\n\n"
                    f"👥 Гости: {reservation['guests_count']}\n"
                    f"👤 Имя: {reservation['customer_name']}",
                    parse_mode="HTML",
                    reply_markup=None  # Убираем кнопку
                )
            except Exception as e:
                logger.warning(f"⚠️ Could not edit reminder message: {e}")
                # Если не получилось редактировать, просто отправляем новое сообщение
                await callback.message.answer("✅ Бронь успешно отменена")
            
            await callback.answer("✅ Бронь отменена")
            
            # 🔔 УВЕДОМЛЯЕМ АДМИНИСТРАТОРОВ
            await notify_admins_about_cancellation(bot, db_manager, reservation, callback.from_user)
            
            logger.info(f"✅ Reservation #{reservation_id} cancelled by user {user_id}")
            
        else:
            await callback.answer("❌ Ошибка при отмене брони", show_alert=True)
            logger.error(f"❌ Failed to cancel reservation #{reservation_id}")
            
    except Exception as e:
        logger.error(f"❌ Error in cancel_reservation_callback: {e}")
        await callback.answer("❌ Произошла ошибка при отмене брони", show_alert=True)

async def notify_admins_about_cancellation(bot, db_manager, reservation, user):
    """Уведомление администраторов об отмене брони"""
    try:
        admins = await db_manager.get_admins()
        
        if not admins:
            logger.warning("⚠️ No admins found to notify about cancellation")
            return
        
        # Форматируем дату и время для уведомления
        reservation_date = reservation['reservation_date']
        reservation_time = reservation['reservation_time']
        
        if hasattr(reservation_date, 'strftime'):
            formatted_date = reservation_date.strftime("%d.%m.%Y")
        else:
            formatted_date = str(reservation_date)
            
        if hasattr(reservation_time, 'strftime'):
            formatted_time = reservation_time.strftime("%H:%M")
        else:
            formatted_time = str(reservation_time)
            
        cancellation_text = (
            f"❌ <b>БРОНЬ ОТМЕНЕНА ПОЛЬЗОВАТЕЛЕМ</b>\n\n"
            f"📅 <b>Дата:</b> {formatted_date}\n"
            f"🕐 <b>Время:</b> {formatted_time}\n"
            f"👥 <b>Гости:</b> {reservation['guests_count']}\n"
            f"👤 <b>Клиент:</b> {reservation['customer_name']}\n"
            f"📞 <b>Телефон:</b> {reservation['customer_phone']}\n"
            f"🆔 <b>ID пользователя:</b> {user.id}\n"
            f"🔍 <b>Username:</b> @{user.username if user.username else 'нет'}\n"
            f"🆔 <b>ID брони:</b> {reservation['id']}\n\n"
            f"#отмена_брони"
        )
        
        for admin in admins:
            try:
                await bot.send_message(
                    chat_id=admin['user_id'],
                    text=cancellation_text,
                    parse_mode="HTML"
                )
                logger.info(f"✅ Notified admin {admin['user_id']} about cancellation #{reservation['id']}")
            except Exception as e:
                logger.error(f"❌ Failed to notify admin {admin['user_id']}: {e}")
                
    except Exception as e:
        logger.error(f"❌ Error notifying admins: {e}")

=== src/handlers/user/__init__.py ===
__all__ = ("router", )

from aiogram import Router

router = Router()

# Импортируем и включаем роутеры ПОСЛЕ определения router
from .message import router as message_router
from .callback import router as callback_router
from .reservation import router as reservation_router
from .delivery import router as delivery_router
from .directions import router as directions_router
from .referral import router as referral_router
from .bonus import router as bonus_router

router.include_router(message_router)
router.include_router(callback_router)
router.include_router(reservation_router)
router.include_router(delivery_router)
router.include_router(directions_router)
router.include_router(referral_router)
router.include_router(bonus_router)

=== src/i18n/ru/button.ftl ===
# ===== ПРИВЕТСТВЕННОЕ МЕНЮ =====
male-user = Я парень 🧑‍🦰
female-user = Я девушка 👧


# ===== РЕГИСТРАЦИЯ ПОЛЬЗОВАТЕЛЯ =====
major-student = 👨‍🎓 Я студент
major-entrepreneur = 💰 Я предпрениматель
major-hire = 💼 Работаю в найме
major-frilans = 💻 Фрилансер


# ===== ОСНОВНОЕ МЕНЮ =====
menu-btn = 📃 Меню
call-staff-btn = 👨‍💼 Вызвать персонал
make-reservation-btn = 🍽️ Забронировать стол
delivery-btn = 🛵 Доставка

# ===== АКЦИИ И ЛОЯЛЬНОСТЬ =====
invite-friend-btn = 👥 Пригласи друга
loyalty-program-btn = 💳 Карта лояльности

# ===== КОНТАКТЫ И НАВИГАЦИЯ =====
get-directions-btn = 🗺️ Проложить маршрут

# ===== АДМИН ПАНЕЛЬ (только для администраторов) =====
broadcast-btn = 📢 Сделать рассылку подписчикам
settings-btn = ⚙️ Настройки
analytics-btn = 📊 Аналитика

# ===== ОБЩИЕ КНОПКИ =====
back-to-menu-btn = ↩️ В главное меню
cancel-btn = ❌ Отмена
confirm-btn = ✅ Подтвердить




# ===== КНОПКИ ДЛЯ ВЫБОРА ТИПА ЕДЫ =====
menu-breakfasts = 🍳 Завтраки
menu-hot-foods = 🍲 Горячее
menu-hot-drinks = ☕ Горячие напитки
menu-cold-drinks = 🍸 Холодные напитки
menu-deserts = 🍰 Десерты
menu-go-back = 🔙 Назад

=== src/i18n/ru/text.ftl ===
help-message = 
    ПОМОЩЬ ПО БОТУ:

    📋 Команды:
    /start - запустить бот
    /menu - посмотреть меню
    /reservation - забронировать стол
    /help - помощь по БОТУ

    📞 По возникшим вопросам или предложениям писать @garunsuleymanov

menu-title = 
    Выберите что вы хотите⬇️



# Текст для сообщения с маршрутом
directions-title = "Как добраться до нашего ресторана"
directions-address = "Адрес"
directions-hours = "Часы работы"
directions-phone = "Телефон"
directions-parking = "Парковка"
directions-accessibility = "Доступность"


# ===== КОМАНДА /help =====

help-title = 🤖 ПОМОЩЬ ПО БОТУ РЕСТОРАНА

help-main-commands = 
    <b>Основные команды:</b>
    📃 <b>Меню</b> - Просмотр меню ресторана
    👨‍💼 <b>Вызвать персонал</b> - Вызов официанта к вашему столу
    🍽️ <b>Забронировать стол</b> - Бронирование стола в ресторане
    🛵 <b>Доставка</b> - Заказ еды с доставкой

help-additional = 
    <b>Дополнительные функции:</b>
    👥 <b>Пригласить друга</b> - Реферальная программа
    💳 <b>Программа лояльности</b> - Бонусная система
    🗺️ <b>Как добраться</b> - Адрес и схема проезда

help-commands = 
    <b>Команды:</b>
    /start - Перезапустить бота
    /menu - Открыть главное меню
    /help - Показать эту справку

help-admin = 
    <b>Административные команды:</b>
    📊 <b>Аналитика</b> - Статистика и отчеты
    📋 <b>Брони сегодня</b> - Отчет по бронированиям
    🛵 <b>Заказы доставки</b> - Управление заказами
    🏥 <b>Health Monitor</b> - Мониторинг системы

help-support = 
    <b>Техническая поддержка:</b>
    Если у вас возникли проблемы, свяжитесь с администратором.

help-contacts = 
    🕐 <b>Время работы ресторана:</b>
    Пн-Вс: 10:00 - 22:00
    📞 <b>Телефон:</b> +7 (495) 123-45-67


# ===== Приветствие =====
welcome-message =
    Привет! 🖐️
    Я виртуальный помощник ресторана "Good Food"
    
    Давай узнаем друг друга лучше? 😊

# ===== ГЛАВНОЕ МЕНЮ =====
main-menu-title = 
    🍽️ Добро пожаловать в Good Food!

    Куда отправимся?

main-menu-text = 
    { main-menu-title }

# ===== РАЗДЕЛЫ =====
call-staff-message = 
    👨‍💼 Вызов официанта

    Укажите номер вашего стола:
    (Например: 5)

error-enter-table-number = 
    📍 Нужен номер стола для вызова
    Посмотрите на табличку на столе и введите цифру
    Пример: 2

confirm-staff-message = 
    ✅ Подтвердите вызов официанта

    Стол: { $table-number }
    Официант подойдет в течение 1-3 минут

make-reservation-message = 
    💺 Забронировать стол

    Быстрое бронирование онлайн:
    • Дата и время
    • Количество гостей  
    • Пожелания по столу

    Подтверждение за 15 минут! ⏱️

delivery-message = 
    🛵 Доставка из ресторана

    Ваши любимые блюда дома:
    • Доставка: 30-45 мин
    • Минимум: 500₽
    • Бесплатно от 1500₽

    🕒 Работаем: 10:00-23:00

invite-friend-message = 
    👥 Приведи друга - получи бонус!

    За каждого друга:
    • 20% скидка вам и другу
    • Десерт в подарок от 1500₽
    • Бонусные баллы

    Ваша ссылка:
    https://t.me/your_bot?start=ref{ $user_id }

loyalty-program-message = 
    💎 Программа лояльности

    Ваш статус:
    • Баллы: { $points }
    • Уровень: { $level }
    • До повышения: { $points_needed }

    Привилегии:
    • Накопление баллов
    • Персональные скидки

get-directions-message = 
    🗺️ Как нас найти?

    📍 Адрес:
    ул. Ресторанная, 15

    🕒 Время работы:
    Пн-Чт: 10:00-23:00
    Пт-Сб: 10:00-00:00  
    Вс: 10:00-22:00

    📞 Телефон: +7 (495) 123-45-67

# ===== АДМИН ПАНЕЛЬ =====
admin-panel-title = 
    ⚙️ Панель администратора

    Управление рестораном:

broadcast-message = 
    📢 Рассылка подписчикам

    Создайте сообщение для отправки:

settings-message = 
    ⚙️ Настройки системы

    Конфигурация бота и ресторана:

analytics-message = 
    📊 Статистика за сегодня

    • Броней: { $reservations }
    • Заказов: { $orders }
    • Вызовов персонала: { $staff_calls }

# ===== ПОДТВЕРЖДЕНИЯ =====
staff-called-message = 
    ✅ Официант вызван

    Подойдет к столу в течение 1-3 минут

cancel-staff-call = 
    ✅ Вызов отменен

reservation-confirmed-message = 
    ✅ Бронь подтверждена!

    Ждем вас { $date } в { $time }
    Стол на { $guests } гостей

    📞 Для изменений: +7 (495) 123-45-67

# ===== РЕГИСТРАЦИЯ ПОЛЬЗОВАТЕЛЯ =====
who-are-you = Кто вы?

ask-major =
    { $sex }, отлично! 😊

    Чем занимаешься?

messages-before-main-menu =
    { $major }, отлично! 🎉

    Для скидки 10% остался один шаг:
    Перейди в меню и оформи карту лояльности 💳

    (Если меню скрыто, нажпи 🎛️ справа от микрофона)




# ===== БРОНИРОВАНИЕ СТОЛИКА =====

reservation-choose-date = 📅 Выберите дату бронирования:
reservation-choose-time = 🕐 Выберите время бронирования:
reservation-ask-guests = 👥 На сколько гостей бронируем?
reservation-ask-name = 👤 Введите ваше имя:
reservation-ask-phone = 📞 Введите ваш телефон:
reservation-guests-error = ❌ Количество гостей должно быть от 1 до 20
reservation-guests-invalid = ❌ Пожалуйста, введите корректное число
reservation-name-error = ❌ Имя должно содержать минимум 2 символа
reservation-phone-error = ❌ Пожалуйста, введите корректный номер телефона

reservation-summary = 
    📋 Подтвердите данные бронирования:
    
    📅 Дата: { $date }
    🕐 Время: { $time }
    👥 Гости: { $guests }
    👤 Имя: { $name }
    📞 Телефон: { $phone }

reservation-success = 
    ✅ Бронирование #{$id} успешно создано!
    
    📅 Дата: { $date }
    🕐 Время: { $time }
    
    Мы свяжемся с вами для подтверждения.

reservation-error = ❌ Произошла ошибка при создании брони. Попробуйте позже.
reservation-cancelled = ❌ Бронирование отменено.

reservation-not-available-restaurant_closed = ❌ Ресторан закрыт в это время. Мы работаем с 10:00 до 22:00.
reservation-not-available-past_date = ❌ Нельзя забронировать стол на прошедшую дату.
reservation-not-available-no_tables = ❌ К сожалению, на это время нет свободных столов.
reservation-not-available-capacity_exceeded = ❌ Превышена общая вместимость ресторана на это время.
reservation-not-available-error = ❌ Произошла ошибка при проверке доступности.


admin-reservations-menu = 📋 Меню управления бронями:
admin-no-pending-reservations = ⏳ Нет ожидающих подтверждения броней.

admin-reservation-details = 
    📋 Бронь #{$id}
    
    📅 Дата: {$date}
    🕐 Время: {$time}
    👥 Гости: {$guests}
    👤 Имя: {$name}
    📞 Телефон: {$phone}
    👤 ID пользователя: {$user_id}


# ===== УВЕДОМЛЕНИЯ О БРОНИРОВАНИЕ СТОЛИКА =====

admin-new-reservation-notification = 
    🆕 Новая бронь #{$id}
    
    📅 Дата: {$date}
    🕐 Время: {$time}
    👥 Гости: {$guests}
    👤 Имя: {$name}
    📞 Телефон: {$phone}
    👤 ID пользователя: {$user_id}

user-reservation-status-notification = 
    📋 Статус вашей брони #{$id}
    
    📅 Дата: {$date}
    🕐 Время: {$time}
    Статус: {$status}

=== src/keyboards/calendar.py ===
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from datetime import datetime, timedelta
from calendar import monthrange

class Calendar:
    @staticmethod
    def get_calendar_keyboard(year: int = None, month: int = None) -> InlineKeyboardMarkup:
        """Генерация интерактивного календаря"""
        now = datetime.now()
        if not year:
            year = now.year
        if not month:
            month = now.month
        
        # Названия месяцев
        month_names = [
            "Январь", "Февраль", "Март", "Апрель", "Май", "Июнь",
            "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"
        ]
        
        builder = InlineKeyboardBuilder()
        
        # Заголовок с навигацией
        builder.row(
            InlineKeyboardButton(
                text="←", 
                callback_data=f"calendar_prev_{year}_{month}"
            ),
            InlineKeyboardButton(
                text=f"{month_names[month-1]} {year}", 
                callback_data="ignore"
            ),
            InlineKeyboardButton(
                text="→", 
                callback_data=f"calendar_next_{year}_{month}"
            )
        )
        
        # Дни недели
        week_days = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]
        for day in week_days:
            builder.add(InlineKeyboardButton(text=day, callback_data="ignore"))
        
        # Дни месяца
        _, days_in_month = monthrange(year, month)
        first_day_weekday = datetime(year, month, 1).weekday()
        
        # Пустые кнопки для выравнивания
        for _ in range(first_day_weekday):
            builder.add(InlineKeyboardButton(text=" ", callback_data="ignore"))
        
        # Кнопки с днями
        today = datetime.now().date()
        for day in range(1, days_in_month + 1):
            current_date = datetime(year, month, day).date()
            is_past = current_date < today
            is_today = current_date == today
            
            if is_past:
                builder.add(InlineKeyboardButton(
                    text=f"❌{day}", 
                    callback_data="ignore"
                ))
            elif is_today:
                builder.add(InlineKeyboardButton(
                    text=f"📍{day}", 
                    callback_data=f"calendar_select_{year}_{month:02d}_{day:02d}"
                ))
            else:
                builder.add(InlineKeyboardButton(
                    text=str(day), 
                    callback_data=f"calendar_select_{year}_{month:02d}_{day:02d}"
                ))
        
        # Кнопка отмены
        builder.row(
            InlineKeyboardButton(text="❌ Отмена", callback_data="cancel_reservation")
        )
        
        builder.adjust(3, 7, *[7 for _ in range((days_in_month + first_day_weekday - 1) // 7 + 1)], 1)
        return builder.as_markup()

    @staticmethod
    def get_time_keyboard() -> InlineKeyboardMarkup:
        """Генерация клавиатуры для выбора времени"""
        builder = InlineKeyboardBuilder()
        
        # Популярные временные слоты
        time_slots = [
            "10:00", "11:00", "12:00", "13:00", "14:00", "15:00",
            "16:00", "17:00", "18:00", "19:00", "20:00", "21:00"
        ]
        
        for time_slot in time_slots:
            builder.add(InlineKeyboardButton(
                text=time_slot, 
                callback_data=f"time_select_{time_slot}"
            ))
        
        builder.row(
            InlineKeyboardButton(text="⬅️ Назад", callback_data="back_to_calendar"),
            InlineKeyboardButton(text="❌ Отмена", callback_data="cancel_reservation")
        )
        
        builder.adjust(3, 3, 3, 3, 2)
        return builder.as_markup()

=== src/middlewares/fsm_middleware.py ===
from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
import logging
from typing import Callable, Dict, Any, Awaitable

logger = logging.getLogger(__name__)

class FSMMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],
        event: Message | CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        state: FSMContext = data.get("state")
        
        try:
            return await handler(event, data)
        except Exception as e:
            logger.error(f"FSM error for user {event.from_user.id}: {e}", exc_info=True)
            
            # Очищаем состояние при ошибке
            if state:
                current_state = await state.get_state()
                if current_state:
                    await state.clear()
                    logger.info(f"Cleared FSM state '{current_state}' for user {event.from_user.id} due to error")
            
            # Отправляем сообщение об ошибке пользователю
            error_message = "❌ Произошла ошибка. Пожалуйста, начните заново."
            if isinstance(event, Message):
                await event.answer(error_message)
            elif isinstance(event, CallbackQuery):
                await event.message.answer(error_message)
                await event.answer()  # Закрываем уведомление callback
            
            return None  # Прерываем дальнейшую обработку

=== src/states/broadcast.py ===
from aiogram.fsm.state import State, StatesGroup

class BroadcastStates(StatesGroup):
    """Состояния для создания рассылки"""
    choosing_segment = State()
    choosing_type = State()
    entering_text = State()
    entering_image = State()
    confirming = State()

=== src/states/call_stuff.py ===
from aiogram.fsm.state import State, StatesGroup


class CallStaff(StatesGroup):
    table_number = State()

=== src/states/delivery.py ===
from aiogram.fsm.state import State, StatesGroup

class DeliveryStates(StatesGroup):
    choosing_category = State()
    viewing_menu = State()
    viewing_cart = State()
    entering_name = State()
    entering_phone = State()
    entering_address = State()
    entering_referral = State()
    using_bonus = State()
    confirming_order = State()

=== src/states/greetings.py ===
from aiogram.fsm.state import State, StatesGroup


class Greeting(StatesGroup):
    get_sex = State()
    get_major = State()
    open_main_menu = State()

=== src/states/payment.py ===
from aiogram.fsm.state import State, StatesGroup

class PaymentStates(StatesGroup):
    choosing_payment_method = State()
    waiting_payment_confirmation = State()

=== src/states/reservation.py ===
from aiogram.fsm.state import State, StatesGroup

class ReservationStates(StatesGroup):
    waiting_for_date = State()
    waiting_for_time = State()
    waiting_for_guests = State()
    waiting_for_name = State()
    waiting_for_phone = State()
    confirmation = State()

=== src/states/settings.py ===
from aiogram.fsm.state import State, StatesGroup

class SettingsStates(StatesGroup):
    # Управление персоналом
    waiting_for_admin_id = State()
    waiting_for_staff_id = State()
    waiting_for_remove_admin_id = State()
    waiting_for_remove_staff_id = State()
    
    # Управление меню
    waiting_for_menu_category = State()
    waiting_for_dish_name = State()
    waiting_for_dish_description = State()
    waiting_for_dish_price = State()
    waiting_for_remove_dish_id = State()
    
    # Блокировка пользователей
    waiting_for_block_user_id = State()
    waiting_for_unblock_user_id = State()

=== src/utils/config.py ===
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List, Optional

class Settings(BaseSettings):
    BOT_TOKEN: str
    ADMIN_IDS: str
    STAFF_IDS: str

    @property
    def admin_ids_list(self) -> List[int]:
        """Преобразует строку ADMIN_IDS в список чисел"""
        if hasattr(self, 'ADMIN_IDS') and self.ADMIN_IDS:
            return [int(admin_id.strip()) for admin_id in self.ADMIN_IDS.split(",")]
        return []

    @property
    def staff_ids_list(self) -> List[int]:
        """Преобразует строку STAFF_IDS в список чисел"""
        if hasattr(self, 'STAFF_IDS') and self.STAFF_IDS:
            return [int(staff_id.strip()) for staff_id in self.STAFF_IDS.split(",")]
        return []

    @property
    def all_staff_ids(self) -> List[int]:
        """Все ID персонала (админы + стафф)"""
        return list(set(self.admin_ids_list + self.staff_ids_list))

    async def is_admin(self, user_id: int, db_manager = None) -> bool:
        """Проверка прав администратора через базу данных"""
        if db_manager:
            return await db_manager.is_admin(user_id)
        # Fallback: проверка через статический список
        admin_ids = [int(admin_id.strip()) for admin_id in self.ADMIN_IDS.split(",")]
        return user_id in admin_ids

    async def is_staff(self, user_id: int, db_manager = None) -> bool:
        """Проверка прав персонала через базу данных"""
        if db_manager:
            return await db_manager.is_staff(user_id)
        # Fallback: проверка через статический список
        staff_ids = [int(staff_id.strip()) for staff_id in self.STAFF_IDS.split(",")]
        return user_id in staff_ids

    def can_receive_staff_notifications(self, user_id: int) -> bool:
        """Проверяет, может ли пользователь получать уведомления (админы + стафф)"""
        return user_id in self.all_staff_ids
    
    # Restaurant location
    RESTAURANT_ADDRESS: str = "Москва, ул. Тверская, 25"
    RESTAURANT_LATITUDE: float = 55.7603
    RESTAURANT_LONGITUDE: float = 37.6185

    # Настройки логирования
    LOG_LEVEL: str = "INFO"
    LOG_FORMAT: str = "colored"
    ENABLE_FILE_LOGGING: bool = True
    DATABASE_URL: Optional[str] = None

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8"
    )

settings = Settings()

=== src/utils/fsm_cleanup.py ===
import asyncio
from datetime import datetime, timedelta
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.base import BaseStorage
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)

class FSMCleanupService:
    def __init__(self, storage: BaseStorage, timeout_minutes: int = 30):
        self.storage = storage
        self.timeout_minutes = timeout_minutes
        self.is_running = False
    
    async def start_cleanup_task(self):
        """Запускает фоновую задачу очистки устаревших состояний"""
        self.is_running = True
        while self.is_running:
            try:
                await self.cleanup_expired_states()
                await asyncio.sleep(300)  # Проверяем каждые 5 минут
            except Exception as e:
                logger.error(f"FSM cleanup error: {e}")
                await asyncio.sleep(60)
    
    async def stop_cleanup_task(self):
        """Останавливает задачу очистки"""
        self.is_running = False
    
    async def cleanup_expired_states(self):
        """Очищает устаревшие состояния FSM"""
        try:
            # Эта логика зависит от реализации storage
            # Для памяти: states хранятся в оперативке, очистка не нужна
            # Для Redis/DB: нужно реализовать очистку по TTL
            logger.debug("FSM cleanup check performed")
        except Exception as e:
            logger.error(f"FSM cleanup failed: {e}")

# Глобальный экземпляр
fsm_cleanup_service = None

async def start_fsm_cleanup(storage: BaseStorage):
    """Запуск сервиса очистки FSM"""
    global fsm_cleanup_service
    fsm_cleanup_service = FSMCleanupService(storage)
    asyncio.create_task(fsm_cleanup_service.start_cleanup_task())

async def stop_fsm_cleanup():
    """Остановка сервиса очистки FSM"""
    global fsm_cleanup_service
    if fsm_cleanup_service:
        await fsm_cleanup_service.stop_cleanup_task()

=== src/utils/health_monitor.py ===
import asyncio
import psutil
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class HealthStatus(Enum):
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"

@dataclass
class HealthCheckResult:
    component: str
    status: HealthStatus
    message: str
    response_time: float
    timestamp: datetime

class HealthMonitor:
    def __init__(self, db_manager, bot):
        self.db_manager = db_manager
        self.bot = bot
        self.health_history: List[HealthCheckResult] = []
        self.max_history_size = 100
        
    async def perform_full_health_check(self) -> Dict[str, Any]:
        """Выполняет полную проверку здоровья системы"""
        checks = [
            self._check_database_connection,
            self._check_database_performance,
            self._check_memory_usage,
            self._check_disk_usage,
            self._check_bot_connection,
            self._check_background_tasks
        ]
        
        results = []
        overall_status = HealthStatus.HEALTHY
        
        for check in checks:
            try:
                result = await check()
                results.append(result)
                
                if result.status == HealthStatus.UNHEALTHY:
                    overall_status = HealthStatus.UNHEALTHY
                elif result.status == HealthStatus.DEGRADED and overall_status == HealthStatus.HEALTHY:
                    overall_status = HealthStatus.DEGRADED
                    
            except Exception as e:
                logger.error(f"Health check failed: {e}")
                result = HealthCheckResult(
                    component=check.__name__,
                    status=HealthStatus.UNHEALTHY,
                    message=f"Check failed: {str(e)}",
                    response_time=0,
                    timestamp=datetime.now()
                )
                results.append(result)
                overall_status = HealthStatus.UNHEALTHY
        
        # Сохраняем в историю
        self.health_history.extend(results)
        if len(self.health_history) > self.max_history_size:
            self.health_history = self.health_history[-self.max_history_size:]
        
        return {
            "status": overall_status,
            "timestamp": datetime.now(),
            "checks": [self._result_to_dict(r) for r in results],
            "summary": self._generate_summary(results)
        }
    
    async def _check_database_connection(self) -> HealthCheckResult:
        """Проверка соединения с БД"""
        start_time = datetime.now()
        try:
            is_healthy = await self.db_manager.health_check()
            response_time = (datetime.now() - start_time).total_seconds()
            
            if is_healthy:
                return HealthCheckResult(
                    component="database_connection",
                    status=HealthStatus.HEALTHY,
                    message="Database connection is stable",
                    response_time=response_time,
                    timestamp=datetime.now()
                )
            else:
                return HealthCheckResult(
                    component="database_connection",
                    status=HealthStatus.UNHEALTHY,
                    message="Database connection failed",
                    response_time=response_time,
                    timestamp=datetime.now()
                )
        except Exception as e:
            response_time = (datetime.now() - start_time).total_seconds()
            return HealthCheckResult(
                component="database_connection",
                status=HealthStatus.UNHEALTHY,
                message=f"Database connection error: {str(e)}",
                response_time=response_time,
                timestamp=datetime.now()
            )
    
    async def _check_database_performance(self) -> HealthCheckResult:
        """Проверка производительности БД"""
        start_time = datetime.now()
        try:
            async with self.db_manager.pool.acquire() as conn:
                # Проверяем время выполнения простого запроса
                query_start = datetime.now()
                await conn.fetchval("SELECT 1")
                query_time = (datetime.now() - query_start).total_seconds()
                
                # Проверяем количество соединений
                connections = await conn.fetchval("""
                    SELECT count(*) FROM pg_stat_activity 
                    WHERE datname = current_database()
                """)
                
            response_time = (datetime.now() - start_time).total_seconds()
            
            if query_time < 0.1:  # 100ms threshold
                status = HealthStatus.HEALTHY
                message = f"Database performance normal (query: {query_time:.3f}s, connections: {connections})"
            elif query_time < 1.0:
                status = HealthStatus.DEGRADED
                message = f"Database performance degraded (query: {query_time:.3f}s, connections: {connections})"
            else:
                status = HealthStatus.UNHEALTHY
                message = f"Database performance critical (query: {query_time:.3f}s, connections: {connections})"
                
            return HealthCheckResult(
                component="database_performance",
                status=status,
                message=message,
                response_time=response_time,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            response_time = (datetime.now() - start_time).total_seconds()
            return HealthCheckResult(
                component="database_performance",
                status=HealthStatus.UNHEALTHY,
                message=f"Database performance check failed: {str(e)}",
                response_time=response_time,
                timestamp=datetime.now()
            )
    
    async def _check_memory_usage(self) -> HealthCheckResult:
        """Проверка использования памяти"""
        try:
            memory = psutil.virtual_memory()
            response_time = 0.001  # Быстрая проверка
            
            if memory.percent < 80:
                status = HealthStatus.HEALTHY
                message = f"Memory usage: {memory.percent:.1f}%"
            elif memory.percent < 90:
                status = HealthStatus.DEGRADED
                message = f"Memory usage high: {memory.percent:.1f}%"
            else:
                status = HealthStatus.UNHEALTHY
                message = f"Memory usage critical: {memory.percent:.1f}%"
                
            return HealthCheckResult(
                component="memory_usage",
                status=status,
                message=message,
                response_time=response_time,
                timestamp=datetime.now()
            )
        except Exception as e:
            return HealthCheckResult(
                component="memory_usage",
                status=HealthStatus.DEGRADED,
                message=f"Memory check unavailable: {str(e)}",
                response_time=0,
                timestamp=datetime.now()
            )
    
    async def _check_disk_usage(self) -> HealthCheckResult:
        """Проверка использования диска"""
        try:
            disk = psutil.disk_usage('/')
            response_time = 0.001
            
            if disk.percent < 85:
                status = HealthStatus.HEALTHY
                message = f"Disk usage: {disk.percent:.1f}%"
            elif disk.percent < 95:
                status = HealthStatus.DEGRADED
                message = f"Disk usage high: {disk.percent:.1f}%"
            else:
                status = HealthStatus.UNHEALTHY
                message = f"Disk usage critical: {disk.percent:.1f}%"
                
            return HealthCheckResult(
                component="disk_usage",
                status=status,
                message=message,
                response_time=response_time,
                timestamp=datetime.now()
            )
        except Exception as e:
            return HealthCheckResult(
                component="disk_usage",
                status=HealthStatus.DEGRADED,
                message=f"Disk check unavailable: {str(e)}",
                response_time=0,
                timestamp=datetime.now()
            )
    
    async def _check_bot_connection(self) -> HealthCheckResult:
        """Проверка соединения с Telegram API"""
        start_time = datetime.now()
        try:
            me = await self.bot.get_me()
            response_time = (datetime.now() - start_time).total_seconds()
            
            return HealthCheckResult(
                component="bot_connection",
                status=HealthStatus.HEALTHY,
                message=f"Bot connection OK (@{me.username})",
                response_time=response_time,
                timestamp=datetime.now()
            )
        except Exception as e:
            response_time = (datetime.now() - start_time).total_seconds()
            return HealthCheckResult(
                component="bot_connection",
                status=HealthStatus.UNHEALTHY,
                message=f"Bot connection failed: {str(e)}",
                response_time=response_time,
                timestamp=datetime.now()
            )
    
    async def _check_background_tasks(self) -> HealthCheckResult:
        """Проверка фоновых задач"""
        try:
            # Здесь можно добавить проверки специфичных фоновых задач
            tasks = asyncio.all_tasks()
            background_count = len([t for t in tasks if not t.done() and "background" in str(t).lower()])
            
            return HealthCheckResult(
                component="background_tasks",
                status=HealthStatus.HEALTHY,
                message=f"Background tasks running: {background_count}",
                response_time=0.001,
                timestamp=datetime.now()
            )
        except Exception as e:
            return HealthCheckResult(
                component="background_tasks",
                status=HealthStatus.DEGRADED,
                message=f"Background tasks check failed: {str(e)}",
                response_time=0,
                timestamp=datetime.now()
            )
    
    def _result_to_dict(self, result: HealthCheckResult) -> Dict[str, Any]:
        """Конвертирует результат в словарь"""
        return {
            "component": result.component,
            "status": result.status.value,
            "message": result.message,
            "response_time": result.response_time,
            "timestamp": result.timestamp.isoformat()
        }
    
    def _generate_summary(self, results: List[HealthCheckResult]) -> Dict[str, Any]:
        """Генерирует сводку по проверкам"""
        total_checks = len(results)
        healthy_checks = len([r for r in results if r.status == HealthStatus.HEALTHY])
        degraded_checks = len([r for r in results if r.status == HealthStatus.DEGRADED])
        unhealthy_checks = len([r for r in results if r.status == HealthStatus.UNHEALTHY])
        
        # Среднее время ответа
        avg_response_time = sum(r.response_time for r in results) / total_checks if total_checks > 0 else 0
        
        return {
            "total_checks": total_checks,
            "healthy_checks": healthy_checks,
            "degraded_checks": degraded_checks,
            "unhealthy_checks": unhealthy_checks,
            "success_rate": (healthy_checks / total_checks) * 100 if total_checks > 0 else 0,
            "avg_response_time": avg_response_time
        }
    
    def get_health_history(self, hours: int = 24) -> List[Dict[str, Any]]:
        """Возвращает историю проверок здоровья за указанные часы"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        recent_checks = [r for r in self.health_history if r.timestamp > cutoff_time]
        return [self._result_to_dict(r) for r in recent_checks]

=== src/utils/logger.py ===
import logging
import sys
import json
from pathlib import Path
from logging.handlers import RotatingFileHandler
from typing import Optional

class ColoredFormatter(logging.Formatter):
    """Кастомный форматтер с цветами для консоли"""
    
    grey = "\x1b[38;20m"
    blue = "\x1b[34;20m"
    yellow = "\x1b[33;20m"
    red = "\x1b[31;20m"
    bold_red = "\x1b[31;1m"
    reset = "\x1b[0m"
    
    FORMATS = {
        logging.DEBUG: blue + "🐛 %(asctime)s - %(name)s - %(levelname)s - %(message)s" + reset,
        logging.INFO: grey + "ℹ️  %(asctime)s - %(name)s - %(levelname)s - %(message)s" + reset,
        logging.WARNING: yellow + "⚠️  %(asctime)s - %(name)s - %(levelname)s - %(message)s" + reset,
        logging.ERROR: red + "❌ %(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s" + reset,
        logging.CRITICAL: bold_red + "💥 %(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s" + reset
    }
    
    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno, self.FORMATS[logging.INFO])
        formatter = logging.Formatter(log_fmt, datefmt='%H:%M:%S')
        return formatter.format(record)

class JSONFormatter(logging.Formatter):
    """Форматтер для структурированного JSON логирования"""
    
    def format(self, record):
        log_data = {
            "timestamp": self.formatTime(record, "%Y-%m-%d %H:%M:%S"),
            "level": record.levelname,
            "logger": record.name,
            "file": record.filename,
            "line": record.lineno,
            "function": record.funcName,
            "message": record.getMessage(),
        }
        
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)
            
        return json.dumps(log_data, ensure_ascii=False)

def setup_logging(
    log_level: str = "INFO",
    enable_file_logging: bool = True,
    enable_console_logging: bool = True,
    log_format: str = "colored"  # "colored", "json", "simple"
):
    """
    Настройка системы логирования
    
    Args:
        log_level: Уровень логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        enable_file_logging: Включить запись в файл
        enable_console_logging: Включить вывод в консоль
        log_format: Формат вывода ("colored", "json", "simple")
    """
    
    # Создаем папку для логов
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    
    # Получаем корневой логгер
    logger = logging.getLogger()
    logger.setLevel(getattr(logging, log_level.upper()))
    
    # Очищаем существующие handlers
    logger.handlers.clear()
    
    # Настройка форматера в зависимости от выбранного формата
    if log_format == "json":
        formatter = JSONFormatter()
        console_formatter = JSONFormatter()
    elif log_format == "colored":
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        console_formatter = ColoredFormatter()
    else:  # simple
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        console_formatter = formatter
    
    # File Handler с ротацией
    if enable_file_logging:
        file_handler = RotatingFileHandler(
            log_dir / "bot.log",
            maxBytes=10*1024*1024,  # 10 MB
            backupCount=5,
            encoding='utf-8'
        )
        file_handler.setLevel(logging.INFO)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        # Отдельный файл для ошибок
        error_handler = RotatingFileHandler(
            log_dir / "errors.log",
            maxBytes=5*1024*1024,  # 5 MB
            backupCount=3,
            encoding='utf-8'
        )
        error_handler.setLevel(logging.ERROR)
        error_handler.setFormatter(formatter)
        logger.addHandler(error_handler)
    
    # Console Handler
    if enable_console_logging:
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(getattr(logging, log_level.upper()))
        console_handler.setFormatter(console_formatter)
        logger.addHandler(console_handler)
    
    # Устанавливаем уровень для сторонних библиотек чтобы уменьшить шум
    logging.getLogger('aiogram').setLevel(logging.WARNING)
    logging.getLogger('aiohttp').setLevel(logging.WARNING)
    logging.getLogger('asyncio').setLevel(logging.WARNING)
    
    # Логируем старт системы логирования
    logger.info("🚀 Система логирования инициализирована (уровень: %s, формат: %s)", 
                log_level, log_format)

def get_logger(name: str) -> logging.Logger:
    """Получить логгер с указанным именем"""
    return logging.getLogger(name)

# Создаем логгер для этого модуля
logger = get_logger(__name__)

=== src/utils/order_utils.py ===
# src/utils/order_utils.py
import re
from aiogram.utils.keyboard import InlineKeyboardBuilder

def _strip_html_tags(text: str) -> str:
    if not text:
        return ""
    return re.sub(r'<[^>]+>', '', text)

def caption_too_long(text: str, limit: int = 1024) -> bool:
    return len(_strip_html_tags(text)) > limit

def build_order_dashboard_payload(order: dict):
    # Скопируйте логику из вашего build_order_dashboard_payload (только использующиеся части),
    # но НЕ импортируя ничего из admin.* модулей
    # Верните (text, kb) - InlineKeyboardBuilder или InlineKeyboardMarkup
    kb = InlineKeyboardBuilder()
    # ... (логика формирования items_text и клавиатуры)
    # для краткости покажу пример-скелет:
    order_id = order.get('id')
    text = f"🆕 <b>Заказ #{order_id}</b>\n\n"
    # добавьте остальные поля: items, qty, суммы, оплата
    # build kb buttons как у вас
    return text, kb

def format_order_card(order: dict, urgent: bool = False):
    # Вынесите сюда код форматирования одной карточки (взятый из DeliveryDashboard.format_order_card)
    # Возвращает строку
    ...


=== src/utils/rate_limiter.py ===
from functools import wraps
from typing import Dict, Tuple
import time
from aiogram.types import Message, CallbackQuery
import logging
from collections import defaultdict

logger = logging.getLogger(__name__)

class RateLimiter:
    def __init__(self):
        # Структура: {(user_id, action): [timestamps]}
        self.user_limits: Dict[Tuple[int, str], list] = defaultdict(list)
        self.cleanup_interval = 3600  # 1 час
        self.last_cleanup = time.time()
    
    def check_limit(self, user_id: int, action: str, cooldown: int, max_requests: int = 1) -> Tuple[bool, float]:
        """
        Проверяет лимит для пользователя и действия
        
        Args:
            user_id: ID пользователя
            action: тип действия
            cooldown: время охлаждения в секундах
            max_requests: максимальное количество запросов за период
            
        Returns:
            (is_limited, remaining_time)
        """
        current_time = time.time()
        
        # Периодическая очистка старых записей
        if current_time - self.last_cleanup > self.cleanup_interval:
            self.cleanup_old_entries()
            self.last_cleanup = current_time
        
        key = (user_id, action)
        timestamps = self.user_limits[key]
        
        # Удаляем старые временные метки
        timestamps = [ts for ts in timestamps if current_time - ts < cooldown]
        self.user_limits[key] = timestamps
        
        # Проверяем лимит
        if len(timestamps) >= max_requests:
            oldest_timestamp = min(timestamps)
            remaining = cooldown - (current_time - oldest_timestamp)
            return True, max(0, remaining)
        
        # Добавляем текущую временную метку
        timestamps.append(current_time)
        return False, 0
    
    def cleanup_old_entries(self, max_age: int = 86400):  # 24 часа по умолчанию
        """Очищает старые записи (старше max_age секунд)"""
        current_time = time.time()
        keys_to_remove = []
        
        for key, timestamps in self.user_limits.items():
            # Оставляем только свежие временные метки
            fresh_timestamps = [ts for ts in timestamps if current_time - ts < max_age]
            if fresh_timestamps:
                self.user_limits[key] = fresh_timestamps
            else:
                keys_to_remove.append(key)
        
        for key in keys_to_remove:
            del self.user_limits[key]
        
        if keys_to_remove:
            logger.debug(f"🧹 Очищено {len(keys_to_remove)} старых записей rate limiting")

# Глобальный экземпляр
rate_limiter = RateLimiter()

def rate_limit(cooldown: int = 60, action: str = "default", max_requests: int = 1):
    """
    Декоратор для ограничения частоты запросов
    
    Args:
        cooldown: время охлаждения в секундах
        action: тип действия (для разделения лимитов)
        max_requests: максимальное количество запросов за период
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Извлекаем user_id из аргументов
            user_id = None
            for arg in args:
                if isinstance(arg, (Message, CallbackQuery)):
                    user_id = arg.from_user.id
                    break
            
            if user_id is None:
                logger.warning(f"❌ Не удалось извлечь user_id для rate limiting в {func.__name__}")
                return await func(*args, **kwargs)
            
            # Проверяем лимит
            is_limited, remaining = rate_limiter.check_limit(user_id, action, cooldown, max_requests)
            
            if is_limited:
                remaining_seconds = int(remaining)
                minutes = remaining_seconds // 60
                seconds = remaining_seconds % 60
                
                if minutes > 0:
                    time_text = f"{minutes} мин {seconds} сек"
                else:
                    time_text = f"{seconds} сек"
                
                message_text = f"⏳ Слишком частые запросы. Попробуйте через {time_text}."
                
                logger.info(f"🚫 Rate limit: user {user_id}, action '{action}', wait {remaining_seconds}s")
                
                if isinstance(args[0], Message):
                    await args[0].answer(message_text)
                elif isinstance(args[0], CallbackQuery):
                    await args[0].answer(message_text, show_alert=True)
                return
            
            # Если лимит не превышен - выполняем функцию
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# Специализированные декораторы
def staff_call_limit(cooldown: int = 30, max_requests: int = 3):
    """Специальный декоратор для вызовов персонала"""
    return rate_limit(cooldown=cooldown, action="staff_call", max_requests=max_requests)

def reservation_limit(cooldown: int = 30, max_requests: int = 2):
    """Специальный декоратор для бронирований"""
    return rate_limit(cooldown=cooldown, action="reservation_start", max_requests=max_requests)

def menu_view_limit(cooldown: int = 10, max_requests: int = 10):
    """Специальный декоратор для просмотра меню"""
    return rate_limit(cooldown=cooldown, action="menu_view", max_requests=max_requests)

=== src/utils/reminders.py ===
import asyncio
from aiogram.utils.keyboard import InlineKeyboardBuilder
from datetime import datetime, timedelta, date, time
from src.database.db_manager import DatabaseManager
from aiogram import Bot

class ReminderSystem:
    def __init__(self, bot: Bot, db_manager: DatabaseManager):
        self.bot = bot
        self.db_manager = db_manager
        self.is_running = False
        self.sent_reminders_24h = set()
        self.sent_reminders_3h = set()
    
    async def start(self):
        """Запуск системы напоминаний"""
        self.is_running = True
        while self.is_running:
            try:
                # Сначала обновляем прошедшие брони
                await self.db_manager.update_expired_reservations()
                
                # Затем проверяем напоминания
                await self.check_reminders()
                await asyncio.sleep(300)  # Проверяем каждые 5 минут
            except Exception as e:
                print(f"Reminder system error: {e}")
                await asyncio.sleep(60)
    
    async def stop(self):
        """Остановка системы напоминаний"""
        self.is_running = False
    
    async def check_reminders(self):
        """Проверка и отправка напоминаний"""
        now = datetime.now()
        
        # Напоминание за 24 часа
        tomorrow_date = (now + timedelta(days=1)).strftime("%d.%m.%Y")
        tomorrow_reservations = await self.db_manager.get_reservations_for_date(tomorrow_date)
        
        for reservation in tomorrow_reservations:
            if (reservation['status'] == 'confirmed' and 
                reservation['id'] not in self.sent_reminders_24h):
                
                reservation_date = reservation['reservation_date']
                reservation_time = reservation['reservation_time']
                
                if isinstance(reservation_date, date) and isinstance(reservation_time, time):
                    reservation_datetime = datetime.combine(reservation_date, reservation_time)
                    time_until_reservation = reservation_datetime - now
                    
                    # Отправляем напоминание за 23.5-24.5 часа до брони
                    if timedelta(hours=23, minutes=30) <= time_until_reservation <= timedelta(hours=24, minutes=30):
                        await self.send_24h_reminder(reservation)
                        self.sent_reminders_24h.add(reservation['id'])
        
        # Напоминание за 3 часа
        today_date = now.strftime("%d.%m.%Y")
        today_reservations = await self.db_manager.get_reservations_for_date(today_date)
        
        for reservation in today_reservations:
            if (reservation['status'] == 'confirmed' and 
                reservation['id'] not in self.sent_reminders_3h):
                
                reservation_date = reservation['reservation_date']
                reservation_time = reservation['reservation_time']
                
                if isinstance(reservation_date, date) and isinstance(reservation_time, time):
                    reservation_datetime = datetime.combine(reservation_date, reservation_time)
                    time_until_reservation = reservation_datetime - now
                    
                    # Отправляем напоминание за 2.5-3.5 часа до брони
                    if timedelta(hours=2, minutes=30) <= time_until_reservation <= timedelta(hours=3, minutes=30):
                        await self.send_3h_reminder(reservation)
                        self.sent_reminders_3h.add(reservation['id'])
        
        # Очищаем старые записи из кэша напоминаний
        self._cleanup_old_reminders()
    
    def _cleanup_old_reminders(self):
        """Очистка старых напоминаний из кэша"""
        # Удаляем ID броней, которые уже прошли (старше 2 дней)
        current_ids_24h = set()
        current_ids_3h = set()
        
        # В реальном приложении здесь нужно проверять актуальность ID в базе
        # Пока просто ограничим размер множеств
        if len(self.sent_reminders_24h) > 100:
            self.sent_reminders_24h.clear()
        if len(self.sent_reminders_3h) > 100:
            self.sent_reminders_3h.clear()
    
    async def send_24h_reminder(self, reservation):
        """Отправка напоминания за 24 часа"""
        # Форматируем дату для отображения
        reservation_date = reservation['reservation_date']
        if isinstance(reservation_date, date):
            formatted_date = reservation_date.strftime("%d.%m.%Y")
        else:
            formatted_date = str(reservation_date)
        
        # Форматируем время для отображения
        reservation_time = reservation['reservation_time']
        if isinstance(reservation_time, time):
            formatted_time = reservation_time.strftime("%H:%M")
        else:
            formatted_time = str(reservation_time)

        # Создаем клавиатуру с кнопкой отмены
        keyboard = InlineKeyboardBuilder()
        keyboard.button(
            text="❌ Отменить бронь", 
            callback_data=f"cancel_reservation_{reservation['id']}"
        )
        
        message_text = f"""
🔔 <b>Напоминание о бронировании!</b>

Через 24 часа у вас бронь в нашем ресторане.

📅 Дата: {formatted_date}
🕐 Время: {formatted_time}
👥 Гости: {reservation['guests_count']}

Если планы изменились, вы можете отменить бронь:
"""
        
        try:
            await self.bot.send_message(
                reservation['user_id'], 
                message_text, 
                reply_markup=keyboard.as_markup(),
                parse_mode="HTML"  # Добавляем HTML для форматирования
            )
            print(f"📨 Sent 24h reminder for reservation #{reservation['id']} to user {reservation['user_id']}")
        except Exception as e:
            print(f"❌ Failed to send 24h reminder: {e}")
    
    async def send_3h_reminder(self, reservation):
        """Отправка напоминания за 3 часа"""
        # Форматируем дату для отображения
        reservation_date = reservation['reservation_date']
        if isinstance(reservation_date, date):
            formatted_date = reservation_date.strftime("%d.%m.%Y")
        else:
            formatted_date = str(reservation_date)
        
        # Форматируем время для отображения
        reservation_time = reservation['reservation_time']
        if isinstance(reservation_time, time):
            formatted_time = reservation_time.strftime("%H:%M")
        else:
            formatted_time = str(reservation_time)

        # Создаем клавиатуру с кнопкой отмены
        keyboard = InlineKeyboardBuilder()
        keyboard.button(
            text="❌ Отменить бронь", 
            callback_data=f"cancel_reservation_{reservation['id']}"
        )
        
        message_text = f"""
⏰ <b>Скоро встреча!</b>

Через 3 часа у вас бронь в нашем ресторане.

📅 Дата: {formatted_date}
🕐 Время: {formatted_time}
👥 Гости: {reservation['guests_count']}

Если не успеваете, отмените бронь:
"""
        
        try:
            await self.bot.send_message(
                reservation['user_id'],
                message_text, 
                reply_markup=keyboard.as_markup(),
                parse_mode="HTML"  # Добавляем HTML для форматирования
            )
            print(f"📨 Sent 3h reminder for reservation #{reservation['id']} to user {reservation['user_id']}")
        except Exception as e:
            print(f"❌ Failed to send 3h reminder: {e}")

# Глобальный экземпляр системы напоминаний
reminder_system = None

async def start_reminder_system(bot: Bot, db_manager: DatabaseManager):
    """Запуск системы напоминаний"""
    global reminder_system
    reminder_system = ReminderSystem(bot, db_manager)
    asyncio.create_task(reminder_system.start())

async def stop_reminder_system():
    """Остановка системы напоминаний"""
    global reminder_system
    if reminder_system:
        await reminder_system.stop()

=== src/utils/report_generator.py ===
import os
import logging
from datetime import datetime, date
from typing import List, Dict, Any
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
from openpyxl.utils import get_column_letter
import tempfile

logger = logging.getLogger(__name__)

class ReportGenerator:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    async def generate_daily_reservations_report(self, reservations: List[Dict[str, Any]]) -> str:
        """
        Генерирует Excel файл с бронированиями на текущий день
        
        Returns:
            Путь к сгенерированному файлу
        """
        try:
            # Создаем временный файл
            with tempfile.NamedTemporaryFile(mode='wb', suffix='.xlsx', delete=False) as tmp_file:
                file_path = tmp_file.name
            
            # Создаем workbook и worksheet
            wb = Workbook()
            ws = wb.active
            ws.title = "Бронирования"
            
            # Заголовки колонок
            headers = [
                "ID", "Время", "Гости", "Имя клиента", "Телефон",
                "Статус", "ID пользователя", "Создано", "Примечания"
            ]
            
            # Стили для заголовков
            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
            header_alignment = Alignment(horizontal="center", vertical="center")
            thin_border = Border(left=Side(style='thin'), right=Side(style='thin'),
                               top=Side(style='thin'), bottom=Side(style='thin'))
            
            # Записываем заголовки
            for col, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col, value=header)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = header_alignment
                cell.border = thin_border
            
            # Записываем данные
            for row, reservation in enumerate(reservations, 2):
                # Форматируем время
                reservation_time = reservation['reservation_time']
                if isinstance(reservation_time, str):
                    time_str = reservation_time
                else:
                    time_str = reservation_time.strftime("%H:%M")
                
                # Форматируем дату создания
                created_at = reservation['created_at']
                if isinstance(created_at, datetime):
                    created_str = created_at.strftime("%d.%m.%Y %H:%M")
                else:
                    created_str = str(created_at)
                
                # Статус с русским текстом
                status_map = {
                    'pending': '⏳ Ожидание',
                    'confirmed': '✅ Подтверждено', 
                    'cancelled': '❌ Отменено',
                    'completed': '🎉 Завершено'
                }
                status_text = status_map.get(reservation['status'], reservation['status'])
                
                data_row = [
                    reservation['id'],
                    time_str,
                    reservation['guests_count'],
                    reservation['customer_name'],
                    reservation['customer_phone'],
                    status_text,
                    reservation['user_id'],
                    created_str,
                    reservation.get('notes', '')
                ]
                
                for col, value in enumerate(data_row, 1):
                    cell = ws.cell(row=row, column=col, value=value)
                    cell.border = thin_border
                    
                    # Центрируем числовые колонки
                    if col in [1, 3, 7]:  # ID, Гости, User ID
                        cell.alignment = Alignment(horizontal="center")
            
            # Настраиваем ширину колонок
            column_widths = [8, 10, 8, 20, 15, 15, 12, 16, 25]
            for i, width in enumerate(column_widths, 1):
                ws.column_dimensions[get_column_letter(i)].width = width
            
            # Добавляем фильтры
            ws.auto_filter.ref = f"A1:I{len(reservations) + 1}"
            
            # Добавляем сводную информацию
            summary_row = len(reservations) + 3
            ws.cell(row=summary_row, column=1, value="Сводка:").font = Font(bold=True)
            ws.cell(row=summary_row, column=2, value=f"Всего бронирований: {len(reservations)}")
            
            # Статистика по статусам
            status_counts = {}
            for reservation in reservations:
                status = reservation['status']
                status_counts[status] = status_counts.get(status, 0) + 1
            
            for i, (status, count) in enumerate(status_counts.items(), 1):
                status_text = status_map.get(status, status)
                ws.cell(row=summary_row + i, column=2, value=f"{status_text}: {count}")
            
            # Сохраняем файл
            wb.save(file_path)
            self.logger.info(f"✅ Generated reservations report with {len(reservations)} entries")
            
            return file_path
            
        except Exception as e:
            self.logger.error(f"❌ Failed to generate reservations report: {e}")
            raise
    
    def cleanup_file(self, file_path: str):
        """Очищает временный файл"""
        try:
            if os.path.exists(file_path):
                os.unlink(file_path)
                self.logger.debug(f"🧹 Cleared temporary file: {file_path}")
        except Exception as e:
            self.logger.warning(f"⚠️ Could not delete temporary file {file_path}: {e}")

=== src/utils/reservation_errors.py ===
from enum import Enum
from typing import Dict, Any

class ReservationError(Enum):
    RESTAURANT_CLOSED = "restaurant_closed"
    PAST_DATE = "past_date" 
    NO_TABLES = "no_tables"
    CAPACITY_EXCEEDED = "capacity_exceeded"
    INVALID_GUESTS = "invalid_guests_count"
    CONFLICT = "time_conflict"
    SERVICE_UNAVAILABLE = "service_unavailable"

ERROR_MESSAGES = {
    ReservationError.RESTAURANT_CLOSED: {
        "message": "❌ Ресторан закрыт в это время. Мы работаем с 10:00 до 22:00.",
        "user_friendly": True
    },
    ReservationError.PAST_DATE: {
        "message": "❌ Нельзя забронировать стол на прошедшую дату.",
        "user_friendly": True
    },
    ReservationError.NO_TABLES: {
        "message": "❌ К сожалению, на это время нет свободных столов.",
        "user_friendly": True
    },
    ReservationError.CAPACITY_EXCEEDED: {
        "message": "❌ Превышена общая вместимость ресторана на это время.",
        "user_friendly": True
    },
    ReservationError.INVALID_GUESTS: {
        "message": "❌ Количество гостей должно быть от 1 до 20.",
        "user_friendly": True
    },
    ReservationError.CONFLICT: {
        "message": "❌ Это время стало недоступно. Пожалуйста, выберите другое время.",
        "user_friendly": True
    },
    ReservationError.SERVICE_UNAVAILABLE: {
        "message": "❌ Сервис бронирования временно недоступен. Попробуйте позже.",
        "user_friendly": True
    }
}

def get_reservation_error_message(error_type: ReservationError, details: Dict[str, Any] = None) -> str:
    """Получение пользовательского сообщения об ошибке"""
    error_config = ERROR_MESSAGES.get(error_type, {
        "message": "❌ Произошла ошибка при бронировании.",
        "user_friendly": True
    })
    
    message = error_config["message"]
    
    # Добавляем детали если есть
    if details and error_config.get("include_details", False):
        message += f"\n\nДетали: {details}"
    
    return message

=== src/utils/security.py ===
from functools import wraps
from aiogram.types import Message, CallbackQuery
from src.utils.config import settings
import logging

logger = logging.getLogger(__name__)

def admin_required(func):
    """Декоратор для проверки прав администратора"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        user_id = None
        
        # Извлекаем user_id из разных типов аргументов
        for arg in args:
            if isinstance(arg, Message):
                user_id = arg.from_user.id
                break
            elif isinstance(arg, CallbackQuery):
                user_id = arg.from_user.id
                break
        
        if not user_id or not settings.is_admin(user_id):
            logger.warning(f"❌ Unauthorized admin access attempt by user {user_id}")
            if len(args) > 0:
                if isinstance(args[0], Message):
                    await args[0].answer("❌ Эта команда доступна только администраторам.")
                elif isinstance(args[0], CallbackQuery):
                    await args[0].answer("❌ У вас нет доступа к этой команде.", show_alert=True)
            return
        
        return await func(*args, **kwargs)
    return wrapper

def staff_required(func):
    """Декоратор для проверки прав персонала"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        user_id = None
        
        for arg in args:
            if isinstance(arg, Message):
                user_id = arg.from_user.id
                break
            elif isinstance(arg, CallbackQuery):
                user_id = arg.from_user.id
                break
        
        if not user_id or not settings.is_staff(user_id):
            logger.warning(f"❌ Unauthorized staff access attempt by user {user_id}")
            if len(args) > 0:
                if isinstance(args[0], Message):
                    await args[0].answer("❌ У вас нет доступа к этой команде.")
                elif isinstance(args[0], CallbackQuery):
                    await args[0].answer("❌ У вас нет доступа к этой команде.", show_alert=True)
            return
        
        return await func(*args, **kwargs)
    return wrapper

=== src/utils/time_utils.py ===
from datetime import date, datetime, time
import pytz
from src.utils.logger import get_logger

logger = get_logger(__name__)

# Часовой пояс ресторана (например, Europe/Moscow для UTC+3/UTC+4)
RESTAURANT_TIMEZONE = pytz.timezone('Europe/Astrakhan')

def get_restaurant_time(dt=None):
    """
    Получить текущее время в часовом поясе ресторана
    Если dt не указан, возвращает текущее время
    """
    if dt is None:
        dt = datetime.now(pytz.utc)
    
    # Если время наивное (без часового пояса), считаем что это UTC
    if dt.tzinfo is None:
        dt = pytz.utc.localize(dt)
    
    # Конвертируем в часовой пояс ресторана
    return dt.astimezone(RESTAURANT_TIMEZONE)

def format_restaurant_time(dt=None, format_str='%H:%M:%S'):
    """
    Отформатировать время в часовом поясе ресторана
    """
    restaurant_time = get_restaurant_time(dt)
    return restaurant_time.strftime(format_str)


def parse_reservation_datetime(date_str, time_str):
    """Парсит дату и время из разных форматов в объект datetime"""
    try:
        # Если это уже datetime объект, возвращаем как есть
        if isinstance(date_str, datetime) and isinstance(time_str, (datetime, time)):
            if isinstance(time_str, time):
                return datetime.combine(date_str.date(), time_str)
            return date_str
        
        # Если это date и time объекты
        if isinstance(date_str, date) and isinstance(time_str, time):
            return datetime.combine(date_str, time_str)
        
        # Парсим строковые форматы
        date_str = str(date_str)
        time_str = str(time_str)
        
        # Парсим дату (поддерживаем оба формата: "10.10.2025" и "2025-10-10")
        if '.' in date_str:
            # Формат "день.месяц.год"
            day, month, year = map(int, date_str.split('.'))
        else:
            # Формат "год-месяц-день"
            year, month, day = map(int, date_str.split('-'))
        
        # Парсим время (поддерживаем "10:00" и "10:00:00")
        time_parts = time_str.split(':')
        hour = int(time_parts[0])
        minute = int(time_parts[1])
        
        return datetime(year, month, day, hour, minute)
        
    except Exception as e:
        logger.error(f"❌ Error parsing reservation datetime: date_str={date_str}, time_str={time_str}, error={e}")
        return None

